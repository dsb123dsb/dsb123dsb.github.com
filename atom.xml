<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>XX雨中人</title>
  
  <subtitle>纸上得来终觉浅，绝知此事要躬行</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://dsb123dsb.github.io/"/>
  <updated>2018-10-15T13:48:29.630Z</updated>
  <id>https://dsb123dsb.github.io/</id>
  
  <author>
    <name>qijiIng</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>webpack模块化</title>
    <link href="https://dsb123dsb.github.io/2018/10/15/webpack%20treeshaking/"/>
    <id>https://dsb123dsb.github.io/2018/10/15/webpack treeshaking/</id>
    <published>2018-10-15T12:58:12.000Z</published>
    <updated>2018-10-15T13:48:29.630Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>纸上得来终觉浅，绝知此事要躬行</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>很久前看过<code>webpack</code>，入职来一直做小程序快应用相关需求，对于框架和工程化的东西渐渐拉下了，忽然发现webpack都到4.0了，想想之前看还是2.0时代，真是是新月异啊，<code>webpack</code>入门的初始化配置就不再记述，基本看下编译之后的文件就能读明白（普通模块依赖、动态引用编译）主要记述下自己看<code>tree shaking</code>时的坑。</p><h2 id="Tree-Shaking"><a href="#Tree-Shaking" class="headerlink" title="Tree Shaking"></a>Tree Shaking</h2><h4 id="它是何方神圣"><a href="#它是何方神圣" class="headerlink" title="它是何方神圣"></a>它是何方神圣</h4><p>首先介绍下什么是<code>tree shaking</code>，可以理解为通过工具”摇”我们的JS文件，将其中用不到的代码”摇”掉，是一个性能优化的范畴。具体来说，在 <code>webpack</code>项目中，有一个入口文件，相当于一棵树的主干，入口文件有很多依赖的模块，相当于树枝。实际情况中，虽然依赖了某个模块，但其实只使用其中的某些功能。通过<code>tree-shaking</code>，将没有使用的模块摇掉，这样来达到删除无用代码的目的。</p><a id="more"></a><h4 id="how原理"><a href="#how原理" class="headerlink" title="how原理"></a>how原理</h4><p>Tree-shaking 较早由 Rich_Harris 的 rollup 实现，后来，<code>webpack2</code> 也增加了<code>tree-shaking</code> 的功能。</p><p><code>Tree-shaking</code>的本质是消除无用的js代码，这个称之为<code>DCE（dead code elimination）</code>。</p><p><code>Dead Code</code> 一般具有以下几个特征:</p><ul><li>代码不会被执行，不可到达</li><li>代码执行的结果不会被用到</li><li>代码只会影响死变量（只写不读）</li></ul><p>传统编译型的语言中，都是由编译器将<code>Dead Code</code>从AST（抽象语法树）中删除，那javascript中是由谁做DCE呢？</p><p>首先肯定不是浏览器做DCE，因为当我们的代码送到浏览器，那还谈什么消除无法执行的代码来优化呢，所以肯定是送到浏览器之前的步骤进行优化。</p><p>其实也不是通常使用的打包工具<code>rollup、webpack</code>做的，而是著名的代码压缩优化工具uglify，uglify完成了javascript的DCE（本人就是因为知道这一点纠结了很久，5555）。</p><h2 id="看下编译代码"><a href="#看下编译代码" class="headerlink" title="看下编译代码"></a>看下编译代码</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// index.js 入口文件</span></div><div class="line"><span class="keyword">import</span> &#123;cube&#125; <span class="keyword">from</span> <span class="string">'./math.js'</span>;</div><div class="line"><span class="built_in">console</span>.log(cube(<span class="number">5</span>))</div></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// math.js</span></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">x</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> x * x;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">cube</span>(<span class="params">x</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> x * x * x;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>可以看到math.js导出了square和cube两个函数，index.js引入了其中一个，按照前面说的原理编译后不应该存在cube导出的函数的，结果却出乎预料。</p><p>编译后代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/******/</span> (<span class="function"><span class="keyword">function</span>(<span class="params">modules</span>) </span>&#123; <span class="comment">// webpackBootstrap</span></div><div class="line"><span class="comment">/******/</span> <span class="comment">// The module cache</span></div><div class="line"><span class="comment">/******/</span> <span class="keyword">var</span> installedModules = &#123;&#125;;</div><div class="line"><span class="comment">/******/</span></div><div class="line"><span class="comment">/******/</span> <span class="comment">// The require function</span></div><div class="line"><span class="comment">/******/</span> <span class="function"><span class="keyword">function</span> <span class="title">__webpack_require__</span>(<span class="params">moduleId</span>) </span>&#123;</div><div class="line"><span class="comment">/******/</span></div><div class="line"><span class="comment">/******/</span> <span class="comment">// Check if module is in cache</span></div><div class="line"><span class="comment">/******/</span> <span class="keyword">if</span>(installedModules[moduleId]) &#123;</div><div class="line"><span class="comment">/******/</span> <span class="keyword">return</span> installedModules[moduleId].exports;</div><div class="line"><span class="comment">/******/</span> &#125;</div><div class="line"><span class="comment">/******/</span> <span class="comment">// Create a new module (and put it into the cache)</span></div><div class="line"><span class="comment">/******/</span> <span class="keyword">var</span> <span class="built_in">module</span> = installedModules[moduleId] = &#123;</div><div class="line"><span class="comment">/******/</span> i: moduleId,</div><div class="line"><span class="comment">/******/</span> l: <span class="literal">false</span>,</div><div class="line"><span class="comment">/******/</span> exports: &#123;&#125;</div><div class="line"><span class="comment">/******/</span> &#125;;</div><div class="line"><span class="comment">/******/</span></div><div class="line"><span class="comment">/******/</span> <span class="comment">// Execute the module function</span></div><div class="line"><span class="comment">/******/</span> modules[moduleId].call(<span class="built_in">module</span>.exports, <span class="built_in">module</span>, <span class="built_in">module</span>.exports, __webpack_require__);</div><div class="line"><span class="comment">/******/</span></div><div class="line"><span class="comment">/******/</span> <span class="comment">// Flag the module as loaded</span></div><div class="line"><span class="comment">/******/</span> <span class="built_in">module</span>.l = <span class="literal">true</span>;</div><div class="line"><span class="comment">/******/</span></div><div class="line"><span class="comment">/******/</span> <span class="comment">// Return the exports of the module</span></div><div class="line"><span class="comment">/******/</span> <span class="keyword">return</span> <span class="built_in">module</span>.exports;</div><div class="line"><span class="comment">/******/</span> &#125;</div><div class="line"><span class="comment">/******/</span></div><div class="line"><span class="comment">/******/</span></div><div class="line"><span class="comment">/******/</span> <span class="comment">// expose the modules object (__webpack_modules__)</span></div><div class="line"><span class="comment">/******/</span> __webpack_require__.m = modules;</div><div class="line"><span class="comment">/******/</span></div><div class="line"><span class="comment">/******/</span> <span class="comment">// expose the module cache</span></div><div class="line"><span class="comment">/******/</span> __webpack_require__.c = installedModules;</div><div class="line"><span class="comment">/******/</span></div><div class="line"><span class="comment">/******/</span> <span class="comment">// define getter function for harmony exports</span></div><div class="line"><span class="comment">/******/</span> __webpack_require__.d = <span class="function"><span class="keyword">function</span>(<span class="params">exports, name, getter</span>) </span>&#123;</div><div class="line"><span class="comment">/******/</span> <span class="keyword">if</span>(!__webpack_require__.o(exports, name)) &#123;</div><div class="line"><span class="comment">/******/</span> <span class="built_in">Object</span>.defineProperty(exports, name, &#123; <span class="attr">enumerable</span>: <span class="literal">true</span>, <span class="attr">get</span>: getter &#125;);</div><div class="line"><span class="comment">/******/</span> &#125;</div><div class="line"><span class="comment">/******/</span> &#125;;</div><div class="line"><span class="comment">/******/</span></div><div class="line"><span class="comment">/******/</span> <span class="comment">// define __esModule on exports</span></div><div class="line"><span class="comment">/******/</span> __webpack_require__.r = <span class="function"><span class="keyword">function</span>(<span class="params">exports</span>) </span>&#123;</div><div class="line"><span class="comment">/******/</span> <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="built_in">Symbol</span> !== <span class="string">'undefined'</span> &amp;&amp; <span class="built_in">Symbol</span>.toStringTag) &#123;</div><div class="line"><span class="comment">/******/</span> <span class="built_in">Object</span>.defineProperty(exports, <span class="built_in">Symbol</span>.toStringTag, &#123; <span class="attr">value</span>: <span class="string">'Module'</span> &#125;);</div><div class="line"><span class="comment">/******/</span> &#125;</div><div class="line"><span class="comment">/******/</span> <span class="built_in">Object</span>.defineProperty(exports, <span class="string">'__esModule'</span>, &#123; <span class="attr">value</span>: <span class="literal">true</span> &#125;);</div><div class="line"><span class="comment">/******/</span> &#125;;</div><div class="line"><span class="comment">/******/</span></div><div class="line"><span class="comment">/******/</span> <span class="comment">// create a fake namespace object</span></div><div class="line"><span class="comment">/******/</span> <span class="comment">// mode &amp; 1: value is a module id, require it</span></div><div class="line"><span class="comment">/******/</span> <span class="comment">// mode &amp; 2: merge all properties of value into the ns</span></div><div class="line"><span class="comment">/******/</span> <span class="comment">// mode &amp; 4: return value when already ns object</span></div><div class="line"><span class="comment">/******/</span> <span class="comment">// mode &amp; 8|1: behave like require</span></div><div class="line"><span class="comment">/******/</span> __webpack_require__.t = <span class="function"><span class="keyword">function</span>(<span class="params">value, mode</span>) </span>&#123;</div><div class="line"><span class="comment">/******/</span> <span class="keyword">if</span>(mode &amp; <span class="number">1</span>) value = __webpack_require__(value);</div><div class="line"><span class="comment">/******/</span> <span class="keyword">if</span>(mode &amp; <span class="number">8</span>) <span class="keyword">return</span> value;</div><div class="line"><span class="comment">/******/</span> <span class="keyword">if</span>((mode &amp; <span class="number">4</span>) &amp;&amp; <span class="keyword">typeof</span> value === <span class="string">'object'</span> &amp;&amp; value &amp;&amp; value.__esModule) <span class="keyword">return</span> value;</div><div class="line"><span class="comment">/******/</span> <span class="keyword">var</span> ns = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</div><div class="line"><span class="comment">/******/</span> __webpack_require__.r(ns);</div><div class="line"><span class="comment">/******/</span> <span class="built_in">Object</span>.defineProperty(ns, <span class="string">'default'</span>, &#123; <span class="attr">enumerable</span>: <span class="literal">true</span>, <span class="attr">value</span>: value &#125;);</div><div class="line"><span class="comment">/******/</span> <span class="keyword">if</span>(mode &amp; <span class="number">2</span> &amp;&amp; <span class="keyword">typeof</span> value != <span class="string">'string'</span>) <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> value) __webpack_require__.d(ns, key, <span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123; <span class="keyword">return</span> value[key]; &#125;.bind(<span class="literal">null</span>, key));</div><div class="line"><span class="comment">/******/</span> <span class="keyword">return</span> ns;</div><div class="line"><span class="comment">/******/</span> &#125;;</div><div class="line"><span class="comment">/******/</span></div><div class="line"><span class="comment">/******/</span> <span class="comment">// getDefaultExport function for compatibility with non-harmony modules</span></div><div class="line"><span class="comment">/******/</span> __webpack_require__.n = <span class="function"><span class="keyword">function</span>(<span class="params">module</span>) </span>&#123;</div><div class="line"><span class="comment">/******/</span> <span class="keyword">var</span> getter = <span class="built_in">module</span> &amp;&amp; <span class="built_in">module</span>.__esModule ?</div><div class="line"><span class="comment">/******/</span> <span class="function"><span class="keyword">function</span> <span class="title">getDefault</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="built_in">module</span>[<span class="string">'default'</span>]; &#125; :</div><div class="line"><span class="comment">/******/</span> <span class="function"><span class="keyword">function</span> <span class="title">getModuleExports</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="built_in">module</span>; &#125;;</div><div class="line"><span class="comment">/******/</span> __webpack_require__.d(getter, <span class="string">'a'</span>, getter);</div><div class="line"><span class="comment">/******/</span> <span class="keyword">return</span> getter;</div><div class="line"><span class="comment">/******/</span> &#125;;</div><div class="line"><span class="comment">/******/</span></div><div class="line"><span class="comment">/******/</span> <span class="comment">// Object.prototype.hasOwnProperty.call</span></div><div class="line"><span class="comment">/******/</span> __webpack_require__.o = <span class="function"><span class="keyword">function</span>(<span class="params">object, property</span>) </span>&#123; <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.hasOwnProperty.call(object, property); &#125;;</div><div class="line"><span class="comment">/******/</span></div><div class="line"><span class="comment">/******/</span> <span class="comment">// __webpack_public_path__</span></div><div class="line"><span class="comment">/******/</span> __webpack_require__.p = <span class="string">"/Users/zhouyh/codebase/webpack_test/dist"</span>;</div><div class="line"><span class="comment">/******/</span></div><div class="line"><span class="comment">/******/</span></div><div class="line"><span class="comment">/******/</span> <span class="comment">// Load entry module and return exports</span></div><div class="line"><span class="comment">/******/</span> <span class="keyword">return</span> __webpack_require__(__webpack_require__.s = <span class="string">"./src/index.js"</span>);</div><div class="line"><span class="comment">/******/</span> &#125;)</div><div class="line"><span class="comment">/************************************************************************/</span></div><div class="line"><span class="comment">/******/</span> (&#123;</div><div class="line"></div><div class="line"><span class="comment">/***/</span> <span class="string">"./src/index.js"</span>:</div><div class="line"><span class="comment">/*!**********************!*\</span></div><div class="line"><span class="comment">  !*** ./src/index.js ***!</span></div><div class="line"><span class="comment">  \**********************/</span></div><div class="line"><span class="comment">/*! no exports provided */</span></div><div class="line"><span class="comment">/***/</span> (<span class="function"><span class="keyword">function</span>(<span class="params">module, __webpack_exports__, __webpack_require__</span>) </span>&#123;</div><div class="line"></div><div class="line"><span class="meta">"use strict"</span>;</div><div class="line"><span class="built_in">eval</span>(<span class="string">"__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ \"./src/math.js\");\n\nconsole.log(12)\nconsole.log(Object(_math_js__WEBPACK_IMPORTED_MODULE_0__[\"cube\"])(5))\n\n//# sourceURL=webpack:///./src/index.js?"</span>);</div><div class="line"></div><div class="line"><span class="comment">/***/</span> &#125;),</div><div class="line"></div><div class="line"><span class="comment">/***/</span> <span class="string">"./src/math.js"</span>:</div><div class="line"><span class="comment">/*!*********************!*\</span></div><div class="line"><span class="comment">  !*** ./src/math.js ***!</span></div><div class="line"><span class="comment">  \*********************/</span></div><div class="line"><span class="comment">/*! exports provided: square, cube */</span></div><div class="line"><span class="comment">/***/</span> (<span class="function"><span class="keyword">function</span>(<span class="params">module, __webpack_exports__, __webpack_require__</span>) </span>&#123;</div><div class="line"></div><div class="line"><span class="meta">"use strict"</span>;</div><div class="line"><span class="built_in">eval</span>(<span class="string">"__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"square\", function() &#123; return square; &#125;);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"cube\", function() &#123; return cube; &#125;);\nfunction square(x) &#123;\n  return x * x;\n&#125;\n\nfunction cube(x) &#123;\n  return x * x * x;\n&#125;\n\n//# sourceURL=webpack:///./src/math.js?"</span>);</div><div class="line"></div><div class="line"><span class="comment">/***/</span> &#125;)</div><div class="line"></div><div class="line"><span class="comment">/******/</span> &#125;);</div></pre></td></tr></table></figure><p>坑爹的webpack最新版本编译后是eval函数解析了，可读性很差，大家感觉看着不易读可以去网上找找之前版本的，其实主要就是最后那个eval函数，可以看到cube和square函数都有定义，当时花了很多时间调试，比如和babel编译冲突，等等，最后居然发现是开发模式的原因，巨坑啊，webpack文档上写的就是开发模式的，哎，到底还是对原理了解不深，前面也说了tree shaking的原理是使用uglify实现的。</p><p>想想也能理解，开发模式是不开启开启压缩的，接下来看下压缩后的编译代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">! <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</div><div class="line"><span class="keyword">var</span> t = &#123;&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">r</span>(<span class="params">n</span>) </span>&#123;</div><div class="line"><span class="keyword">if</span> (t[n]) <span class="keyword">return</span> t[n].exports;</div><div class="line"><span class="keyword">var</span> o = t[n] = &#123;</div><div class="line">i: n,</div><div class="line">l: !<span class="number">1</span>,</div><div class="line">exports: &#123;&#125;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">return</span> e[n].call(o.exports, o, o.exports, r), o.l = !<span class="number">0</span>, o.exports</div><div class="line">&#125;</div><div class="line">r.m = e, r.c = t, r.d = <span class="function"><span class="keyword">function</span>(<span class="params">e, t, n</span>) </span>&#123;</div><div class="line">r.o(e, t) || <span class="built_in">Object</span>.defineProperty(e, t, &#123;</div><div class="line">enumerable: !<span class="number">0</span>,</div><div class="line">get: n</div><div class="line">&#125;)</div><div class="line">&#125;, r.r = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</div><div class="line"><span class="string">"undefined"</span> != <span class="keyword">typeof</span> <span class="built_in">Symbol</span> &amp;&amp; <span class="built_in">Symbol</span>.toStringTag &amp;&amp; <span class="built_in">Object</span>.defineProperty(e, <span class="built_in">Symbol</span>.toStringTag, &#123;</div><div class="line">value: <span class="string">"Module"</span></div><div class="line">&#125;), <span class="built_in">Object</span>.defineProperty(e, <span class="string">"__esModule"</span>, &#123;</div><div class="line">value: !<span class="number">0</span></div><div class="line">&#125;)</div><div class="line">&#125;, r.t = <span class="function"><span class="keyword">function</span>(<span class="params">e, t</span>) </span>&#123;</div><div class="line"><span class="keyword">if</span> (<span class="number">1</span> &amp; t &amp;&amp; (e = r(e)), <span class="number">8</span> &amp; t) <span class="keyword">return</span> e;</div><div class="line"><span class="keyword">if</span> (<span class="number">4</span> &amp; t &amp;&amp; <span class="string">"object"</span> == <span class="keyword">typeof</span> e &amp;&amp; e &amp;&amp; e.__esModule) <span class="keyword">return</span> e;</div><div class="line"><span class="keyword">var</span> n = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</div><div class="line"><span class="keyword">if</span> (r.r(n), <span class="built_in">Object</span>.defineProperty(n, <span class="string">"default"</span>, &#123;</div><div class="line">enumerable: !<span class="number">0</span>,</div><div class="line">value: e</div><div class="line">&#125;), <span class="number">2</span> &amp; t &amp;&amp; <span class="string">"string"</span> != <span class="keyword">typeof</span> e)</div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> o <span class="keyword">in</span> e) r.d(n, o, <span class="function"><span class="keyword">function</span>(<span class="params">t</span>) </span>&#123;</div><div class="line"><span class="keyword">return</span> e[t]</div><div class="line">&#125;.bind(<span class="literal">null</span>, o));</div><div class="line"><span class="keyword">return</span> n</div><div class="line">&#125;, r.n = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</div><div class="line"><span class="keyword">var</span> t = e &amp;&amp; e.__esModule ? <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line"><span class="keyword">return</span> e.default</div><div class="line">&#125; : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line"><span class="keyword">return</span> e</div><div class="line">&#125;;</div><div class="line"><span class="keyword">return</span> r.d(t, <span class="string">"a"</span>, t), t</div><div class="line">&#125;, r.o = <span class="function"><span class="keyword">function</span>(<span class="params">e, t</span>) </span>&#123;</div><div class="line"><span class="keyword">return</span> <span class="built_in">Object</span>.prototype.hasOwnProperty.call(e, t)</div><div class="line">&#125;, r.p = <span class="string">"/Users/zhouyh/codebase/webpack_test/dist"</span>, r(r.s = <span class="number">0</span>)</div><div class="line">&#125;([<span class="function"><span class="keyword">function</span>(<span class="params">e, t, r</span>) </span>&#123;</div><div class="line"><span class="meta">"use strict"</span>;</div><div class="line">r.r(t), <span class="built_in">console</span>.log(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</div><div class="line"><span class="keyword">return</span> e * e * e</div><div class="line">&#125;(<span class="number">5</span>))</div><div class="line">&#125;]);</div></pre></td></tr></table></figure><p>主要关注最后的立即执行函数传入的参数数组即可,可以看到现在只有用到的cube函数了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">! <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</div><div class="line">&#125;([<span class="function"><span class="keyword">function</span>(<span class="params">e, t, r</span>) </span>&#123;</div><div class="line"><span class="meta">"use strict"</span>;</div><div class="line">r.r(t), <span class="built_in">console</span>.log(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</div><div class="line"><span class="keyword">return</span> e * e * e</div><div class="line">&#125;(<span class="number">5</span>))</div><div class="line">&#125;]);</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;纸上得来终觉浅，绝知此事要躬行&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;很久前看过&lt;code&gt;webpack&lt;/code&gt;，入职来一直做小程序快应用相关需求，对于框架和工程化的东西渐渐拉下了，忽然发现webpack都到4.0了，想想之前看还是2.0时代，真是是新月异啊，&lt;code&gt;webpack&lt;/code&gt;入门的初始化配置就不再记述，基本看下编译之后的文件就能读明白（普通模块依赖、动态引用编译）主要记述下自己看&lt;code&gt;tree shaking&lt;/code&gt;时的坑。&lt;/p&gt;
&lt;h2 id=&quot;Tree-Shaking&quot;&gt;&lt;a href=&quot;#Tree-Shaking&quot; class=&quot;headerlink&quot; title=&quot;Tree Shaking&quot;&gt;&lt;/a&gt;Tree Shaking&lt;/h2&gt;&lt;h4 id=&quot;它是何方神圣&quot;&gt;&lt;a href=&quot;#它是何方神圣&quot; class=&quot;headerlink&quot; title=&quot;它是何方神圣&quot;&gt;&lt;/a&gt;它是何方神圣&lt;/h4&gt;&lt;p&gt;首先介绍下什么是&lt;code&gt;tree shaking&lt;/code&gt;，可以理解为通过工具”摇”我们的JS文件，将其中用不到的代码”摇”掉，是一个性能优化的范畴。具体来说，在 &lt;code&gt;webpack&lt;/code&gt;项目中，有一个入口文件，相当于一棵树的主干，入口文件有很多依赖的模块，相当于树枝。实际情况中，虽然依赖了某个模块，但其实只使用其中的某些功能。通过&lt;code&gt;tree-shaking&lt;/code&gt;，将没有使用的模块摇掉，这样来达到删除无用代码的目的。&lt;/p&gt;
    
    </summary>
    
      <category term="基础杂谈" scheme="https://dsb123dsb.github.io/categories/%E5%9F%BA%E7%A1%80%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="工程化" scheme="https://dsb123dsb.github.io/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
      <category term="webpack" scheme="https://dsb123dsb.github.io/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>数组扁平化</title>
    <link href="https://dsb123dsb.github.io/2018/08/05/%E6%95%B0%E7%BB%84%E6%89%81%E5%B9%B3%E5%8C%96/"/>
    <id>https://dsb123dsb.github.io/2018/08/05/数组扁平化/</id>
    <published>2018-08-05T13:21:03.000Z</published>
    <updated>2018-08-05T13:36:25.836Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>纸上得来终觉浅，绝知此事要躬行</p></blockquote><p>转眼又要开始校招了，组内也要求每人出一道题，忽然就想起自己面试遇到的一道数组扁平化的问题，就顺便温习做下总结。</p><p>题目：请使用尽可能多的方法将一个js嵌套数组转换为只有一层的数组。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span>  arr = [<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]]];</div><div class="line"><span class="built_in">console</span>.log(flatten(arr)) <span class="comment">// [1, 2, 3, 4]</span></div></pre></td></tr></table></figure><a id="more"></a><p>参考答案：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 方法 1，常规深度遍历</span></div><div class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]]];</div><div class="line"></div><div class="line"><span class="keyword">let</span> flatten = <span class="function">(<span class="params">arr</span>)=&gt;</span>  &#123;</div><div class="line">    <span class="keyword">var</span> result = [];</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = arr.length; i &lt; len; i++) &#123;</div><div class="line">        <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.toString.call(arr[i])===<span class="string">'[object Array]'</span>) &#123;</div><div class="line">            result = result.concat(flatten(arr[i]))</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            result.push(arr[i])</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(flatten(arr))</div></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 方法2 遍历，但是使用reduce简化代码</span></div><div class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]]];</div><div class="line"></div><div class="line"><span class="keyword">let</span> flatten = <span class="function">(<span class="params">arr</span>)=&gt;</span> &#123;</div><div class="line">    <span class="keyword">return</span> arr.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">prev, next</span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> prev.concat(<span class="built_in">Object</span>.prototype.toString.call(next)===<span class="string">'[object Array]'</span>? flatten(next) : next)</div><div class="line">    &#125;, [])</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(flatten(arr))</div></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 方法3 遍历 ES6拓展运算符简化代码</span></div><div class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]]];</div><div class="line"></div><div class="line"><span class="keyword">let</span> flatten = <span class="function">(<span class="params">arr</span>)=&gt;</span> &#123;</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (arr.some(<span class="function"><span class="params">item</span> =&gt;</span> <span class="built_in">Object</span>.prototype.toString.call(item)===<span class="string">'[object Array]'</span>)) &#123;</div><div class="line">        arr = [].concat(...arr);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> arr;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(flatten(arr))</div></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 方法4,不使用遍历, JSON.stringify转化为字符串, 正则取出内容，拼接为JSON数组，转为数组（注意转化字符串方法，toString和join会无法处理极端数据如[2, [3.2, ['s,d,w'],'a,b,c,d,e']]</span></div><div class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]]];</div><div class="line"></div><div class="line"><span class="keyword">let</span> flatten = <span class="function">(<span class="params">arr</span>)=&gt;</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">JSON</span>.parse(<span class="string">`[<span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(arr).replace(<span class="regexp">/\[|\]/g</span>, <span class="string">''</span>)&#125;</span>]`</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(flatten(arr))</div></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//方法5，不使用循环，JSON.stringify转化为字符串, 正则取出内容，拼接为JSON数组，JSON.parse转为数组</span></div><div class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]]];</div><div class="line"><span class="keyword">let</span> flatten = <span class="function">(<span class="params">arr</span>)=&gt;</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">JSON</span>.parse(<span class="string">`[<span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(arr).replace(<span class="regexp">/\[|\]/g</span>, <span class="string">''</span>)&#125;</span>]`</span>);</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(flatten(arr))</div></pre></td></tr></table></figure><p>考察知识点：主要考察数组方面知识</p><ol><li>数组类型判断<code>（typeof, Array.isArray, Object.prototype.toString.call(arr)）</code></li><li>数组遍历方法的熟悉reduce、some、 map、concat等，ES6少许知识，以及简化代码的意识</li></ol><p>需要说明的时后面两种不使用遍历的方<code>·JSON.stringify</code>，对于一些数据类型可能不太适用，这是使用时需要注意的。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;纸上得来终觉浅，绝知此事要躬行&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;转眼又要开始校招了，组内也要求每人出一道题，忽然就想起自己面试遇到的一道数组扁平化的问题，就顺便温习做下总结。&lt;/p&gt;
&lt;p&gt;题目：请使用尽可能多的方法将一个js嵌套数组转换为只有一层的数组。例如：&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt;  arr = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, [&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, [&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;]]];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(flatten(arr)) &lt;span class=&quot;comment&quot;&gt;// [1, 2, 3, 4]&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="js" scheme="https://dsb123dsb.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>快应用开发实践踩坑</title>
    <link href="https://dsb123dsb.github.io/2018/07/21/%E5%BF%AB%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5%E8%B8%A9%E5%9D%91/"/>
    <id>https://dsb123dsb.github.io/2018/07/21/快应用开发实践踩坑/</id>
    <published>2018-07-21T12:46:34.000Z</published>
    <updated>2018-08-05T13:25:56.983Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>纸上得来终觉浅，觉知此事要躬行</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    工作后发现写文章的频率变得少了很多，还是要多总结下的，最近在开发公司搜狗搜索快应用，开发最初毫无经验完全对着文档，快速迭代了好几版，也是时候做个总结和吐槽了。、</p><h2 id="快应用是什么？"><a href="#快应用是什么？" class="headerlink" title="快应用是什么？"></a>快应用是什么？</h2><p>借用官方的说法有三点：</p><ol><li>基于手机硬件平台的新型应用形态，标准由主流手机厂商（==仅限安卓==）组成的快应用联盟联合制定。</li><li>快应用标准的诞生将在研发接口、能力接入、开发者服务等层面建设标准平台，以平台化的生态模式对个人开发者和企业开发者全品类开放。</li><li>快应用无需安装、即点即用。</li></ol><p>个人觉得就是应用商店内部的小程序吧，而且还要面临各个厂商的问题，ios缺阵也是一大不爽，无论如何既然作为一种生态还是很有而且无需安装能力也和app相近还是有很大的前景的（参加快应用沙龙指导汽车之间DAU有10w，还是不错的），作为前端人员还是很有学习必要的。</p><a id="more"></a><p>##开发流水账</p><ol><li>开发工具：首先官方提供了开发工具<code>hap-toolkit</code> 和快应用调试器（直接下载安装，支持扫码本地安装）,具体开发可参见文档，值得注意的是使用hap开发时，如果升级了hap版本，要记得在项目目录下执行<code>hap update</code> 不然后面执行hap命令打包会出问题。说到打包，打包签名包后要想使用调试器本地安装要记得先清空系统快应用缓存。快应用官方没有ide，华为自己开发了一个ide，为了和ide搭配又开发了个调试器，很坑，在官方调试器没问题，放到华为调试器上会报一堆错误，，目前还没完美解决。真希望对于开发工具和标准能做到统一啊</li><li>全局配置<code>manifest.json</code>文件:包括项目的一些基本信息，和全局配置项和全局数据，比如标题栏、debug级别、路由、最低平台、菜单、页面设计基准等</li><li>样式：样式感觉比较坑，支持特别少，盒模型border-box模型，布局不支持绝对定位，想要灵活定位只能使用stack组件</li><li>路由：支持新增、替换、回退路由，并且能获取当前路由页面栈，路由可以传递参数，路由页面可以通过<code>this.params</code>取到，实际中发现死活去不到，最后发现要想渠道商必须在页面public对象内定义</li><li>web组件：我们搜索结果页是使用的webview，发现某些case下页面会特别卡顿，最后偶然发现web组件是直接暴漏在template下的，外面包一层div，就可以解决webview内部再次搜索卡顿，也是侥幸能发现这个问题的解决方案。</li><li>输入框输入某些case 出sug框时会莫名闪退，以为我们为了提高list组件滚动性能把搜索框放进了list组件内部，接着就出现了某些查询词时闪退，反复验证搜索框放在外面就不会，后面考虑到既然是因为sug直接暴漏在在list内部会闪退，那我们就把sug框也放进list内部进行嵌套，果然解决了闪退问题</li><li>list组件滚动有个坑，通过scrollTo事件到顶时不会触发到顶事件,在tab组件内嵌套时外部也不能跟着滚动，嵌套list内部list不识别三元判别(不识别绑定数据变化)，tab组件直接嵌套list滚动置顶会有一个tab的距离差值，list外面包一层div</li><li>接口问题：这个感觉最不合理的，他们接口竟然几乎全部都是异步接口，这让对数据流有所要求的地方写起来极其别扭，彷佛回到回调地狱</li><li>父子组件传递参数不能用驼峰，这个被坑了好几次</li><li>channelReady判断不准，false也可以吊起，吊起url参数长度限制，吊起也必须关闭代理</li><li>push消息：push消息有最低版本要求，而且用户必须创建桌面图标才能收到</li><li>最后吐槽：文档很多使用地方写的很不详细，而且厂商有变动的地方开发者也无法第一时间得知，从而多浪费很多时间。</li></ol><p>最后，希望快应用能越来也好吧，自己技术也能越来越进步。</p><p>，</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;纸上得来终觉浅，觉知此事要躬行&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;​    工作后发现写文章的频率变得少了很多，还是要多总结下的，最近在开发公司搜狗搜索快应用，开发最初毫无经验完全对着文档，快速迭代了好几版，也是时候做个总结和吐槽了。、&lt;/p&gt;
&lt;h2 id=&quot;快应用是什么？&quot;&gt;&lt;a href=&quot;#快应用是什么？&quot; class=&quot;headerlink&quot; title=&quot;快应用是什么？&quot;&gt;&lt;/a&gt;快应用是什么？&lt;/h2&gt;&lt;p&gt;借用官方的说法有三点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;基于手机硬件平台的新型应用形态，标准由主流手机厂商（==仅限安卓==）组成的快应用联盟联合制定。&lt;/li&gt;
&lt;li&gt;快应用标准的诞生将在研发接口、能力接入、开发者服务等层面建设标准平台，以平台化的生态模式对个人开发者和企业开发者全品类开放。&lt;/li&gt;
&lt;li&gt;快应用无需安装、即点即用。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;个人觉得就是应用商店内部的小程序吧，而且还要面临各个厂商的问题，ios缺阵也是一大不爽，无论如何既然作为一种生态还是很有而且无需安装能力也和app相近还是有很大的前景的（参加快应用沙龙指导汽车之间DAU有10w，还是不错的），作为前端人员还是很有学习必要的。&lt;/p&gt;
    
    </summary>
    
      <category term="编程实战" scheme="https://dsb123dsb.github.io/categories/%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="快应用" scheme="https://dsb123dsb.github.io/tags/%E5%BF%AB%E5%BA%94%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>lint-staged和husky在pre-commit阶段做代码检查</title>
    <link href="https://dsb123dsb.github.io/2018/05/26/lint-staged%E5%92%8Chusky%E5%9C%A8pre-commit%E9%98%B6%E6%AE%B5%E5%81%9A%E4%BB%A3%E7%A0%81%E6%A3%80%E6%9F%A5/"/>
    <id>https://dsb123dsb.github.io/2018/05/26/lint-staged和husky在pre-commit阶段做代码检查/</id>
    <published>2018-05-26T01:49:24.000Z</published>
    <updated>2018-05-26T02:51:28.162Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>纸上得来终终觉浅，绝知此事要躬行</p></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前几天给项目代码加eslint，并且使用lint-staged和husky在pre-commit阶段做代码检查，也踩了个坑，这里对这两个npm包作简要介绍。</p><h1 id="为什么使用"><a href="#为什么使用" class="headerlink" title="为什么使用"></a>为什么使用</h1><p>通常项目中我们通过<code>eslint</code>和<code>stylelint</code>这些lint工具来检查代码的规范与否，保证良好的代码规范，从而在多人协作中保障项目质量和可维护性。正常我们会在提交代码前手动执行语法检查，而<code>lint-staged</code>和<code>husky</code>而让这一过程自动化，在git的pre-commit阶段来检测你的代码，如果存在语法错误会中断commit。</p><a id="more"></a><h1 id="husky"><a href="#husky" class="headerlink" title="husky"></a>husky</h1><p><a href="https://github.com/typicode/husky" target="_blank" rel="external">husky</a>可以让git hooks的使用变得更简单方便。运行<code>npm install husky@next --save-dev</code>安装最新版本，它会在我们项目根目录下面的<code>.git/hooks</code>文件夹下面创建<code>pre-commit</code>、<code>pre-push</code>等hooks。这些hooks可以让我们直接在<code>package.json</code>的<code>script</code>里运行我们想要在某个hook阶段执行的命令。</p><p>版本0.14之后配置有所改变，之前不知道npm安装使用@next会安装最新开发版本，一直安装稳定版本却使用心得配置，也算踩的坑吧，具体配置：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">// package.json， 最新版本</div><div class="line">&#123;</div><div class="line">  <span class="attr">"husky"</span>: &#123;</div><div class="line">    <span class="attr">"hooks"</span>: &#123;</div><div class="line">      <span class="attr">"pre-commit"</span>: <span class="string">"npm test"</span>,</div><div class="line">      <span class="attr">"pre-push"</span>: <span class="string">"npm test"</span>,</div><div class="line">      <span class="attr">"..."</span>: <span class="string">"..."</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">// package.json 版本0.14之前</div><div class="line">&#123;  <span class="attr">"scripts"</span>: &#123;    </div><div class="line"><span class="attr">"precommit"</span>: <span class="string">"npm test"</span>,  </div><div class="line">    <span class="attr">"prepush"</span>: <span class="string">"npm test"</span>,  </div><div class="line">    <span class="attr">"..."</span>: <span class="string">"..."</span>  </div><div class="line"> &#125;&#125;</div></pre></td></tr></table></figure><p>而仅使用husky在提交代码时会检查所有文件，我们肯定不希望这样，仅仅检查git add .的文件才是我们期望的。</p><h1 id="lint-staged"><a href="#lint-staged" class="headerlink" title="lint-staged"></a>lint-staged</h1><p><a href="https://github.com/okonet/lint-staged" target="_blank" rel="external">lint-staged</a>可以在git staged阶段的文件上执行linters，简单点来说就是当我们运行<code>eslint</code>或<code>stylelint</code>的命令时，只会检查我们通过<code>git add</code>添加到暂存区的文件，可以避免我们每次检查都把整个项目的代码都检查一遍。</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// package.json</div><div class="line">"lint-staged": &#123;</div><div class="line">    "*.js": ["eslint --fix", "git add"]</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;纸上得来终终觉浅，绝知此事要躬行&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;前几天给项目代码加eslint，并且使用lint-staged和husky在pre-commit阶段做代码检查，也踩了个坑，这里对这两个npm包作简要介绍。&lt;/p&gt;
&lt;h1 id=&quot;为什么使用&quot;&gt;&lt;a href=&quot;#为什么使用&quot; class=&quot;headerlink&quot; title=&quot;为什么使用&quot;&gt;&lt;/a&gt;为什么使用&lt;/h1&gt;&lt;p&gt;通常项目中我们通过&lt;code&gt;eslint&lt;/code&gt;和&lt;code&gt;stylelint&lt;/code&gt;这些lint工具来检查代码的规范与否，保证良好的代码规范，从而在多人协作中保障项目质量和可维护性。正常我们会在提交代码前手动执行语法检查，而&lt;code&gt;lint-staged&lt;/code&gt;和&lt;code&gt;husky&lt;/code&gt;而让这一过程自动化，在git的pre-commit阶段来检测你的代码，如果存在语法错误会中断commit。&lt;/p&gt;
    
    </summary>
    
      <category term="tools" scheme="https://dsb123dsb.github.io/categories/tools/"/>
    
    
      <category term="工程化" scheme="https://dsb123dsb.github.io/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>北漂初感</title>
    <link href="https://dsb123dsb.github.io/2018/04/15/%E5%8C%97%E6%BC%82%E5%88%9D%E6%84%9F/"/>
    <id>https://dsb123dsb.github.io/2018/04/15/北漂初感/</id>
    <published>2018-04-15T12:09:55.000Z</published>
    <updated>2018-04-15T12:52:23.217Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>纸上得来终觉浅，绝知此事要躬行</p></blockquote><p>转眼来北京四天了，过了第一个周末，也渐渐重新适应北方的气候，变成了原来自己眼里有些傻傻的戴口罩的匆匆行人，作为北方出生的汉纸在南方呆了几年竞变得不适应自己土生土长的北方土地，内心难免产生些许情绪。行走在北京校园的街头，看着遍地的杨树，在这个最好的季节，仿佛梦回幼时的家乡，原来我的内心深处一直对故乡的一切有着深深的眷恋，一点点相似的物事便已暴露，几年江南烟雨的温柔婉约也不能将之改变。</p><p>工作上第一次进入这么大的前端组，充满兴奋和忐忑，周五分享会想也了解到组内的一些业务和技术情况，有些业务技术虽然很老，但也看到组内积极想新技术转变的决心和努力，希望自己能够在这个过程获得成长和作出贡献。这里的也充满挑战，linux开发流程，偏后端知识的学习（ngnix，java），vue，微信小程序等等，有挑战才有进步，加油，期待两年后的自己。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;纸上得来终觉浅，绝知此事要躬行&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;转眼来北京四天了，过了第一个周末，也渐渐重新适应北方的气候，变成了原来自己眼里有些傻傻的戴口罩的匆匆行人，作为北方出生的汉纸在南方呆了几年竞变得不适应自己土生土长的北方土地，
      
    
    </summary>
    
      <category term="生活随笔" scheme="https://dsb123dsb.github.io/categories/%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="北漂" scheme="https://dsb123dsb.github.io/tags/%E5%8C%97%E6%BC%82/"/>
    
  </entry>
  
  <entry>
    <title>原生WebGL小试牛刀</title>
    <link href="https://dsb123dsb.github.io/2018/01/09/%E5%8E%9F%E7%94%9FWebGL%E5%B0%8F%E8%AF%95%E7%89%9B%E5%88%80/"/>
    <id>https://dsb123dsb.github.io/2018/01/09/原生WebGL小试牛刀/</id>
    <published>2018-01-09T11:35:28.000Z</published>
    <updated>2018-01-09T12:51:05.757Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>纸上得来终觉浅，绝知此事要躬行</p></blockquote><h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>​    最近学习WebGL，各个知识点讲解比较分散，自己把整理了下知识点，并综合起来写了简单demo，学习中也感觉到3D图形制作知识的繁杂，当时看懂了其实并未太懂，只有不断学习消化。友情提醒，由于本地测试要访问文件图片，所以要使用命令<code>open -a &quot;Google Chrome&quot; --args --allow-file-access-from-files</code>。本文仅是个人总结，先介绍初始化着色器、纹理、阴影，后续细节会继续整理增加，先看下demo。</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fnallq6sa7g30bf07074m.gif" alt=""></p><a id="more"></a><h1 id="我们开始吧"><a href="#我们开始吧" class="headerlink" title="我们开始吧"></a>我们开始吧</h1><h2 id="初始化着色器程序"><a href="#初始化着色器程序" class="headerlink" title="初始化着色器程序"></a>初始化着色器程序</h2><p>​    书中开始一直使用<code>initShaders()</code>函数，隐藏了创建着色器和程序对象的细节，其中着色器对象管理一个顶点着色器或者一个片元着色器，程序对象管理着色器对象的容器，具体包括下面七个步骤：</p><ol><li><p><code>gl.createShader(type)</code>创建着色器对象，根据传入的参数</p></li><li><p><code>gl.shaderSource(shader, source)</code> 指定着色器对象的代码GLSL ES源代码</p></li><li><p><code>gl.compileShader(shader)</code>向着色器传入源代码后，还需要进行编译才能使用（二进制可执行格式）,调用gl.getShaderParameter(shader, pname)函数来检查着色器状态。</p></li><li><p><code>gl.createProgram()</code>创建程序对象</p></li><li><p><code>gl.attachShader(progtam,shader)</code>为程序对象分配着色器对象</p></li><li><p><code>gl.linkProgram(program</code>)为程序对象分配着色器对象后，还需要将（顶点和片元）着色器连接起来，调用<code>gl.getProgramParameters(program,pname)</code>检查是否连接成功，调用<code>gl.getProgramInfoLog()</code>获取连接出错信息</p></li><li><p><code>gl.useProgram()</code>告知WebGL系统所使用的程序对象，可以在绘制前准备多个程序对象，然后在绘制时根据需要切换程序对象。</p><p>然后根据这七个步骤分成了封装成了三个流程即最前面提到的<code>initShaders()</code>函数，内部调用<code>createProgram()</code>,它内部又会调用<code>loaderShader()</code>    ，后者负责创建一个编译好的着色器对象。</p></li></ol><p>##纹理一二须知</p><p>​    首先知道纹理映射：texture mapping,即将一张图像映射到一个几何图形的表面 。具体步骤：</p><ul><li>准备好映射到几何图形的纹理图像（需要先加载好图像）</li><li><p>为几何图形配置纹理映射方式（利用图形的顶点确定屏幕上哪部分被纹理图像覆盖，使用纹理坐标texture coordinate（纹理坐标很通用，坐标值与图像自身的尺寸无关）确定纹理图像的哪部分将覆盖到几何图形上）。</p><p>​通过纹理图像的纹理坐标与几何形体顶点坐标的映射关系确定怎样将纹理图像贴上去。WebGL中无法直接操作纹理对象，必须将纹理对象绑定到纹理单元上，间接操作。顶点之间的片元的纹理坐标会在光栅化的过程中内插出来。纹理单元机制可以同时使用多个纹理，默认下至少支持8个纹理</p></li></ul><p>##渲染到纹理</p><p>​    渲染到纹理是把渲染结果作为纹理使用，动态的生成图像，不是像服务器请求加载图像（在纹理图像被贴上图像被贴上图形之前还可以对其做一些额外处理，比如动态模糊或景深效果）。</p><p>​    通常WebGL在颜色缓冲区中进行绘制，在开启隐藏面消除功能时还会用到深度缓冲区，总之绘制结果存储在颜色缓冲区中。而帧缓冲区对象(framebuffer object)可以用来替代颜色缓冲区或深度缓冲区，可以先对帧缓冲区中的内容进行一些处理再显示或者直接用其中的内容作为纹理图像，被称为<strong>离屏绘制</strong>(offscreen drawing)。一个帧缓冲区有三个关联对象：颜色关联对象(color attachment)、深度关联区(depth attachment)和模板关联区(stencil attachment)，分别用来替换颜色缓冲区、深度缓冲区、模板缓冲区。每个关联对象又有两种类型：纹理对象和渲染缓冲区，具体步骤如下：</p><ul><li>创建帧缓冲区：<code>framebuffer = gl.createFramebuffer()</code>，创建之后还需要将其颜色关联对象指定为一个纹理对象，将其深度关联对象指定为一个渲染缓冲区对象</li><li>创建纹理对象并设置其尺寸和参数：<code>texture=gl.createTexture()，gl.bindTexture(gl.TEXTURE_2D,texture), gl.textImage2D(gl.TEXTURE_2D,0,gl.RGBA,OFFSCREEN_WIDTH,OFFSCREEN_HEIGHT,0,gl.RGBA,gl.UNSIGNED_BYTE,null)</code>存储纹理高宽，最后一个参数设为null可以新建一块空白区域, <code>gl.textParameteri(gl.TEXTURE_MIN_FILTER,gl.LINEAR)</code>;</li><li>创建渲染缓冲区对象: <code>depthBuffer = gl.createRenderbuffer()</code></li><li>绑定渲染缓冲区并设置其尺寸：<code>gl.bindRenderbuffer(gl.RENDERBUFFER, depthBuffer); gl.renderbufferStorage(gl.RENDER, gl.DEPTH_COMPONENT16, OFFSCREEn_WIDTH, OFFSCREEN_HEIGHT);</code> 深度关联对象的渲染缓冲区，其宽度和高度必须与作为颜色关联对象的纹理缓冲区一致。</li><li>将纹理对象关联到帧缓冲区：<code>gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer)</code>绑定帧缓冲区。<code>gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D,texture,0)</code>关联</li><li><p>将渲染缓冲区对象关联到帧缓冲区: <code>gl.framebufferRenderbuffer(gl.FRAMEBUFFER,gl.DEPTH_ATTAACHMENT, gl.RENDERBUFFER, depthBuffer)</code></p></li><li><p>检查帧缓冲区的配置： <code>gl.checkFramebufferStatus(gl.FRAMEBUFFER)</code>（返回<code>gl.FRAMEBUFFER_COMPLETE</code>表示正确配置）</p></li><li>在帧缓冲区进行绘图：首先切换目标未帧缓冲区对象fbo，并在其颜色关联对象既在纹理对象上绘制立方体，然后切换绘制目标到canvas在颜色缓冲区绘制矩形同时把上一步在纹理对象中绘制的图像贴到矩形表面。</li></ul><h2 id="绘制阴影"><a href="#绘制阴影" class="headerlink" title="绘制阴影"></a>绘制阴影</h2><p>绘制过程可以简要概述为：一对着色器用来计算光源到物体的距离，另一对着色器根据一中计算出的距离。使用一张纹理图像把一中结果传入二中，这张纹理图像就被称为阴影贴图（shadow map），而通过阴影贴图实现阴影的方法就是阴影映射（shadow mapping），具体分为两步：</p><ol><li>将视点移到光源位置处，并运行第一个着色器，这是那些“要被绘制”的片元都是被照射到的，我们并不实际绘制片元，而是将其z值写入阴影贴图。</li><li>将视点移回原来位置，运行第二对着色器绘制场景，此时需要计算每个片元在光源坐标系中的坐标，并与阴影贴图中记录的值比较，如果前者大于后者，则说明在阴影中，使用较暗的颜色绘制。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;纸上得来终觉浅，绝知此事要躬行&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;​    最近学习WebGL，各个知识点讲解比较分散，自己把整理了下知识点，并综合起来写了简单demo，学习中也感觉到3D图形制作知识的繁杂，当时看懂了其实并未太懂，只有不断学习消化。友情提醒，由于本地测试要访问文件图片，所以要使用命令&lt;code&gt;open -a &amp;quot;Google Chrome&amp;quot; --args --allow-file-access-from-files&lt;/code&gt;。本文仅是个人总结，先介绍初始化着色器、纹理、阴影，后续细节会继续整理增加，先看下demo。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws4.sinaimg.cn/large/006tNc79gy1fnallq6sa7g30bf07074m.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="编程实战" scheme="https://dsb123dsb.github.io/categories/%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="WebGL" scheme="https://dsb123dsb.github.io/tags/WebGL/"/>
    
  </entry>
  
  <entry>
    <title>参加D2论坛的一二收获想法</title>
    <link href="https://dsb123dsb.github.io/2017/12/17/%E5%8F%82%E5%8A%A0D2%E8%AE%BA%E5%9D%9B%E7%9A%84%E4%B8%80%E4%BA%8C%E6%94%B6%E8%8E%B7%E6%83%B3%E6%B3%95/"/>
    <id>https://dsb123dsb.github.io/2017/12/17/参加D2论坛的一二收获想法/</id>
    <published>2017-12-17T14:13:35.000Z</published>
    <updated>2017-12-17T14:45:04.428Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>纸上得来终觉浅，绝知此事要躬行</p></blockquote><p>今年第二次参加D2，相比去年新入行听的们懵懵懂懂，经过一年洗礼，今年听的能有些体会也有选择性的听了一些主题。</p><p>前几天参加GDD，谷歌发了Android Things，所以对于<strong>IoT</strong>比较感兴趣，而且也算前端的一个新的方向吧，上午去的比较迟，到的时候已经讲了一部分，讲师对于应用的实现分别用js和java、python都实现了，不过也谈到存在效率问题，实际落地使用的java，动态语言仅仅内部比赛idea时开发，不得不说很遗憾，不论如何重在尝试，希望自己也写个demo出来。</p><a id="more"></a><p>高性能react同构方案：在SPA时代，同构能够很好弥补客户端渲染不足，提升用户体验，讲师分享了beidou框架，也讲了同构常见的内存泄漏的排查和解决提出cpuProfile，它们自己开发的一个工具。具体性能优化部分就是不断修改代码：插件》prodcution 》缓存》node8》升级react16，应该还有方法记不住了。最后数据很惊人；还提到<strong>智能降级</strong>很感兴趣，查了下就是当流量暴增，接近或超过阈值时，会直接导致服务的RT快速上升。可以实时监测CPU和内存的使用率，超过一定的比例自动降级为客户端渲染，降低服务端压力，CPU和内存恢复常态时，自动切回服务端渲染。最后讲师提到的方法论很有启迪意义：上面提到的优化性能策略很多迟早都会过时，比如react16 ssr重构后，之前的组件级别缓存逻辑不再有效，真正的方法就是我们可以在代码层面定位到底应用慢在那个地方，从而针对性的改进（具体工具方法有点记不清了，回去在看下视频）。</p><p>很佩服贺师俊老师的，对于技术的纯粹追求和刨根问题的态度在演讲中表现的淋淋尽致，从Fastify的JSON解析优化快在哪里，到性能的基准测试，console.time由于抢占式多任务系统的测不准，64HZ级数导致的精度15ms，自己有些之前虽然略有了解不过并没有像今天贺老这般带着深入根源。</p><p>还有腾讯小伙伴分享的PWA，因为之前在GDD听了很多这方面东西，所以了解较多，但是也有一些新的体会，比如具体缓存设置和service worker的一些细节，但是自己也体验了PWA，感觉体验确实非常好；不过感觉PWA和微信小程序是对立的哈，哈哈</p><p>后面对于一些主题也很感兴趣，比如前端监控和http2，不过由于有事只能先走，后面有空去看回放视频吧。</p><p>虽然这次被小伙伴放鸽子，自己一个人去，但是看到前端有这么磨多优秀的前辈，也给予我无限前进动力，加油！！！</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;纸上得来终觉浅，绝知此事要躬行&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;今年第二次参加D2，相比去年新入行听的们懵懵懂懂，经过一年洗礼，今年听的能有些体会也有选择性的听了一些主题。&lt;/p&gt;
&lt;p&gt;前几天参加GDD，谷歌发了Android Things，所以对于&lt;strong&gt;IoT&lt;/strong&gt;比较感兴趣，而且也算前端的一个新的方向吧，上午去的比较迟，到的时候已经讲了一部分，讲师对于应用的实现分别用js和java、python都实现了，不过也谈到存在效率问题，实际落地使用的java，动态语言仅仅内部比赛idea时开发，不得不说很遗憾，不论如何重在尝试，希望自己也写个demo出来。&lt;/p&gt;
    
    </summary>
    
      <category term="生活随笔" scheme="https://dsb123dsb.github.io/categories/%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="D2" scheme="https://dsb123dsb.github.io/tags/D2/"/>
    
  </entry>
  
  <entry>
    <title>css揭秘中的一些技巧</title>
    <link href="https://dsb123dsb.github.io/2017/11/17/css%E6%8F%AD%E7%A7%98%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E6%8A%80%E5%B7%A7/"/>
    <id>https://dsb123dsb.github.io/2017/11/17/css揭秘中的一些技巧/</id>
    <published>2017-11-17T07:13:40.000Z</published>
    <updated>2017-11-17T08:31:20.150Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>纸上得来终觉浅，绝知此事要躬行</p></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>看完css揭秘，对表现和结构分离的理解更加深刻，之前写样式只求能做出来，对于结构有多复杂，代码有多冗余，并没有太多考虑，或者心有余而力不足，之前也没有真正认真进阶学习过css，读完此书，css magical不虚此名。</p><h1 id="偷师技巧一二"><a href="#偷师技巧一二" class="headerlink" title="偷师技巧一二"></a>偷师技巧一二</h1><p>个人总结了下，让css变得如魔法一般的有以下几个：</p><ol><li><p>巧用渐变</p></li><li><p>善用阴影</p></li><li><p>令人激动的动画和过渡的一些部位常人熟知的属性：<code>animation-play-state;animation-direction;steps()</code></p><a id="more"></a></li></ol><h3 id="毛玻璃效果"><a href="#毛玻璃效果" class="headerlink" title="毛玻璃效果"></a>毛玻璃效果</h3><p><strong>要点</strong>：父元素背景，子元素模糊（半透明处理，溢出隐藏，伪元素模糊放filter:blur()在子元素下面，负边距处理边缘）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Frosted glass effect</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"><span class="selector-tag">body</span> &#123;</div><div class="line"><span class="attribute">min-height</span>: <span class="number">100vh</span>;</div><div class="line"><span class="attribute">box-sizing</span>: border-box;</div><div class="line"><span class="attribute">margin</span>: <span class="number">0</span>;</div><div class="line"><span class="attribute">padding-top</span>: <span class="built_in">calc</span>(50vh - 6em);</div><div class="line"><span class="attribute">font</span>: <span class="number">150%</span>/<span class="number">1.6</span> Baskerville, Palatino, serif;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-tag">body</span>, <span class="selector-tag">main</span><span class="selector-pseudo">::before</span> &#123;</div><div class="line"><span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">"http://csssecrets.io/images/tiger.jpg"</span>) <span class="number">0</span> / cover fixed;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-tag">main</span> &#123;</div><div class="line"><span class="attribute">position</span>: relative;</div><div class="line"><span class="attribute">margin</span>: <span class="number">0</span> auto;</div><div class="line"><span class="attribute">padding</span>: <span class="number">1em</span>;</div><div class="line"><span class="attribute">max-width</span>: <span class="number">23em</span>;</div><div class="line"><span class="attribute">background</span>: <span class="built_in">hsla</span>(0,0%,100%,.25) border-box;</div><div class="line"><span class="attribute">overflow</span>: hidden;</div><div class="line"><span class="attribute">border-radius</span>: .<span class="number">3em</span>;</div><div class="line"><span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1px</span> <span class="built_in">hsla</span>(0,0%,100%,.3) inset,</div><div class="line">            <span class="number">0</span> .<span class="number">5em</span> <span class="number">1em</span> <span class="built_in">rgba</span>(0, 0, 0, 0.6);</div><div class="line"><span class="attribute">text-shadow</span>: <span class="number">0</span> <span class="number">1px</span> <span class="number">1px</span> <span class="built_in">hsla</span>(0,0%,100%,.3);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-tag">main</span><span class="selector-pseudo">::before</span> &#123;</div><div class="line"><span class="attribute">content</span>: <span class="string">''</span>;</div><div class="line"><span class="attribute">position</span>: absolute;</div><div class="line"><span class="attribute">top</span>: <span class="number">0</span>; <span class="attribute">right</span>: <span class="number">0</span>; <span class="attribute">bottom</span>: <span class="number">0</span>; <span class="attribute">left</span>: <span class="number">0</span>;</div><div class="line"><span class="attribute">margin</span>: -<span class="number">30px</span>;</div><div class="line"><span class="attribute">z-index</span>: -<span class="number">1</span>;</div><div class="line"><span class="attribute">-webkit-filter</span>: <span class="built_in">blur</span>(20px);</div><div class="line"><span class="attribute">filter</span>: <span class="built_in">blur</span>(20px);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-tag">blockquote</span> &#123; <span class="attribute">font-style</span>: italic &#125;</div><div class="line"><span class="selector-tag">blockquote</span> <span class="selector-tag">cite</span> &#123; <span class="attribute">font-style</span>: normal; &#125;</div></pre></td></tr></table></figure><h3 id="文本行的斑马纹效果"><a href="#文本行的斑马纹效果" class="headerlink" title="文本行的斑马纹效果"></a>文本行的斑马纹效果</h3><p>斑马纹可以帮助把人们视线保持在长条水平空间内，众所周知表格的斑马纹可使用伪类选择器<code>tr:nth-child(even)</code>实现，文本行的可以使用渐变背景实现</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">padding</span><span class="selector-pseudo">:.5em</span>;</div><div class="line"><span class="selector-tag">line-height</span><span class="selector-pseudo">:1.5em</span>;</div><div class="line"><span class="selector-tag">background</span><span class="selector-pseudo">:beige</span>;</div><div class="line"><span class="selector-tag">background-size</span><span class="selector-pseudo">:auto</span> 3<span class="selector-tag">em</span>;</div><div class="line"><span class="selector-tag">background-origin</span><span class="selector-pseudo">:content-box</span>;<span class="comment">/*背景相对content-box定位，从而保持和文本对齐*/</span></div><div class="line"><span class="selector-tag">background-image</span><span class="selector-pseudo">:linear-gradient(rgba(0</span>,0,0,<span class="selector-class">.2</span>) 50%, <span class="selector-tag">transparent</span> 0);<span class="comment">/*渐变第二个角标中0表示和前面角标的值相同*/</span></div></pre></td></tr></table></figure><h3 id="自适应内部元素"><a href="#自适应内部元素" class="headerlink" title="自适应内部元素"></a>自适应内部元素</h3><p>如果不给内部元素制定一个height，他就会自动适应内容高度，而块级元素通常独占一行，如果我们希望它也这样 <code>max-width:min-content；</code></p><h3 id="满幅背景"><a href="#满幅背景" class="headerlink" title="满幅背景"></a>满幅背景</h3><p>很多时候我们希望背景满幅，内容定宽</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&lt;!<span class="selector-tag">--1</span><span class="selector-class">.0--</span>&gt;</div><div class="line"><span class="selector-tag">footer</span> &#123;</div><div class="line"><span class="attribute">background</span>: <span class="number">#333</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.wrapper</span> &#123;</div><div class="line"><span class="attribute">max-width</span>: <span class="number">900px</span>;</div><div class="line"><span class="attribute">margin</span>: <span class="number">1em</span> auto;</div><div class="line">&#125;</div><div class="line">&lt;!<span class="selector-tag">--2</span><span class="selector-class">.0--</span>&gt;</div><div class="line"><span class="selector-tag">footer</span> &#123;</div><div class="line">    <span class="attribute">padding</span>: <span class="number">1em</span>;</div><div class="line">    <span class="attribute">padding</span>: <span class="number">1em</span> <span class="built_in">calc</span>(50% - 450px);</div><div class="line">    <span class="attribute">background</span>: <span class="number">#333</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>2.0中减少了内层多余的一层结构样式</p><h3 id="sticky-footer"><a href="#sticky-footer" class="headerlink" title="sticky-footer"></a>sticky-footer</h3><p>这是一种常见的布局，之前我们会使用计算高度<code>min-height:calc(100vh-footer)</code>,但是每当我们改变页脚尺寸或者折行时就会出现问题；更好的方法是使用flex布局，非footer部分设置<code>flex:1;</code>即可</p><h3 id="逐帧动画"><a href="#逐帧动画" class="headerlink" title="逐帧动画"></a>逐帧动画</h3><p><code>animation:loader 1s inifinite steps(8)</code>硬切为8部分，仅用css制作动图（动图切成多帧合并在一幅图上）</p><h3 id="闪烁效果"><a href="#闪烁效果" class="headerlink" title="闪烁效果"></a>闪烁效果</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*1.平滑闪烁*/</span></div><div class="line">@<span class="keyword">keyframes</span> blink-smooth &#123;<span class="selector-tag">to</span> &#123;<span class="attribute">color</span>:transparent;&#125;&#125;</div><div class="line"><span class="selector-class">.highlight</span> &#123;</div><div class="line">    <span class="attribute">animation</span>:.<span class="number">5s</span> blink-smooth <span class="number">6</span> alternate;<span class="comment">/*alternate为animation-direction*/</span></div><div class="line">&#125;</div><div class="line"><span class="comment">/*2.普通闪烁*/</span></div><div class="line">@<span class="keyword">keyframes</span> blink &#123;50% &#123;<span class="attribute">color</span>:transparent;&#125;&#125;</div><div class="line"><span class="selector-class">.highlight</span> &#123;</div><div class="line">    <span class="attribute">animation</span>:<span class="number">1s</span> blink <span class="number">3</span> <span class="built_in">steps</span>(1);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="状态平稳动画"><a href="#状态平稳动画" class="headerlink" title="状态平稳动画"></a>状态平稳动画</h3><p>有一些动画，比如交互性的：鼠标hover时动画，离开终止，我们希望动画暂停而不是突兀切回初始状态，可使用<code>animation-play-state:pause/running;</code>控制</p><h3 id="打字效果"><a href="#打字效果" class="headerlink" title="打字效果"></a>打字效果</h3><p>利用动画逐渐增加文本宽度</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">@<span class="keyword">keyframes</span> typing &#123;</div><div class="line">    <span class="selector-tag">from</span> &#123; <span class="attribute">width</span>: <span class="number">0</span> &#125;</div><div class="line">&#125;</div><div class="line">@<span class="keyword">keyframes</span> caret &#123;</div><div class="line">    50% &#123; <span class="attribute">border-color</span>: transparent; &#125;</div><div class="line">&#125;</div><div class="line"><span class="selector-tag">h1</span> &#123;</div><div class="line">    <span class="attribute">width</span>: <span class="number">15ch</span>; <span class="comment">/* 文本的宽度 可能有兼容问题，可设置固定来优雅回退*/</span></div><div class="line">    <span class="attribute">overflow</span>: hidden;</div><div class="line">    <span class="attribute">white-space</span>: nowrap;</div><div class="line">    <span class="attribute">border-right</span>: .<span class="number">05em</span> solid;</div><div class="line">    <span class="attribute">animation</span>: typing <span class="number">6s</span> <span class="built_in">steps</span>(15),</div><div class="line">    caret <span class="number">1s</span> <span class="built_in">steps</span>(1) infinite;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//js</span></div><div class="line">$$(<span class="string">'h1'</span>).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">h1</span>) </span>&#123;</div><div class="line"><span class="keyword">var</span> len = h1.textContent.length, s = h1.style;</div><div class="line">s.width = len + <span class="string">'ch'</span>;</div><div class="line">s.animationTimingFunction = <span class="string">"steps("</span>+len+<span class="string">"),steps(1)"</span>;</div><div class="line">&#125;);</div></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>hello awesome css<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div></pre></td></tr></table></figure><h1 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h1><p>对css越来越感兴趣，前端的三把利器真是样样都要行，之前很厌烦来回调样式，说到底还是没有好好学习，功夫到了很多样式往往几行代码就能产生魔法般的效果，fighting！！！！！</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;纸上得来终觉浅，绝知此事要躬行&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;看完css揭秘，对表现和结构分离的理解更加深刻，之前写样式只求能做出来，对于结构有多复杂，代码有多冗余，并没有太多考虑，或者心有余而力不足，之前也没有真正认真进阶学习过css，读完此书，css magical不虚此名。&lt;/p&gt;
&lt;h1 id=&quot;偷师技巧一二&quot;&gt;&lt;a href=&quot;#偷师技巧一二&quot; class=&quot;headerlink&quot; title=&quot;偷师技巧一二&quot;&gt;&lt;/a&gt;偷师技巧一二&lt;/h1&gt;&lt;p&gt;个人总结了下，让css变得如魔法一般的有以下几个：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;巧用渐变&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;善用阴影&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;令人激动的动画和过渡的一些部位常人熟知的属性：&lt;code&gt;animation-play-state;animation-direction;steps()&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="css" scheme="https://dsb123dsb.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>http2.0小结</title>
    <link href="https://dsb123dsb.github.io/2017/10/28/http2-0%E5%B0%8F%E7%BB%93/"/>
    <id>https://dsb123dsb.github.io/2017/10/28/http2-0小结/</id>
    <published>2017-10-28T04:35:31.000Z</published>
    <updated>2017-10-28T06:15:11.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>纸上得来终觉浅，觉知此事要躬行</p></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>如今，http1.1是互联网中的主要协议，随着web技术的飞速发展，http1.1已经无法满足用户对性能的要求，此后谷歌推出SPDY,意在解决http1.1中广为人知的性能问题，其在被行业采用并证明能够大幅提升性能后，已经具备了成为一个标准的条件。</p><p>Http2.0是http协议自1999年http1.1发布后的首个更新，主要基于SPDY协议，於2015年正式发表。</p><h1 id="http2-0变化"><a href="#http2-0变化" class="headerlink" title="http2.0变化"></a>http2.0变化</h1><h2 id="二进制分帧"><a href="#二进制分帧" class="headerlink" title="二进制分帧"></a>二进制分帧</h2><p>帧：http2.0数据通信的最小单位。</p><p>消息（message）：指http2.0中逻辑上的http消息。例如请求和响应，消息由一个或多个帧组成。</p><p>流：存在于连接中的一个虚拟通道。流可以承载双向消息，每个流都有一个唯一的证书ID。</p><p>http2.0采用二进制格式传输数据，而非http1x的文本格式，二进制协议解析起来更高效。</p><p>Http1.x的请求和响应报文，都是起始行，首部和整体正文（可选）组成，各部分之间以文本换行符分隔。http2.0将请求和响应数据分割为更小的帧，并且它们采用二进制编码。</p><p>http2.0中，同域名下所有通信都在单个连接上完成（多路复用中介绍），这个连接可以承载任意数量数量的双向数据流。每个数据流都以消息的形式发送，而消息又由一个或多个帧组成。多个帧之间可以乱序发送，因为根据帧首部的流标识可以重新组装。</p><a id="more"></a><h2 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h2><p>多路复用，代替原来的序列和阻塞机制。所有的请求都是通过==一个TCP==连接并发完成。</p><p>http1.x中，如果想并发多个请求，必须使用多个tcp连接，并且浏览器为了控制资源，还会对单个域名有6-8个数限制，如下图，红色圈出来的请求就因域名链接数超过限制，而被挂起等待了一段时间：</p><p><img src="http://blog.upyun.com/wp-content/uploads/2017/03/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.png" alt=""></p><p>在http2.0中，有了二进制分帧后，就不再依赖TCP连接去实现多流并行了：</p><ul><li>同域名下所用通信都在单个连接上完成</li><li>单个连接可以承载任意数量的双向数据流</li><li>数据流以消息的形式发送，而消息又由一个或多个帧组成，多个帧可以乱序发送，因为根据帧首部的流标识可以重新组装</li></ul><p>这一特性，性能会有极大提升，因为：</p><ul><li>同个域名下只需要占用一个TCP连接，消除了因多个TCP连接而带来的延时和内存消耗</li><li>单个连接上可以并行交错请求和响应，之间互不干扰</li><li>在http2.0中，每个请求都可以带一个31bit的优先值，0表示最高优先级，数值越大优先级越低。有了这个优先值，客户端和服务器就可以在处理不同的流时采取不同的策略，以最优的方式发送流、消息和帧</li></ul><h2 id="服务器推送"><a href="#服务器推送" class="headerlink" title="服务器推送"></a>服务器推送</h2><p>服务端可以在发送页面html时主动推送其它资源，而不用等到浏览器解析到相应位置，发起请求再响应。例如服务端可以主动把js和css文件推送给客户端，而不需要客户端解析html在请求发送这些请求。服务端可以主动送，客户端也有权利选择接收与否，如果服务端推送的资源已经被浏览器缓存过，浏览器可以通过RST_STREAM帧来拒收。主动推送也遵守同源策略，服务端不会随便推送第三方资源给客户端。</p><h2 id="头部压缩"><a href="#头部压缩" class="headerlink" title="头部压缩"></a>头部压缩</h2><p>Http1.1请求的大小变得越来越大，有时甚至会大于TCP窗口的初始大小，因为它们需要等待带着ACK的响应回来以后才能继续发送。http2.0对消息头部采用HACK（专门为http2头部设计的压缩格式）进行压缩传输，能够节省消息头占用的网络流量。而http1.x每次请求，都会携带大量冗余头部信息，浪费很多带宽资源，如果算cookie，增加的负荷会达到上千字节，为了减少开销并且提升性能，http2.0会压缩首部元数据。</p><ul><li>http2.0在客户端和服务端使用“首部表”来跟踪和存储之前发送的键-值对，对于相同的数据，不再通过每次请求和响应发送</li><li>首部表在http2.0的连接存续期内始终存在，由客户端和服务端共同渐进的更新</li><li>每个新的首部键-值对要么被追加到当前表尾部，要么替换表中之前的值</li></ul><p>于是，http2.0连接的两端都知道已经发送了那些首部，这些首部的值是什么，从而针对之前的数据至编码发送这些差异的数据。在通信期间几乎不会改变的键值对只需要发送一次即可，这就大大提高了数据的载荷。</p><p>头部压缩需要客户端和服务端做好以下工作：</p><ul><li>维护一份相同的静态字典（Static Table），包含常见的头部名称，以及特别常见的头部名称和值的组合</li><li>维护一份相同的动态字典（Dynamic Table），可以动态的添加内容</li><li>支持基于静态哈夫曼编码（Huffman Coding）</li></ul><p>静态字典的作用有两个：</p><ol><li>对于完全匹配的头部键值对，可以直接使用一个字符表示</li><li>对于头部名称可以匹配的键值对，可以将名称使用一个字符表示</li></ol><p>哈夫曼编码的核心理念就是使用最少的位数表示最多的信息，HTTP2.0中这份哈夫曼编码表是根据一个大样本的HTTP报头的统计数据生成，经常出现的字符会用较短的二进制数标识，出现频率较低的字符用较长的二进制数标识，这样就保证了综合来看报头信息占用了较少的空间，进一步压缩了报头信息。</p><p>在服务端接收到压缩过的报头信息后，会先进行哈夫曼编码解码，得到报首信息后，再结合维护的静态字典和动态字典信息得出完整的报首信息，随后进行请求的处理和响应。在需要更新动态字典信息时，对字典进行更新。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>向HTTP2.0的迁移不可能瞬间完成，无论服务器端还是客户端都需要进行必要的更新升级才能使用。好消息是，大多数现代浏览器都内置有高效的后台升级机制，对大多数既有用户来说，这些浏览器可以很快的支持HTTP2.0，不会带来很大困扰。然而，服务器端和中间设备的升级、更新就不是那么容易，是一个长期的过程，而且很费力、费钱。</p><p>HTTP1.X至少还会存续十年以上，大多数服务器和客户端在此期间必须同时支持1.x和2.0标准。于是，支持HTTP2.0的客户端在发起新请求之前，必须能发现服务器及中间设备是否支持HTTP2.0协议。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;纸上得来终觉浅，觉知此事要躬行&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;如今，http1.1是互联网中的主要协议，随着web技术的飞速发展，http1.1已经无法满足用户对性能的要求，此后谷歌推出SPDY,意在解决http1.1中广为人知的性能问题，其在被行业采用并证明能够大幅提升性能后，已经具备了成为一个标准的条件。&lt;/p&gt;
&lt;p&gt;Http2.0是http协议自1999年http1.1发布后的首个更新，主要基于SPDY协议，於2015年正式发表。&lt;/p&gt;
&lt;h1 id=&quot;http2-0变化&quot;&gt;&lt;a href=&quot;#http2-0变化&quot; class=&quot;headerlink&quot; title=&quot;http2.0变化&quot;&gt;&lt;/a&gt;http2.0变化&lt;/h1&gt;&lt;h2 id=&quot;二进制分帧&quot;&gt;&lt;a href=&quot;#二进制分帧&quot; class=&quot;headerlink&quot; title=&quot;二进制分帧&quot;&gt;&lt;/a&gt;二进制分帧&lt;/h2&gt;&lt;p&gt;帧：http2.0数据通信的最小单位。&lt;/p&gt;
&lt;p&gt;消息（message）：指http2.0中逻辑上的http消息。例如请求和响应，消息由一个或多个帧组成。&lt;/p&gt;
&lt;p&gt;流：存在于连接中的一个虚拟通道。流可以承载双向消息，每个流都有一个唯一的证书ID。&lt;/p&gt;
&lt;p&gt;http2.0采用二进制格式传输数据，而非http1x的文本格式，二进制协议解析起来更高效。&lt;/p&gt;
&lt;p&gt;Http1.x的请求和响应报文，都是起始行，首部和整体正文（可选）组成，各部分之间以文本换行符分隔。http2.0将请求和响应数据分割为更小的帧，并且它们采用二进制编码。&lt;/p&gt;
&lt;p&gt;http2.0中，同域名下所有通信都在单个连接上完成（多路复用中介绍），这个连接可以承载任意数量数量的双向数据流。每个数据流都以消息的形式发送，而消息又由一个或多个帧组成。多个帧之间可以乱序发送，因为根据帧首部的流标识可以重新组装。&lt;/p&gt;
    
    </summary>
    
      <category term="基础杂谈" scheme="https://dsb123dsb.github.io/categories/%E5%9F%BA%E7%A1%80%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="http2.0" scheme="https://dsb123dsb.github.io/tags/http2-0/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://dsb123dsb.github.io/2017/10/03/hello-world/"/>
    <id>https://dsb123dsb.github.io/2017/10/03/hello-world/</id>
    <published>2017-10-03T13:53:51.000Z</published>
    <updated>2017-10-03T13:53:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.<br><a id="more"></a></p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;GitHub&lt;/a&gt;.&lt;br&gt;
    
    </summary>
    
      <category term="搭建bog" scheme="https://dsb123dsb.github.io/categories/%E6%90%AD%E5%BB%BAbog/"/>
    
    
      <category term="initial" scheme="https://dsb123dsb.github.io/tags/initial/"/>
    
  </entry>
  
  <entry>
    <title>redux和flux学习</title>
    <link href="https://dsb123dsb.github.io/2017/09/30/redux%E5%92%8Cflux%E5%AD%A6%E4%B9%A0/"/>
    <id>https://dsb123dsb.github.io/2017/09/30/redux和flux学习/</id>
    <published>2017-09-30T03:25:21.000Z</published>
    <updated>2017-10-03T13:53:51.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>纸上得来终觉浅，绝知此事要躬行</p></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>工作虽然一直用react，但是都是现学现用，花了点时间通读《深入react技术栈》，学习笔记略作整理</p><p>传统MVC缺点，在项目越来越大，逻辑越来越复杂时，数据流动变的越来越混乱。<br><img src="https://i.imgur.com/oIfBMk2.png" alt=""><br><a id="more"></a></p><h1 id="Flux-的解决方案"><a href="#Flux-的解决方案" class="headerlink" title="Flux 的解决方案"></a>Flux 的解决方案</h1><p>Flux 的核心思想就是数据和逻辑永远单向流动。<br><strong>flux数据模型</strong><br><img src="https://i.imgur.com/HtXn7dm.png" alt=""></p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>一个 Flux 应用由 3 大部分组成——dispatcher、store 和 view，其中 </p><ol><li>dispatcher 负责分发事件；</li><li>store 负责保存数据，同时响应事件并更新数据；</li><li>view 负责订阅 store 中的数据，并使用这些数据<br>渲染相应的页面</li></ol><p><img src="https://i.imgur.com/1IFv9jz.png" alt=""></p><h2 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h2><ol><li>Flux 的中心化控制。让所有的请求与改变都只能通过 action 发出，统一由 dispatcher 来分配。<ul><li>View 可以保持高度简洁，它不需要关心太多的逻辑，只需要关心传入的数据；</li><li>中心化还控制了所有数据，发生问题时可以方便查询。比起 MVC 架构下数据或逻<br>辑的改动可能来自多个完全不同的源头，Flux 架构追查问题的复杂度和困难度显然要小得多。</li></ul></li><li>Flux 把 action 做了统一归纳，提高了系统抽象程度。不论 action 是由用户触发的，从服务端发起的，还是应用本身的行为，对于我们而言，它都只是一个动作而已。与 MVC 架构下<br>不同的触发方式管理混乱相比，Flux 要优雅许多。<h2 id="flux不足"><a href="#flux不足" class="headerlink" title="flux不足"></a>flux不足</h2></li><li>Flux 的冗余代码太多，Flux 源码中几乎只有 dispatcher的实现，但是在每个应用中都需要手动创建一个 dispatcher 的示例</li><li>Flux 给开发者提供的还是它的思想。Flux 在很大程度上是一种很松散的设计约定，不同的开发者对 Flux 都会有自己的理解<h1 id="redux"><a href="#redux" class="headerlink" title="redux"></a>redux</h1><h2 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h2>Redux 参考了 Flux 的设计，但是对 Flux 许多冗余的部分（如 dispatcher）做了<br>简化，同时将 Elm 语言中函数式编程的思想融合其中。<br><img src="https://i.imgur.com/OzoHXun.png" alt=""><h2 id="Redux-三大原则"><a href="#Redux-三大原则" class="headerlink" title="Redux 三大原则"></a>Redux 三大原则</h2></li><li>单一数据源。 <ul><li>整个应用状态都保存在一个对象中，可以提取出整个应用的状态进行持久化（比如实现一个针对整个应用的即时保存功能）</li><li>也为服务端渲染提供了可能。</li></ul></li><li>状态是只读的。<ul><li>在 Redux 中不会定义一个 store，而是定义一个 reducer，它的功能是根据当前触发的 action 对当前应用的状态（state）进行迭代，这里并没有直接修改应用的状态，而是返回了一份全新的状态。</li><li>Redux 提供的 createStore 方法会根据reducer 生成 store。</li><li>最后，我们可以利用 store. dispatch方法来达到修改状态的目的。</li></ul></li><li>状态修改均由纯函数完成。<ul><li>这是Redux 与Flux 在表现上的最大不同。在 Flux 中，在actionCreator 里调用<br>AppDispatcher.dispatch 方法来触发 action，不仅有冗余的代码，而且因为直接修改了 store 中的数据，导致无法保存每次数据变化前后的状态。</li><li>在 Redux 里，通过定义 reducer 来确定状态的修改，而每一个 reducer 都是纯函数，这意味着它没有副作用，即接受一定的输入，必定会得到一定的输出。<h1 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h1>这里仅对redux和flux的基本知识进行了总结，redux在大型应用的实现后续学习有了深刻体会在做总结</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;纸上得来终觉浅，绝知此事要躬行&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;工作虽然一直用react，但是都是现学现用，花了点时间通读《深入react技术栈》，学习笔记略作整理&lt;/p&gt;
&lt;p&gt;传统MVC缺点，在项目越来越大，逻辑越来越复杂时，数据流动变的越来越混乱。&lt;br&gt;&lt;img src=&quot;https://i.imgur.com/oIfBMk2.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="基础杂谈" scheme="https://dsb123dsb.github.io/categories/%E5%9F%BA%E7%A1%80%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="学习笔记" scheme="https://dsb123dsb.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="react" scheme="https://dsb123dsb.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>携程两个月工作小结</title>
    <link href="https://dsb123dsb.github.io/2017/09/06/%E6%90%BA%E7%A8%8B%E4%B8%A4%E4%B8%AA%E6%9C%88%E5%B7%A5%E4%BD%9C%E5%B0%8F%E7%BB%93/"/>
    <id>https://dsb123dsb.github.io/2017/09/06/携程两个月工作小结/</id>
    <published>2017-09-06T14:41:26.000Z</published>
    <updated>2017-10-03T13:53:51.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>纸上得来终觉浅，绝知此事要躬行</p></blockquote><p>时间过的很快 ，需要放慢脚步来丈量，两个月收获很多，也失去不少</p><h1 id="工作与收获"><a href="#工作与收获" class="headerlink" title="工作与收获"></a>工作与收获</h1><h2 id="软文大赛"><a href="#软文大赛" class="headerlink" title="软文大赛"></a>软文大赛</h2><p>简单的H5页面展示，之前没学过react，利用这个项目，熟悉了react技术栈，能够使用react进行简单页面开发、代码简化。期间也学习了很多技术，大图片快速加载、图片预占位、scss简化代码等</p><h2 id="开通首页兼容性修复"><a href="#开通首页兼容性修复" class="headerlink" title="开通首页兼容性修复"></a>开通首页兼容性修复</h2><p>我们的页面是同时跑在app、微信、和手机浏览器的，发现页面在浏览器会存在拥挤情况，学习了flex布局和hysdk简单使用，使用flex布局使空余空间自动填充，同时考虑在浏览器环境下做专门处理，或者改用滚动布局，思考了很多方案也做了实践</p><h2 id="touchable组件和yo-公共样式"><a href="#touchable组件和yo-公共样式" class="headerlink" title="touchable组件和yo-公共样式"></a>touchable组件和yo-公共样式</h2><p>做这个项目进行项目的组件化和代码复用以及组件源码的学习，养成主动进行项目抽离和阅读源码的习惯。<br>我们页面中使用tuchable组件的地方很多未添加按下态或者按下态不一致，我对组件进行了优化，可进行配置。yo提供了很多封装的现成样式，但是我们代码里基本都是自己写的，没有用到yo封装的样式，通过阅读源码，能使用封装的全部使用，减少代码</p><h2 id="暂停服务公告"><a href="#暂停服务公告" class="headerlink" title="暂停服务公告"></a>暂停服务公告</h2><p>这是完全自己单独写的组件，学习接口设计，展示后端接口返回数据。<br>动画速度和不同字数的计算关系、动画重绘对滚动框影响、动画进入效果优化，动画播放效果优化、flex布局对offsetWidth影响、react生命周期学习，组件的可配置化<br><a id="more"></a></p><h2 id="和第三方app页面交互"><a href="#和第三方app页面交互" class="headerlink" title="和第三方app页面交互"></a>和第三方app页面交互</h2><p>需求是页面需要跳转到另一个页面，然后成功 完成任务后回来，我们页面根据回传参数进行下一步处理，hysdk的学习，app内使用openWebview，期间遇到不同版本app的兼容、h5内直接更换loaction.href, 第三方app通过closeWebview关闭，并且透传参数，通过onreceiveData接收参数，期间调试涉及方面较多，交互逻辑也比较复杂，踩了很多坑。</p><h1 id="后面"><a href="#后面" class="headerlink" title="后面"></a>后面</h1><p>回来需要更加努力学习，基础知识再温习一遍，然后主攻react（进阶知识，高阶组件，redux，源码等）和css，Es6也要温习（promise等）</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;纸上得来终觉浅，绝知此事要躬行&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;时间过的很快 ，需要放慢脚步来丈量，两个月收获很多，也失去不少&lt;/p&gt;
&lt;h1 id=&quot;工作与收获&quot;&gt;&lt;a href=&quot;#工作与收获&quot; class=&quot;headerlink&quot; title=&quot;工作与收获&quot;&gt;&lt;/a&gt;工作与收获&lt;/h1&gt;&lt;h2 id=&quot;软文大赛&quot;&gt;&lt;a href=&quot;#软文大赛&quot; class=&quot;headerlink&quot; title=&quot;软文大赛&quot;&gt;&lt;/a&gt;软文大赛&lt;/h2&gt;&lt;p&gt;简单的H5页面展示，之前没学过react，利用这个项目，熟悉了react技术栈，能够使用react进行简单页面开发、代码简化。期间也学习了很多技术，大图片快速加载、图片预占位、scss简化代码等&lt;/p&gt;
&lt;h2 id=&quot;开通首页兼容性修复&quot;&gt;&lt;a href=&quot;#开通首页兼容性修复&quot; class=&quot;headerlink&quot; title=&quot;开通首页兼容性修复&quot;&gt;&lt;/a&gt;开通首页兼容性修复&lt;/h2&gt;&lt;p&gt;我们的页面是同时跑在app、微信、和手机浏览器的，发现页面在浏览器会存在拥挤情况，学习了flex布局和hysdk简单使用，使用flex布局使空余空间自动填充，同时考虑在浏览器环境下做专门处理，或者改用滚动布局，思考了很多方案也做了实践&lt;/p&gt;
&lt;h2 id=&quot;touchable组件和yo-公共样式&quot;&gt;&lt;a href=&quot;#touchable组件和yo-公共样式&quot; class=&quot;headerlink&quot; title=&quot;touchable组件和yo-公共样式&quot;&gt;&lt;/a&gt;touchable组件和yo-公共样式&lt;/h2&gt;&lt;p&gt;做这个项目进行项目的组件化和代码复用以及组件源码的学习，养成主动进行项目抽离和阅读源码的习惯。&lt;br&gt;我们页面中使用tuchable组件的地方很多未添加按下态或者按下态不一致，我对组件进行了优化，可进行配置。yo提供了很多封装的现成样式，但是我们代码里基本都是自己写的，没有用到yo封装的样式，通过阅读源码，能使用封装的全部使用，减少代码&lt;/p&gt;
&lt;h2 id=&quot;暂停服务公告&quot;&gt;&lt;a href=&quot;#暂停服务公告&quot; class=&quot;headerlink&quot; title=&quot;暂停服务公告&quot;&gt;&lt;/a&gt;暂停服务公告&lt;/h2&gt;&lt;p&gt;这是完全自己单独写的组件，学习接口设计，展示后端接口返回数据。&lt;br&gt;动画速度和不同字数的计算关系、动画重绘对滚动框影响、动画进入效果优化，动画播放效果优化、flex布局对offsetWidth影响、react生命周期学习，组件的可配置化&lt;br&gt;
    
    </summary>
    
      <category term="生活随笔" scheme="https://dsb123dsb.github.io/categories/%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="https://dsb123dsb.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>携程实习小结</title>
    <link href="https://dsb123dsb.github.io/2017/07/30/%E6%90%BA%E7%A8%8B%E5%AE%9E%E4%B9%A0%E5%B0%8F%E7%BB%93/"/>
    <id>https://dsb123dsb.github.io/2017/07/30/携程实习小结/</id>
    <published>2017-07-30T05:57:48.000Z</published>
    <updated>2017-10-03T13:53:51.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>纸上得来终觉浅，绝知此事要躬行</p></blockquote><p>实习后公司学校事情都很多，好久没写点东西，不知不觉月底了，是回顾下总结然后继续去前行的时刻了。</p><h1 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h1><p>本来冲着携程性价比高，不加班来的，事情总是事与愿违，本部门加班简直了，不过还是很高兴学习到了很多哦东西。之前创业公司实习东西要能做出来，后面出问题再改，这里无论是步骤还是流程都更加规范和严格，每次师傅给我review代码都要脱一层皮，感觉自己写的是一坨屎，然后还要和测试review代码，我想象review才是提高和发现错误的契机吧，听闻其他有些部门review代码走过场和没有，更坚定自己好好珍惜这一切，累并快乐着。</p><p>也参加了携程MIT训练营，见了cto，携程能让去哪的人做cto也让人看到了不断加强自身技术导向的意愿，祝好。一起进来的同事们无论积极主动还能力见识都让人侧目。这大概是我们不断奋力向上攀登的魅力吧。</p><h1 id="后面"><a href="#后面" class="headerlink" title="后面"></a>后面</h1><p>很多公司的秋招提前批也开始了，不管未来会不会呆在这里，这是一段美好的旅程，留下一段美好的回忆。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;纸上得来终觉浅，绝知此事要躬行&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;实习后公司学校事情都很多，好久没写点东西，不知不觉月底了，是回顾下总结然后继续去前行的时刻了。&lt;/p&gt;
&lt;h1 id=&quot;收获&quot;&gt;&lt;a href=&quot;#收获&quot; class=&quot;he
      
    
    </summary>
    
      <category term="生活随笔" scheme="https://dsb123dsb.github.io/categories/%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="https://dsb123dsb.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>Flow-JS静态类型检查工具</title>
    <link href="https://dsb123dsb.github.io/2017/06/25/Flow-JS%E9%9D%99%E6%80%81%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5%E5%B7%A5%E5%85%B7/"/>
    <id>https://dsb123dsb.github.io/2017/06/25/Flow-JS静态类型检查工具/</id>
    <published>2017-06-25T12:08:37.000Z</published>
    <updated>2017-10-03T13:53:51.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>纸上得来终觉浅，绝知此事要躬行</p></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近学习vue源码看到下面代码</p><p><img src="http://i.imgur.com/iNBVV3k.png" alt=""></p><p>心里不由WTF,查了下原来是flow代码,就立马去<a href="https://flow.org/en/docs/" target="_blank" rel="external">官网把flow文档</a>撸了一遍，网上又找了几遍文章，做下总结<br><a id="more"></a></p><p>先看下简介</p><p><img src="https://segmentfault.com/img/bVH6mL?w=1200&amp;h=675" alt=""></p><p>Flow本质上也只是个检查工具，它并不会自动修正代码中的错误，也不会强制说你没按照它的警告消息修正，就不会让你运行程序。当然，并没有要求什么时候一定要用这类的工具，只是这种作法可以让你的代码更具强健性与提高阅读性，也可以直接避去很多不必要的数据类型使用上的问题，这种开发方式目前在许多框架与函数库项目，或是以JavaScript应用为主的开发团队中都已经都是必用工具。</p><ul><li>由于Flow还是个年轻的项目，问题仍然很多，功能也没你想像中完整，用起来有时候会卡顿是正常的，效能仍须改善。以后用户愈来愈多就会愈作愈好。</li><li>Windows平台的支持也是不久前(2016.8)时的事，Flow只支持64位元的作业系统，32位元就不能用了。</li><li>如果你是要学或用React或Vue.js等等，Flow是必学的。不管你要用不用，库源码里面都用了。</li></ul><h1 id="Flow介绍"><a href="#Flow介绍" class="headerlink" title="Flow介绍"></a>Flow介绍</h1><p><a href="https://flowtype.org/" target="_blank" rel="external">Flow</a>是个JavaScript的静态类型检查工具，由Facebook出品的开源码项目，问世只有一年多，是个相当年轻的项目。简单来说，它是对比TypeScript语言的解决方式。</p><p>会有这类解决方案，起因是JavaScript是一种弱(动态)数据类型的语言，弱(动态)数据类型代表在代码中，变量或常量会自动依照赋值变更数据类型，而且类型种类也很少，这是直译式脚本语言的常见特性，但有可能是优点也是很大的缺点。优点是容易学习与使用，缺点是像开发者经常会因为赋值或传值的类型错误，造成不如预期的结果。有些时候在使用框架或函数库时，如果没有仔细看文件，亦或是文件写得不清不楚，也容易造成误用的情况。</p><p>这个缺点在应用规模化时，会显得更加严重。我们在开发团队的协同时，一般都是用详尽的文字说明，来降低这个问题的发生，但JS语言本身无法有效阻止这些问题。而且说明文件也需要花时间额外编写，其他的开发者阅读也需要花时间。在现今预先编译器流行的年代，像TypeScript这样的强(静态)类的JavaScript超集语言就开始流行，用严格的角度，以JavaScript语言为基底，来重新打造另一套具有强(静态)类型特性的语言，就如同Java或C#这些语言一样，这也是为什么TypeScript称自己是企业级的开发JavaScript解决方案。</p><blockquote><p>注: 强(静态)类型语言，意思是可以让变量或常量在声明(定义)时，就限制好只能使用哪种类型，之后在使用时如果发生类型不相符时，就会发出错误警告而不能编译。但不只这些，语言本身也会拓展了更多的类型与语法。</p></blockquote><p>TypeScript自然有它的市场，但它有一些明显的问题，首先是JavaScript开发者需要再进一步学习，内容不少，也有一定陡峭的学习曲线，不过这还算小事情。重大的事情是需要把已经在使用的应用代码，都要整个改用TypeScript代码语法，才能发挥完整的功用。这对很多已经有内部代码库的大型应用开发团队而言，将会是个重大的决定，因为如果不往全面重构的路走，将无法发挥强(静态)类型语言的最大效用。</p><p>所以许多现行的开源码函数库或框架，并不会直接使用TypeScript作为代码的语言，另一方面当然因为是TypeScript并非普及到一定程度的语言，社群上有热爱的粉丝也有不是那么支持的反对者。当然，TypeScript也有它的优势，自从TypeScript提出了DefinitelyTyped的解决方式之后，让现有的函数库能额外再定义出里面使用的类型，这也是另一个可以与现有框架与库相整合的方案，这让许多函数库与框架都提交定义档案，提供了另一种选择。另一个优势是，TypeScript也是个活跃的开源码项目，发展到现在也有一段时间，算是逐渐成熟的项目。它的背后有微软公司的支持，在最近发布的知名的、全新打造过的Angular2框架中(由Google主导)，也采用了TypeScript作为基础的开发语言。</p><p>现在，Flow提供了另一个新的选项，它是一种强(静态)类型的辅助检查工具。Flow的功能是让现有的JavaScript语法可以事先作类型的声明(定义)，在开发过程中进行自动检查，当然在最后编译时，一样可以用babel工具来移除这些标记。</p><p>相较于TypeScript是另外重新制定一套语言，最后再经过编译为JavaScript代码来运行。Flow走的则是非强制与非侵入性的路线。Flow的优点是易学易用，它的学习曲线没有TypeScript来得高，虽然内容也很多，但大概一天之内学个大概，就可以渐进式地开始使用。而且因为Flow从头到尾只是个检查工具，并不是新的程序语言或超集语言，所以它可以与各种现有的JavaScript代码兼容，如果你哪天不想用了，就去除掉标记就是回到原来的代码，没什么负担。当然，Flow的功用可能无法像TypeScript这么全面性，也不可能改变要作某些事情的语法结构。</p><p>总结来说，这两种方式的目的是有些相似的，各自有优点也有不足之处，青菜萝卜各有所爱，要选择哪一种方式就看你的选择。</p><h1 id="从一个小例子演示"><a href="#从一个小例子演示" class="headerlink" title="从一个小例子演示"></a>从一个小例子演示</h1><p>这种类型不符的情况在代码中非常容易发生，例如以下的例子:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> x + <span class="number">10</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">foo(<span class="string">'Hello!'</span>)</div></pre></td></tr></table></figure></p><p>x这个传参，我们在函数声明时希望它是个数字类型，但最后使用调用函数时则用了字符串类型。最后的结果会是什么吗？ “Hello!10”，这是因为加号(+)在JavaScript语言中，除了作为数字的加运算外，也可以当作字符串的连接运算。想当然这并不是我们想要的结果。</p><p>聪明如你应该会想要用类型来当传参的识别名，容易一眼看出传参要的是什么类型，像下面这样:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">number</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> number + <span class="number">10</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>但如果在复合类型的情况，例如这个传参的类型可以是数字类型也可以是布尔类型，你又要如何写得清楚？更不用说如果是个复杂的对象类型时，结构又该如何先确定好？另外还有函数的返回类型又该如何来写？</p><p>利用Flow类型的定义方式，来解决这个小案例的问题，可以改写为像下面的代码:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// @flow</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x: number</span>): <span class="title">number</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> x + <span class="number">10</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">foo(<span class="string">'hi'</span>)</div></pre></td></tr></table></figure></p><p>你有看到在函数的传参，以及函数的圆括号(())后面的两个地方，加了: number标记，这代表这个传参会限定为数字类型，而返回值也只允许是数字类型。</p><p>当使用非数字类型的值作为传入值时，就会出现由Flow工具发出的警告消息，像下面这样:</p><blockquote><p>message: ‘[flow] string (This type is incompatible with number See also: function call)’</p></blockquote><p>这消息是说，你这函数的传参是string(字符串)类型，与你声明的number(数字)不相符合。</p><p>如果是要允许多种类型也是很容易可以加标记的，假使这个函数可以使用布尔与数字类型，但返回可以是数字或字符串，就像下面这样修改过:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// @flow</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x: number | boolean</span>): <span class="title">number</span> | <span class="title">string</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">'number'</span>) &#123;</div><div class="line">    <span class="keyword">return</span> x + <span class="number">10</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="string">'x is boolean'</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">foo(<span class="number">1</span>)</div><div class="line">foo(<span class="literal">true</span>)</div><div class="line">foo(<span class="literal">null</span>)  <span class="comment">// 这一行有类型错误消息</span></div></pre></td></tr></table></figure></p><p>由上面这个小例子你可以想见，如果在多人协同开发某个有规模的JavaScript应用时，这种类型的输出输入问题就会很常遇见。如果利用Flow工具的检查，可以避免掉许多不必要的类型问题。</p><h1 id="真实案例"><a href="#真实案例" class="headerlink" title="真实案例"></a>真实案例</h1><p>可能你会认为Flow工具只能运用在小型代码中，但实际上Facebook会创造出Flow工具，有很大的原因是为了React与React Native。</p><p>举一个我最近正在研究的的函数库代码中<a href="https://github.com/facebook/react-native/blob/9ee815f6b52e0c2417c04e5a05e1e31df26daed2/Libraries/NavigationExperimental/NavigationTypeDefinition.js" target="_blank" rel="external">NavigationExperimental</a>(这网址位置有可能会变，因为是直接连到源码里)，这里面就预先声明了所有的对象结构，像下面这样的代码:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> type NavigationGestureDirection = <span class="string">'horizontal'</span> | <span class="string">'vertical'</span>;</div><div class="line"></div><div class="line"><span class="keyword">export</span> type NavigationRoute = &#123;</div><div class="line">  key: string,</div><div class="line">  title?: string</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">export</span> type NavigationState = &#123;</div><div class="line">  index: number,</div><div class="line">  routes: <span class="built_in">Array</span>&lt;NavigationRoute&gt;,</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// ...</span></div></pre></td></tr></table></figure></p><p>Flow具备有像TypeScript语言中，预先定义对象类型的作用。上面代码的都是这个组件中预先定义的类型，这些类型可以再套用到不同的代码文档之中。</p><pre><code>export type NavigationGestureDirection = &apos;horizontal&apos; | &apos;vertical&apos;;</code></pre><p>上面这行类似于列举(enum)的类型，意思是说要不就是’horizontal’(水平的)，要不然就’vertical’(垂直的)，就这两种字符串值可使用。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> type NavigationRoute = &#123;</div><div class="line">  key: string,</div><div class="line">  title?: string</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>这行里面用了一个问号(?)定义在title属性的后面，这代表这属性是可选的(Optional)，不过你可能会有点搞混，因为问号(?)可以放在两个位置，见下面的例子:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> type Test = &#123;</div><div class="line">  titleOne?: string,</div><div class="line">  titleTwo: ?string</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>titleOne代表的是属性为可自定义的(可有可无)，但一定是字符串类型。titleTwo代表的是类型可自定义，也就是值的部份除了定义的类型，也可以是null或undefined，不过这属性是需要的，而且你一定要给它一个值。好的，这有些太细部了，如果有用到再查手册文档就可以。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">export type NavigationState = &#123;</div><div class="line">  index: number,</div><div class="line">  routes: Array&lt;NavigationRoute&gt;,</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>上面的代码可以看到，只要是声明过的类型(type)，同样可以拿来拿在其他类型中套用，像这里的<code>Array&lt;NavigationRoute&gt;</code>，就是使用了上面已声明的NavigationRoute类型。它是一个数组，里面放的成员是NavigationRoute类型，是个对象的结构。</p><p>刚已经有说过Flow工具有很大的原因是为了React与React Native所设计，因为Flow本身就内建对PropTypes的检查功能，也可以正确检查JSX语法，在这篇官方文档中有说明，而这在之后介绍React的文档的例子中就可以看到。</p><h1 id="安装与使用"><a href="#安装与使用" class="headerlink" title="安装与使用"></a>安装与使用</h1><p>Flow目前可以支持macOS、Linux(64位元)、Windows(64位元)，你可以从以下的四种安装方式选择其中一种:</p><p>直接从Flow的发布页面下载可运行档案，加到计算机中的PATH(路径)，让flow指令可以在命令列窗口访问即可。<br>透过npm安装即可，可以安装在全局(global)或是各别项目中。下面为安装在项目中的指令:</p><pre><code>npm install --save-dev flow-bin</code></pre><p>macOS中可以使用homebrew安装:</p><pre><code>brew updatebrew install flow</code></pre><p>透过OCaml OPAM套装管理程序打包与安装，请见<a href="https://github.com/facebook/flow" target="_blank" rel="external">Flow的Github页面</a>。</p><h1 id="Flow简单使用三步骤"><a href="#Flow简单使用三步骤" class="headerlink" title="Flow简单使用三步骤"></a>Flow简单使用三步骤</h1><h2 id="第1步-初始化项目"><a href="#第1步-初始化项目" class="headerlink" title="第1步: 初始化项目"></a>第1步: 初始化项目</h2><p>在你的项目根目录的用命令列工具输入下面的指令，这将会创建一个<code>.flowconfig</code>文档，如果这文档已经存在就不需要再进行初始化，这个设置档一样是可以加入自定义的设置值，请参考<a href="https://flowtype.org/docs/advanced-configuration.html" target="_blank" rel="external">Advanced Configuration</a>这里的说明，目前有很多项目里面都已经内附这个设置档，例如一些React的项目:</p><pre><code>flow init</code></pre><h2 id="第2步-在代码文档中加入要作类型检查的注释"><a href="#第2步-在代码文档中加入要作类型检查的注释" class="headerlink" title="第2步: 在代码文档中加入要作类型检查的注释"></a>第2步: 在代码文档中加入要作类型检查的注释</h2><p>一般都在代码档案的最上面一行加入，没加Flow工具是不会进行检查的，有两种格式都可以:</p><pre><code>// @flow</code></pre><p>或</p><pre><code>/* @flow */</code></pre><h2 id="第3步-进行检查"><a href="#第3步-进行检查" class="headerlink" title="第3步: 进行检查"></a>第3步: 进行检查</h2><p>目前支持Flow工具插件的代码编辑工具很多，常见的Atom, Visual Studio Code(VSC), Sublime与WebStorm都有，当有安装搭配代码编辑工具的插件时，编辑工具会辅助显示检查的讯息。不过有时候会有点卡顿的要等一下，因为检查速度还不是那么快。</p><p>或是直接用下面的命令列指令来进行检查:</p><pre><code>flow check</code></pre><p>在Visual Studio Code中因为它内建TypeScript与JavaScript的检查功能，如果要使用Flow工具来作类型检查，需要在用户设置中，加上下面这行设置值以免冲突:</p><pre><code>&quot;javascript.validate.enable&quot;: false</code></pre><h1 id="转换-编译-有Flow标记的代码"><a href="#转换-编译-有Flow标记的代码" class="headerlink" title="转换(编译)有Flow标记的代码"></a>转换(编译)有Flow标记的代码</h1><blockquote><p>注: 有些脚手架就已经装好与设置好这个babel拓展插件，你不用再多安装了。</p></blockquote><p>在开发的最后阶段要将原本有使用Flow标记，或是有类型注释的代码，进行清除或转换。转换的工作要使用babel编译器，这也是目前较推荐的方式。</p><p>使用babel编译器如果以命令列工具为主，可以使用下面的指令来安装在全局中:</p><pre><code>npm install -g babel-cli</code></pre><p>再来加装额外移除Flow标记的npm套件<code>babel-plugin-transform-flow-strip-types</code>在你的项目中:</p><pre><code>npm install --save-dev babel-plugin-transform-flow-strip-types</code></pre><p>然后创建一个<code>.babelrc</code>设置档案，档案内容如下:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="string">"plugins"</span>: [</div><div class="line">    <span class="string">"transform-flow-strip-types"</span></div><div class="line">  ]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>完成设置后，之后babel在编译时就会一并转换Flow标记。</p><p>下面的指令则是直接把src目录的档案编译到dist目录中:</p><pre><code>babel src -d dist</code></pre><p>当然，babel的使用方式不是只有上面说的这种命令列指令，你可以视项目的使用情况来进行设置。</p><h1 id="Flow支持的数据类型"><a href="#Flow支持的数据类型" class="headerlink" title="Flow支持的数据类型"></a>Flow支持的数据类型</h1><p>Flow用起来是的确是简单，但里面的内容很多，主要原因是是要看实际不同的使用情况作搭配。JavaScript里面的原始数据类型都有支持，而在函数、对象与一些新的ES6中的类，在搭配使用时就会比较复杂，详细的情况就请到官网文档中观看，以下只能提供一些简单的介绍说明。</p><h2 id="原始数据类型"><a href="#原始数据类型" class="headerlink" title="原始数据类型"></a>原始数据类型</h2><p>Flow支持原始数据类型，如下面的列表:</p><ul><li>boolean</li><li>number</li><li>string</li><li>null</li><li>void</li></ul><p>其中的void类型，它就是JS中的<code>undefined</code>类型。</p><p>这里可能要注意的是，在JS中<code>undefined</code>与<code>null</code>的值会相等但类型不同，意思是作值相等比较时，像(<code>undefined == null</code>)时会为<code>true</code>，有时候在一些运行期间的检查时，可能会用值相等比较而不是严格的相等比较，来检查这两个类型的值。</p><p>所有的类型都可以使用垂直线符号(|)作为联合使用(也就是 OR 的意思)，例如<code>string | number</code>指的是两种类型其中一种都可使用，这是一种联合的类型，称为”联合(Union)类型”。</p><p>最特别的是可选的(Optional)类型的设计，可选类型代表这个变量或常量的值有可能不存在，也就是允许它除了是某个类型的值外，也可以是<code>null</code>或<code>undefined</code>值。要使用可选类型，就是在类型名称定义前加上问号(?)，例如?string这样，下面是一个简单的例子:</p><pre><code>let bar: ?string = null</code></pre><h2 id="字面文字-literal-类型"><a href="#字面文字-literal-类型" class="headerlink" title="字面文字(literal)类型"></a>字面文字(literal)类型</h2><p>字面文字类型指的是以真实值作为数据类型，可用的值有三种，即数字、字符串或布尔值。字面文字类型搭配联合的类型可以作为列举(enums)来使用，例如以下的一个扑克牌的类型例子:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">type Suit =</div><div class="line">  | <span class="string">"Diamonds"</span></div><div class="line">  | <span class="string">"Clubs"</span></div><div class="line">  | <span class="string">"Hearts"</span></div><div class="line">  | <span class="string">"Spades"</span>;</div><div class="line"></div><div class="line">type Rank =</div><div class="line">  | <span class="number">2</span> | <span class="number">3</span> | <span class="number">4</span> | <span class="number">5</span> | <span class="number">6</span> | <span class="number">7</span> | <span class="number">8</span> | <span class="number">9</span> | <span class="number">10</span></div><div class="line">  | <span class="string">"Jack"</span></div><div class="line">  | <span class="string">"Queen"</span></div><div class="line">  | <span class="string">"King"</span></div><div class="line">  | <span class="string">"Ace"</span>;</div><div class="line"></div><div class="line">type Card = &#123;</div><div class="line">  suit: Suit,</div><div class="line">  rank: Rank,</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><blockquote><p>注: type是Flow中定义类型别名(Type Alias)的关键字，是一种预先声明的类型，这些声明的标记一样只会在开发阶段中使用，最后编译去除。</p></blockquote><h2 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h2><p>类型别名(Type Alias)提供了可以预先定义与集中代码中所需要的类型，一个简单的例子如下:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">type T = <span class="built_in">Array</span>&lt;string&gt;</div><div class="line"><span class="keyword">var</span> x: T = []</div><div class="line">x[<span class="string">"Hi"</span>] = <span class="number">2</span> <span class="comment">//有Flow警告</span></div></pre></td></tr></table></figure></p><p>类型别名(Type Alias)也可以用于复杂的应用情况，详见Flow官网提供的<a href="https://flowtype.org/docs/type-aliases.html" target="_blank" rel="external">Type Aliases</a>内容。</p><h2 id="任何的数据类型"><a href="#任何的数据类型" class="headerlink" title="任何的数据类型"></a>任何的数据类型</h2><p>在某一些情况可能不需要定义的太过于严格，或是还在开发中正在调试时，有一种作为渐进的改善代码的类型。</p><p>Flow提供了两种特殊的类型可以作为松散的数据类型定义:</p><ul><li>any: 相当于不检查。既是所有类型的超集(supertype)，也是所有类型的子集(subtype)</li><li>mixed: 类似于any是所有类型的超集(supertype)，但不同于any的是，它不是所有类型的子集(subtype)</li></ul><p><code>mixed</code>是一个特别的类型，中文是混合的意思，<code>mixed</code>算是any的”啰嗦”进化类型。mixed用在函数的输入(传参)与输出(返回)时，会有不一样的状态，例如以下的例子会出现警告:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x: mixed</span>): <span class="title">string</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> x + <span class="string">'10'</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">foo(<span class="string">'Hello!'</span>)</div><div class="line">foo(<span class="number">1</span>)</div></pre></td></tr></table></figure></p><blockquote><p>会出现警告消息如下:<br>[flow] mixed (Cannot be added to string)</p></blockquote><p>这原因是虽然输入时可以用<code>mixed</code>，但Flow会认为函数中x的值不见得可以与string类型作相加，所以会请求你要在函数中的代码，要加入检查对传入类型在运行期间的类型检查代码，例如像下面修改过才能过关:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x: mixed</span>): <span class="title">string</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">'number'</span> || <span class="keyword">typeof</span> x === <span class="string">'string'</span>) &#123;</div><div class="line">    <span class="keyword">return</span> x + <span class="string">'10'</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Invalid x type'</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line">foo(<span class="string">'Hello!'</span>)</div><div class="line">foo(<span class="number">1</span>)</div></pre></td></tr></table></figure></p><p><code>mixed</code>虽然”啰嗦”，但它是用来渐进替换any使用的，有时候往往开发者健忘或偷懒没作传入值在运行期间的类型检查，结果后面要花更多的时间才能找出错误点，这个类型的设计大概是为了提早预防这样的情况。</p><blockquote><p>注: 从上面的例子可以看到Flow除了对类型会作检查外，它也会请求对某些类型需要有动态的检查。在官方的文件可以参考<a href="https://flowtype.org/docs/dynamic-type-tests.html#_" target="_blank" rel="external">Dynamic Type Tests</a>这个章节。</p></blockquote><h2 id="复合式的数据类型"><a href="#复合式的数据类型" class="headerlink" title="复合式的数据类型"></a>复合式的数据类型</h2><p>数组(Array)</p><p>数组类型使用的是<code>Array&lt;T&gt;</code>，例如<code>Array&lt;number&gt;</code>，会限定数组中的值只能使用数字的数据类型。当然你也可以加入埀直线(|)来定义允许多种类型，例如<code>Array&lt;number|string&gt;</code>。</p><p>对象(Object)</p><p>对象类型会比较麻烦，主要原因是在JavaScript中所有的数据类型大概都可以算是对象，就算是基础数据类型也有对应的包装对象，再加上有个异常的null类型的typeof返回值也是对象。</p><p>对象类型在Flow中的使用，基本上要分作两大部份来说明。</p><p>第一种是单指Object这个类型，Flow会判断所有的基础数据类<strong>不是</strong>属于这个类型的，以下的例子全部都会有警告:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 以下都有Flow警告</span></div><div class="line"></div><div class="line">(<span class="number">0</span>: <span class="built_in">Object</span>);</div><div class="line">(<span class="string">""</span>: <span class="built_in">Object</span>);</div><div class="line">(<span class="literal">true</span>: <span class="built_in">Object</span>);</div><div class="line">(<span class="literal">null</span>: <span class="built_in">Object</span>);</div><div class="line">(<span class="literal">undefined</span>: <span class="built_in">Object</span>);</div></pre></td></tr></table></figure></p><p>其他的复合式数据类型，除了数组之外，都会认为是对象类型。如下面的例子:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">(&#123;<span class="attr">foo</span>: <span class="string">"foo"</span>&#125;: <span class="built_in">Object</span>);</div><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;: <span class="built_in">Object</span>);</div><div class="line">(<span class="class"><span class="keyword">class</span> </span>&#123;&#125;: <span class="built_in">Object</span>);</div><div class="line">([]: <span class="built_in">Object</span>); <span class="comment">// Flow不认为数组是属于对象</span></div></pre></td></tr></table></figure></p><blockquote><p>注意: 上面有两个特例，<code>typeof null</code>typeof与<code>typeof []</code>都是返回’object’。也就是说在JS的标准定义中，<code>null</code>与<code>数组</code>用``检测都会返回对象类型。所以，Flow工具的检查会与JS预设并不相同，这一点要注意。</p><p>注: typeof在Flow中有一些另外的用途，详见Typeof的说明。</p></blockquote><p>第二种方式是要定义出完整的对象的字面文字结构，像<code>{ x1: T1; x2: T2; x3: T3;}</code>的语法，用这个结构来检查，以下为例子:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> object: &#123;<span class="attr">foo</span>: string, <span class="attr">bar</span>: number&#125; = &#123;<span class="attr">foo</span>: <span class="string">"foo"</span>, <span class="attr">bar</span>: <span class="number">0</span>&#125;;</div><div class="line"></div><div class="line">object.foo = <span class="number">111</span>; <span class="comment">//Flow警告</span></div><div class="line">object.bar = <span class="string">'111'</span>; <span class="comment">//Flow警告</span></div></pre></td></tr></table></figure></p><p>函数(Function)</p><p>上面已经有看到，函数也属于对象(Object)类型，当然也有自己的<code>Function</code>类型，函数的类型也可以从两大部份来看。</p><p>第一是单指<code>Function</code>这个类型，可以用来定义变量或常量的类型。如下面的代码例子:</p><pre><code>var anyFunction: Function = () =&gt; {};</code></pre><p>第二指的是函数中的用法，上面已经有看到函数的输出(返回值)与输入(传参)的用法例子。例如以下的例子:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x: number</span>): <span class="title">number</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> x + <span class="number">10</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>因为函数有很多种不同的使用情况，实际上可能会复杂很多，Flow工具可以支持目前最新的arrow functions、async functions与generator functions，详见<a href="https://flowtype.org/docs/functions.html" target="_blank" rel="external">官方的这篇Functions</a>的说明。</p><p>类(Class)</p><p>类是ES6(ES2015)中新式的特性，类目前仍然只是原型的语法糖，类本身也属于一种对象(Object)类型。类的使用情况也可能会复杂，尤其是涉及多型与实例的情况，详见Flow网站提供的<a href="https://flowtype.org/docs/classes.html" target="_blank" rel="external">Classes</a>内容。</p><h1 id="Flow的现在与未来的发展"><a href="#Flow的现在与未来的发展" class="headerlink" title="Flow的现在与未来的发展"></a>Flow的现在与未来的发展</h1><p>Flow在<a href="https://flowtype.org/blog/2016/10/13/Flow-Typed.html" target="_blank" rel="external">最近的博客</a>中说明引入了<code>flow-typed</code>的函数库定义档(“libdefs”)，在这个Github存储库中将统一存放所有来自社群提供的函数库定义档案。这是一种可以让现有的函数库与框架，预先写出里面使用的类型定义。让项目里面有使用Flow工具与这些函数库，就可以直接使用这些定义档，以此结合现有的函数库与框架来使用。这个作法是参考TypeScript的DefinitelyTyped方式。因为这还是很新的消息(2016.10)，目前加入的函数库还没有太多，不过React周边的一些函数库或组件都已经开始加入，其他常用的像underscore、backbone或lodash也已经有人在提交或维护。</p><p>Flow另一个发展会是在开发工具的自动完成功能的改进，因为如果已经能在撰写代码时，就知道变量或常量的类型(静态类型)，那么在自动完成功能中就可以更准确地给出可用的属性或方法。这一个功能在Facebook自家的Nuclide开发工具的Flow说明页中就有看到。Nuclide是基于Atom开发工具之上的工具，计算机硬件如果不够力是跑不动的，而且它稳定性与运行速度都还需要再努力。这大概是未来可见到的一些新趋向。</p><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>本文简单的说明了Flow工具的功能介绍，以及其中的一些简要的内容等等。相信看过后你已经对这个Flow工具有一些认识，相较于T<strong>ypeScript的学习曲线**</strong>，Flow大概是等于不用学**。Flow虽然是一个很新的工具，但相当的有用，建议每个JavaScript开发者都可以试试，一开始不用学太多，大概这篇文档看完就可以开始用了。复杂的地方就再查找官方的文件即可。</p><p>对于每个正在使用JS开发稍具规模化的应用，或是开发开源码的函数库或框架的团队来说，让JS具有静态类型特性，是一个很重要而且必要的决定。以我的观察，在网络上一直有很多的超集语言(例如TypeScript)的爱好者，会提出要全面改用TypeScript(或其他超集语言)的声音，例如Vue.js在很早之前就有讨论是不是要全面采用TypeScript的声音。后来Vue.js只有提交TypeScript的<a href="https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/vue" target="_blank" rel="external">DefinitelyTyped</a>文档，但在2.0中则采行了Flow工具。在这篇Vue作者于知乎上发表的: <a href="https://www.zhihu.com/question/46397274" target="_blank" rel="external">Vue 2.0 为什么选用 Flow 进行静态代码检查而不是直接使用 TypeScript？</a>的内容中，你可以看到为何选择Flow的理由，这可能也是整个开发团队所认同的最后结果。作者回答的文中可以总结下面这句话:</p><blockquote><p>全部换 TS(TypeScript) 成本过高，短期内并不现实。 相比之下 Flow 对于已有的 ES2015 代码的迁入/迁出成本都非常低 … 万一哪天不想用 Flow 了，转一下，就得到符合规范的 ES。<br>总之，Flow提供了另一个选择，要用什么工具就看聪明的你如何选择了。</p></blockquote><p><a href="https://segmentfault.com/a/1190000008088489?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="external">参考文章地址 https://segmentfault.com/a/1190000008088489?utm_source=tuicool&amp;utm_medium=referral</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;纸上得来终觉浅，绝知此事要躬行&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近学习vue源码看到下面代码&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/iNBVV3k.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;心里不由WTF,查了下原来是flow代码,就立马去&lt;a href=&quot;https://flow.org/en/docs/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;官网把flow文档&lt;/a&gt;撸了一遍，网上又找了几遍文章，做下总结&lt;br&gt;
    
    </summary>
    
      <category term="tools" scheme="https://dsb123dsb.github.io/categories/tools/"/>
    
    
      <category term="js" scheme="https://dsb123dsb.github.io/tags/js/"/>
    
      <category term="flow" scheme="https://dsb123dsb.github.io/tags/flow/"/>
    
  </entry>
  
  <entry>
    <title>浅谈JS实现私有成员</title>
    <link href="https://dsb123dsb.github.io/2017/06/20/%E6%B5%85%E8%B0%88JS%E5%AE%9E%E7%8E%B0%E7%A7%81%E6%9C%89%E6%88%90%E5%91%98/"/>
    <id>https://dsb123dsb.github.io/2017/06/20/浅谈JS实现私有成员/</id>
    <published>2017-06-20T11:44:38.000Z</published>
    <updated>2017-10-03T13:53:51.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>纸上得来终觉浅，绝知此事要躬行</p></blockquote><h1 id="name形式私有"><a href="#name形式私有" class="headerlink" title="_name形式私有"></a>_name形式私有</h1><p>ES6 中有类语法，定义类变得简单了<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(name) &#123;</div><div class="line">        <span class="keyword">this</span>._name = name;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    get name() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._name;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>然而，并没有提供私有属性。比如上面的 Person 其实是希望在构造的时候传入 name，之后不允许修改了。不过，由于没有私有属性，所以难免有人会这样干：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Person james = <span class="keyword">new</span> Person(<span class="string">"James"</span>);</div><div class="line">james._name = <span class="string">"Tom"</span>;        <span class="comment">// God Save Me</span></div></pre></td></tr></table></figure></p><a id="more"></a><h1 id="symbol大法"><a href="#symbol大法" class="headerlink" title="symbol大法"></a>symbol大法</h1><p>不过，如果想定义私有成员，也有变通的方式，比如广为留传的 Symbol 大法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Person = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> _name = <span class="built_in">Symbol</span>();</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</div><div class="line">        <span class="keyword">constructor</span>(name) &#123;</div><div class="line">            <span class="keyword">this</span>[_name] = name;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        get name() &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>[_name];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> Person;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure></p><p>其实质在于匿名函数中的 Symbol 实例 _name 是局部变量，在外部不可访问。而 Symbol 由于自身的唯一性特点，也没法再造一个相同的出来，所以就模拟出来一个私有成员了。</p><h1 id="ES5模拟symbol"><a href="#ES5模拟symbol" class="headerlink" title="ES5模拟symbol"></a>ES5模拟symbol</h1><p>按照此思路，在 ES5 中其实也很容易模拟私有成员。局部变量是很容易做到的，在函数范围内 let 和 var 是一样的效果。问题在于模拟 Symbol 的唯一性。</p><p>ES5 没有 Sybmol，属性名称只可能是一个字符串，如果我们能做到这个字符串不可预料，那么就基本达到目标。要达到不可预期，一个随机数基本上就解决了。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Person = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> _name = <span class="string">"00"</span> + <span class="built_in">Math</span>.random();</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">        <span class="keyword">this</span>[_name] = name;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="built_in">Object</span>.defineProperty(Person.prototype, <span class="string">"name"</span>, &#123;</div><div class="line">        get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>[_name];</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> Person;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure></p><p>如果这个程序在 Web 页面中加载，那么每次刷新页面 _name 的值都会不同，但并不会影响程序的逻辑，外部程序不会出现任何不适。</p><h1 id="新提案"><a href="#新提案" class="headerlink" title="新提案"></a>新提案</h1><p>与私有方法一样，ES6 不支持私有属性。目前，<a href="https://github.com/tc39/proposal-class-fields#private-fields" target="_blank" rel="external">有一个提案</a>，为class加了私有属性。方法是在属性名之前，使用#表示。<br><figure class="highlight hs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="type">Point</span> &#123;</span></div><div class="line"><span class="class">  #x;</span></div><div class="line"><span class="class"></span></div><div class="line"><span class="class">  constructor(<span class="title">x</span> = 0) &#123;</span></div><div class="line"><span class="class">    #x = +x; // 写成 this.#x 亦可</span></div><div class="line"><span class="class">  &#125;</span></div><div class="line"><span class="class"></span></div><div class="line"><span class="class">  get x() &#123; return #x &#125;</span></div><div class="line"><span class="class">  set x(<span class="title">value</span>) &#123; #x = +value &#125;</span></div><div class="line"><span class="class">&#125;</span></div></pre></td></tr></table></figure></p><p>上面代码中，#x就表示私有属性x，在Point类之外是读取不到这个属性的。还可以看到，私有属性与实例的属性是可以同名的（比如，#x与get x()）。</p><p>私有属性可以指定初始值，在构造函数执行时进行初始化。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</div><div class="line">  #x = 0;</div><div class="line">  <span class="keyword">constructor</span>() &#123;</div><div class="line">    #x; // 0</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>之所以要引入一个新的前缀#表示私有属性，而没有采用private关键字，是因为 JavaScript 是一门动态语言，使用独立的符号似乎是唯一的可靠方法，能够准确地区分一种属性是否为私有属性。另外，Ruby 语言使用@表示私有属性，ES6 没有用这个符号而使用#，是因为@已经被留给了 <code>Decorator</code>。</p><p>该提案只规定了私有属性的写法。但是，很自然地，它也可以用来写私有方法。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</div><div class="line">  #a;</div><div class="line">  #b;</div><div class="line">  #sum() &#123; return #a + #b; &#125;</div><div class="line">  printSum() &#123; console.log(#sum()); &#125;</div><div class="line">  constructor(a, b) &#123; #a = a; #b = b; &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>与 Symbol 方案相比，ES5模拟Symbol的问题在于这个 _name 的值不会像 Symbol 一样会隐藏起来，在控制台可以用很多种办法把它找出来——当然在调试阶段这样做也没什么不可以。在开发阶段这个值仍然是不可预料的。</p><p>对于单个私有属性的情况，有人会找到私有 Key 的规律，比如上面的私有 Key 就是以 “000.” 开始的，遍历对象属性很容易找出来。在多个私有 Key 的情况下，也可以通过一些技术手段来找，比如<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPersonNameKey</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> v = <span class="string">""</span> + <span class="built_in">Math</span>.random();</div><div class="line">    <span class="keyword">var</span> p = <span class="keyword">new</span> Person(v);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> k <span class="keyword">in</span> p) &#123;</div><div class="line">        <span class="keyword">if</span> (p[k] === v) &#123;</div><div class="line">            <span class="keyword">return</span> k;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>但这些都是后话，做起来太费劲，一般人不会这么干。何况 Symbol 也是可以遍历的（通过 <code>Object.getOwnPropertySymbols()）</code>，完全可以以同样的方法来获取私有 Key。</p><p>参考<a href="https://segmentfault.com/a/1190000003488631" target="_blank" rel="external">https://segmentfault.com/a/1190000003488631</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;纸上得来终觉浅，绝知此事要躬行&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;name形式私有&quot;&gt;&lt;a href=&quot;#name形式私有&quot; class=&quot;headerlink&quot; title=&quot;_name形式私有&quot;&gt;&lt;/a&gt;_name形式私有&lt;/h1&gt;&lt;p&gt;ES6 中有类语法，定义类变得简单了&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Person&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;constructor&lt;/span&gt;(name) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;._name = name;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    get name() &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;._name;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;然而，并没有提供私有属性。比如上面的 Person 其实是希望在构造的时候传入 name，之后不允许修改了。不过，由于没有私有属性，所以难免有人会这样干：&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;Person james = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Person(&lt;span class=&quot;string&quot;&gt;&quot;James&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;james._name = &lt;span class=&quot;string&quot;&gt;&quot;Tom&quot;&lt;/span&gt;;        &lt;span class=&quot;comment&quot;&gt;// God Save Me&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="基础杂谈" scheme="https://dsb123dsb.github.io/categories/%E5%9F%BA%E7%A1%80%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="ES6" scheme="https://dsb123dsb.github.io/tags/ES6/"/>
    
      <category term="symbol" scheme="https://dsb123dsb.github.io/tags/symbol/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 内存泄漏教程</title>
    <link href="https://dsb123dsb.github.io/2017/06/07/JavaScript-%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%95%99%E7%A8%8B/"/>
    <id>https://dsb123dsb.github.io/2017/06/07/JavaScript-内存泄漏教程/</id>
    <published>2017-06-07T12:19:40.000Z</published>
    <updated>2017-10-03T13:53:51.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>纸上得来终觉浅，绝知此事要躬行</p></blockquote><p>看到阮一峰一篇关于内存泄漏的文章，发现很全，ES6、node相关也都有,个人收益较大部分是weakmap，weakset部分——————<a href="http://www.ruanyifeng.com/blog/2017/04/memory-leak.html" target="_blank" rel="external">原文猛搓</a></p><h1 id="什么是内存泄漏？"><a href="#什么是内存泄漏？" class="headerlink" title="什么是内存泄漏？"></a>什么是内存泄漏？</h1><p>程序的运行需要内存。只要程序提出要求，操作系统或者运行时（runtime）就必须供给内存。</p><p>对于持续运行的服务进程（daemon），必须及时释放不再用到的内存。否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2017/bg2017041701-1.png" alt=""></p><p>不再用到的内存，没有及时释放，就叫做内存泄漏（memory leak）。<br>有些语言（比如 C 语言）必须手动释放内存，程序员负责内存管理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span> * buffer;</div><div class="line">buffer = (<span class="keyword">char</span>*) <span class="built_in">malloc</span>(<span class="number">42</span>);</div><div class="line"></div><div class="line"><span class="comment">// Do something with buffer</span></div><div class="line"></div><div class="line"><span class="built_in">free</span>(buffer);</div></pre></td></tr></table></figure><p>上面是 C 语言代码，<code>malloc</code>方法用来申请内存，使用完毕之后，必须自己用<code>free</code>方法释放内存。<br><a id="more"></a><br>这很麻烦，所以大多数语言提供自动内存管理，减轻程序员的负担，这被称为”垃圾回收机制”（garbage collector）。</p><h1 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h1><p>垃圾回收机制怎么知道，哪些内存不再需要呢？</p><p>最常使用的方法叫做”<a href="https://en.wikipedia.org/wiki/Reference_counting" target="_blank" rel="external">引用计数</a>“（reference counting）：语言引擎有一张”引用表”，保存了内存里面所有的资源（通常是各种值）的引用次数。如果一个值的引用次数是0，就表示这个值不再用到了，因此可以将这块内存释放。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2017/bg2017041703.png" alt=""></p><p>上图中，左下角的两个值，没有任何引用，所以可以释放。</p><p>如果一个值不再需要了，引用数却不为0，垃圾回收机制无法释放这块内存，从而导致内存泄漏。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'hello world'</span>);</div></pre></td></tr></table></figure><p>上面代码中，数组<code>[1, 2, 3, 4]</code>是一个值，会占用内存。变量arr是仅有的对这个值的引用，因此引用次数为1。尽管后面的代码没有用到arr，它还是会持续占用内存。</p><p>如果增加一行代码，解除arr对<code>[1, 2, 3, 4]</code>引用，这块内存就可以被垃圾回收机制释放了。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'hello world'</span>);</div><div class="line">arr = <span class="literal">null</span>;</div></pre></td></tr></table></figure></p><p>上面代码中，arr重置为<code>null</code>，就解除了对<code>[1, 2, 3, 4]</code>的引用，引用次数变成了0，内存就可以释放出来了。</p><p>因此，并不是说有了垃圾回收机制，程序员就轻松了。你还是需要关注内存占用：那些很占空间的值，一旦不再用到，你必须检查是否还存在对它们的引用。如果是的话，就必须手动解除引用。</p><h1 id="内存泄漏的识别方法"><a href="#内存泄漏的识别方法" class="headerlink" title="内存泄漏的识别方法"></a>内存泄漏的识别方法</h1><p>怎样可以观察到内存泄漏呢？<br><a href="https://www.toptal.com/nodejs/debugging-memory-leaks-node-js-applications" target="_blank" rel="external">经验法则是</a>，如果连续五次垃圾回收之后，内存占用一次比一次大，就有内存泄漏。这就要求实时查看内存占用。</p><h2 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h2><p>Chrome 浏览器查看内存占用，按照以下步骤操作。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2017/bg2017041704.png" alt=""></p><ol><li>打开开发者工具，选择 Timeline 面板</li><li>在顶部的Capture字段里面勾选 Memory</li><li>点击左上角的录制按钮。</li><li>在页面上进行各种操作，模拟用户的使用情况。</li></ol><p>一段时间后，点击对话框的 stop 按钮，面板上就会显示这段时间的内存占用情况。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2017/bg2017041705.png" alt=""></p><p>反之，就是内存泄漏了。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2017/bg2017041706.png" alt=""></p><h1 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h1><p>命令行可以使用 <code>Node</code> 提供的<a href="https://nodejs.org/api/process.html#process_process_memoryusage" target="_blank" rel="external">process.memoryUsage</a>方法。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(process.memoryUsage());</div><div class="line"><span class="comment">// &#123; rss: 27709440,</span></div><div class="line"><span class="comment">//  heapTotal: 5685248,</span></div><div class="line"><span class="comment">//  heapUsed: 3449392,</span></div><div class="line"><span class="comment">//  external: 8772 &#125;</span></div></pre></td></tr></table></figure></p><p>process.memoryUsage返回一个对象，包含了 Node 进程的内存占用信息。该对象包含四个字段，单位是字节，<a href="http://stackoverflow.com/questions/12023359/what-do-the-return-values-of-node-js-process-memoryusage-stand-for" target="_blank" rel="external">含义如</a>下。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2017/bg2017041702-1.png" alt=""></p><ul><li>rss（resident set size）：所有内存占用，包括指令区和堆栈。</li><li>heapTotal：”堆”占用的内存，包括用到的和没用到的。</li><li>heapUsed：用到的堆的部分。</li><li>external： V8 引擎内部的 C++ 对象占用的内存。</li></ul><p>判断内存泄漏，以<code>heapUsed</code>字段为准</p><h1 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h1><p>前面说过，及时清除引用非常重要。但是，你不可能记得那么多，有时候一疏忽就忘了，所以才有那么多内存泄漏。</p><p>最好能有一种方法，在新建引用的时候就声明，哪些引用必须手动清除，哪些引用可以忽略不计，当其他引用消失以后，垃圾回收机制就可以释放内存。这样就能大大减轻程序员的负担，你只要清除主要引用就可以了。</p><p>ES6 考虑到了这一点，推出了两种新的数据结构：<a href="http://es6.ruanyifeng.com/#docs/set-map#WeakSet" target="_blank" rel="external">WeakSet</a> 和 <a href="http://es6.ruanyifeng.com/#docs/set-map#WeakMap" target="_blank" rel="external">WeakMap</a>。它们对于值的引用都是不计入垃圾回收机制的，所以名字里面才会有一个”Weak”，表示这是弱引用。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2017/bg2017041707.jpg" alt=""></p><p>下面以 WeakMap 为例，看看它是怎么解决内存泄漏的。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</div><div class="line"></div><div class="line"><span class="keyword">const</span> element = <span class="built_in">document</span>.getElementById(<span class="string">'example'</span>);</div><div class="line"></div><div class="line">wm.set(element, <span class="string">'some information'</span>);</div><div class="line">wm.get(element) <span class="comment">// "some information"</span></div></pre></td></tr></table></figure></p><p>上面代码中，先新建一个 <code>Weakmap</code> 实例。然后，将一个 DOM 节点作为键名存入该实例，并将一些附加信息作为键值，一起存放在 WeakMap 里面。这时，WeakMap 里面对<code>element</code>的引用就是弱引用，不会被计入垃圾回收机制。</p><p>也就是说，DOM 节点对象的引用计数是1，而不是2。这时，一旦消除对该节点的引用，它占用的内存就会被垃圾回收机制释放。Weakmap 保存的这个键值对，也会自动消失。</p><p>基本上，如果你要往对象上添加数据，又不想干扰垃圾回收机制，就可以使用 WeakMap。</p><h1 id="WeakMap-示例"><a href="#WeakMap-示例" class="headerlink" title="WeakMap 示例"></a>WeakMap 示例</h1><p>WeakMap 的例子很难演示，因为无法观察它里面的引用会自动消失。此时，其他引用都解除了，已经没有引用指向 WeakMap 的键名了，导致无法证实那个键名是不是存在。</p><p>我一直想不出办法，直到有一天贺师俊老师<a href="https://github.com/ruanyf/es6tutorial/issues/362#issuecomment-292109104" target="_blank" rel="external">提示</a>，如果引用所指向的值占用特别多的内存，就可以通过<code>process.memoryUsage</code>方法看出来。</p><p>根据这个思路，网友 <a href="https://github.com/ruanyf/es6tutorial/issues/362#issuecomment-292451925" target="_blank" rel="external">vtxf </a>补充了下面的例子。</p><p>首先，打开 Node 命令行。</p><pre><code>$ node --expose-gc</code></pre><p>上面代码中，<code>--expose-gc</code>参数表示允许手动执行垃圾回收机制。</p><p>然后，执行下面的代码。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 手动执行一次垃圾回收，保证获取的内存使用状态准确</span></div><div class="line">&gt; global.gc(); </div><div class="line"><span class="literal">undefined</span></div><div class="line"></div><div class="line"><span class="comment">// 查看内存占用的初始状态，heapUsed 为 4M 左右</span></div><div class="line">&gt; process.memoryUsage(); </div><div class="line">&#123; <span class="attr">rss</span>: <span class="number">21106688</span>,</div><div class="line">  heapTotal: <span class="number">7376896</span>,</div><div class="line">  heapUsed: <span class="number">4153936</span>,</div><div class="line">  external: <span class="number">9059</span> &#125;</div><div class="line"></div><div class="line">&gt; <span class="keyword">let</span> wm = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</div><div class="line"><span class="literal">undefined</span></div><div class="line"></div><div class="line">&gt; <span class="keyword">let</span> b = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line"><span class="literal">undefined</span></div><div class="line"></div><div class="line">&gt; global.gc();</div><div class="line"><span class="literal">undefined</span></div><div class="line"></div><div class="line"><span class="comment">// 此时，heapUsed 仍然为 4M 左右</span></div><div class="line">&gt; process.memoryUsage(); </div><div class="line">&#123; <span class="attr">rss</span>: <span class="number">20537344</span>,</div><div class="line">  heapTotal: <span class="number">9474048</span>,</div><div class="line">  heapUsed: <span class="number">3967272</span>,</div><div class="line">  external: <span class="number">8993</span> &#125;</div><div class="line"></div><div class="line"><span class="comment">// 在 WeakMap 中添加一个键值对，</span></div><div class="line"><span class="comment">// 键名为对象 b，键值为一个 5*1024*1024 的数组  </span></div><div class="line">&gt; wm.set(b, <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">5</span>*<span class="number">1024</span>*<span class="number">1024</span>));</div><div class="line"><span class="built_in">WeakMap</span> &#123;&#125;</div><div class="line"></div><div class="line"><span class="comment">// 手动执行一次垃圾回收</span></div><div class="line">&gt; global.gc();</div><div class="line"><span class="literal">undefined</span></div><div class="line"></div><div class="line"><span class="comment">// 此时，heapUsed 为 45M 左右</span></div><div class="line">&gt; process.memoryUsage(); </div><div class="line">&#123; <span class="attr">rss</span>: <span class="number">62652416</span>,</div><div class="line">  heapTotal: <span class="number">51437568</span>,</div><div class="line">  heapUsed: <span class="number">45911664</span>,</div><div class="line">  external: <span class="number">8951</span> &#125;</div><div class="line"></div><div class="line"><span class="comment">// 解除对象 b 的引用  </span></div><div class="line">&gt; b = <span class="literal">null</span>;</div><div class="line"><span class="literal">null</span></div><div class="line"></div><div class="line"><span class="comment">// 再次执行垃圾回收</span></div><div class="line">&gt; global.gc();</div><div class="line"><span class="literal">undefined</span></div><div class="line"></div><div class="line"><span class="comment">// 解除 b 的引用以后，heapUsed 变回 4M 左右</span></div><div class="line"><span class="comment">// 说明 WeakMap 中的那个长度为 5*1024*1024 的数组被销毁了</span></div><div class="line">&gt; process.memoryUsage(); </div><div class="line">&#123; <span class="attr">rss</span>: <span class="number">20639744</span>,</div><div class="line">  heapTotal: <span class="number">8425472</span>,</div><div class="line">  heapUsed: <span class="number">3979792</span>,</div><div class="line">  external: <span class="number">8956</span> &#125;</div></pre></td></tr></table></figure></p><p>上面代码中，只要外部的引用消失，<code>WeakMap</code> 内部的引用，就会自动被垃圾回收清除。由此可见，有了它的帮助，解决内存泄漏就会简单很多。</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul><li><a href="https://www.alexkras.com/simple-guide-to-finding-a-javascript-memory-leak-in-node-js/" target="_blank" rel="external">Simple Guide to Finding a JavaScript Memory Leak in Node.js</a></li><li><a href="https://www.dynatrace.com/blog/understanding-garbage-collection-and-hunting-memory-leaks-in-node-js/" target="_blank" rel="external">Understanding Garbage Collection and hunting Memory Leaks in Node.js</a></li><li><a href="https://www.toptal.com/nodejs/debugging-memory-leaks-node-js-applications" target="_blank" rel="external">Debugging Memory Leaks in Node.js Applications</a></li></ul><p>(完)</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;纸上得来终觉浅，绝知此事要躬行&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;看到阮一峰一篇关于内存泄漏的文章，发现很全，ES6、node相关也都有,个人收益较大部分是weakmap，weakset部分——————&lt;a href=&quot;http://www.ruanyifeng.com/blog/2017/04/memory-leak.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;原文猛搓&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;什么是内存泄漏？&quot;&gt;&lt;a href=&quot;#什么是内存泄漏？&quot; class=&quot;headerlink&quot; title=&quot;什么是内存泄漏？&quot;&gt;&lt;/a&gt;什么是内存泄漏？&lt;/h1&gt;&lt;p&gt;程序的运行需要内存。只要程序提出要求，操作系统或者运行时（runtime）就必须供给内存。&lt;/p&gt;
&lt;p&gt;对于持续运行的服务进程（daemon），必须及时释放不再用到的内存。否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.ruanyifeng.com/blogimg/asset/2017/bg2017041701-1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;不再用到的内存，没有及时释放，就叫做内存泄漏（memory leak）。&lt;br&gt;有些语言（比如 C 语言）必须手动释放内存，程序员负责内存管理。&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; * buffer;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;buffer = (&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt;*) &lt;span class=&quot;built_in&quot;&gt;malloc&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;42&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Do something with buffer&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;free&lt;/span&gt;(buffer);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面是 C 语言代码，&lt;code&gt;malloc&lt;/code&gt;方法用来申请内存，使用完毕之后，必须自己用&lt;code&gt;free&lt;/code&gt;方法释放内存。&lt;br&gt;
    
    </summary>
    
      <category term="基础杂谈" scheme="https://dsb123dsb.github.io/categories/%E5%9F%BA%E7%A1%80%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="js" scheme="https://dsb123dsb.github.io/tags/js/"/>
    
      <category term="内存泄漏" scheme="https://dsb123dsb.github.io/tags/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Vue2.17源码学习</title>
    <link href="https://dsb123dsb.github.io/2017/05/25/Vue2-17%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    <id>https://dsb123dsb.github.io/2017/05/25/Vue2-17源码学习/</id>
    <published>2017-05-25T14:00:39.000Z</published>
    <updated>2017-10-03T13:53:51.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>纸上得来终觉浅，绝知此事要躬</p></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前段时间看到尤雨溪推荐了一篇vue源码的文章，自己一直也想研究下源码，这几天抽空看了，<a href="http://hcysun.me/2017/03/03/Vue%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/" target="_blank" rel="external">原文猛戳</a></p><p>原本文章的名字叫做《源码解析》，不过后来想想，还是用“源码学习”来的合适一点，在没有彻底掌握源码中的每一个字母之前，“解析”就有点标题党了。建议在看这篇文章之前，最好打开<code>2.1.7</code>的源码对照着看，这样可能更容易理解。另外本人水平有限，文中有错误或不妥的地方望大家多多指正共同成长。</p><p>补充：<code>Vue 2.2</code> 刚刚发布，作为一个系列文章的第一篇，本篇文章主要从Vue代码的组织，Vue构造函数的还原，原型的设计，以及参数选项的处理和已经被写烂了的数据绑定与如何使用 Virtual DOM 更新视图入手。从整体的大方向观察框架，这么看来 <code>V2.1.7</code> 对于理解 <code>V2.2</code>的代码不会有太大的影响。该系列文章的后续文章，都会从最新的源码入手，并对改动的地方做相应的提示。</p><p>很久之前写过一篇文章：<a href="http://hcysun.me/2016/04/28/JavaScript%E5%AE%9E%E7%8E%B0MVVM%E4%B9%8B%E6%88%91%E5%B0%B1%E6%98%AF%E6%83%B3%E7%9B%91%E6%B5%8B%E4%B8%80%E4%B8%AA%E6%99%AE%E9%80%9A%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8F%98%E5%8C%96/" target="_blank" rel="external">JavaScript实现MVVM之我就是想监测一个普通对象的变化</a>，文章开头提到了我写博客的风格，还是那句话，只写努力让小白，甚至是小学生都能看明白的文章。这不免会导致对于某些同学来说这篇文章有些墨迹，所以大家根据自己的喜好，可以详细的看，也可以跳跃着看。<br><a id="more"></a></p><h1 id="从了解一个开源项目入手"><a href="#从了解一个开源项目入手" class="headerlink" title="从了解一个开源项目入手"></a>从了解一个开源项目入手</h1><p>要看一个项目的源码，不要一上来就看，先去了解一下项目本身的元数据和依赖，除此之外最好也了解一下 PR 规则，Issue Reporting 规则等等。特别是“前端”开源项目，我们在看源码之前第一个想到的应该是：<code>package.json</code>文件。</p><p>在 <code>package.json</code> 文件中，我们最应该关注的就是 <code>scripts</code> 字段和 <code>devDependencies</code> 以及 <code>dependencies</code> 字段，通过 <code>scripts</code> 字段我们可以知道项目中定义的脚本命令，通过 <code>devDependencies</code>和 <code>dependencies</code> 字段我们可以了解项目的依赖情况。</p><p>了解了这些之后，如果有依赖我们就 <code>npm install</code> 安装依赖就ok了。</p><p>除了 <code>package.json</code> 之外，我们还要阅读项目的贡献规则文档，了解如何开始，一个好的开源项目肯定会包含这部分内容的，Vue也不例外：<a href="https://github.com/vuejs/vue/blob/dev/.github/CONTRIBUTING.md" target="_blank" rel="external">https://github.com/vuejs/vue/blob/dev/.github/CONTRIBUTING.md</a>，在这个文档里说明了一些行为准则，PR指南，Issue Reporting 指南，Development Setup 以及 项目结构。通过阅读这些内容，我们可以了解项目如何开始，如何开发以及目录的说明，下面是对重要目录和文件的简单介绍，这些内容你都可以去自己阅读获取：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">├── build --------------------------------- 构建相关的文件，一般情况下我们不需要动</div><div class="line">├── dist ---------------------------------- 构建后文件的输出目录</div><div class="line">├── examples ------------------------------ 存放一些使用Vue开发的应用案例</div><div class="line">├── flow ---------------------------------- 类型声明，使用开源项目 [Flow](https://flowtype.org/)</div><div class="line">├── package.json -------------------------- 不解释</div><div class="line">├── test ---------------------------------- 包含所有测试文件</div><div class="line">├── src ----------------------------------- 这个是我们最应该关注的目录，包含了源码</div><div class="line">│   ├── entries --------------------------- 包含了不同的构建或包的入口文件</div><div class="line">│   │   ├── web-runtime.js ---------------- 运行时构建的入口，输出 dist/vue.common.js 文件，不包含模板(template)到render函数的编译器，所以不支持 `template` 选项，我们使用vue默认导出的就是这个运行时的版本。大家使用的时候要注意</div><div class="line">│   │   ├── web-runtime-with-compiler.js -- 独立构建版本的入口，输出 dist/vue.js，它包含模板(template)到render函数的编译器</div><div class="line">│   │   ├── web-compiler.js --------------- vue-template-compiler 包的入口文件</div><div class="line">│   │   ├── web-server-renderer.js -------- vue-server-renderer 包的入口文件</div><div class="line">│   ├── compiler -------------------------- 编译器代码的存放目录，将 template 编译为 render 函数</div><div class="line">│   │   ├── parser ------------------------ 存放将模板字符串转换成元素抽象语法树的代码</div><div class="line">│   │   ├── codegen ----------------------- 存放从抽象语法树(AST)生成render函数的代码</div><div class="line">│   │   ├── optimizer.js ------------------ 分析静态树，优化vdom渲染</div><div class="line">│   ├── core ------------------------------ 存放通用的，平台无关的代码</div><div class="line">│   │   ├── observer ---------------------- 反应系统，包含数据观测的核心代码</div><div class="line">│   │   ├── vdom -------------------------- 包含虚拟DOM创建(creation)和打补丁(patching)的代码</div><div class="line">│   │   ├── instance ---------------------- 包含Vue构造函数设计相关的代码</div><div class="line">│   │   ├── global-api -------------------- 包含给Vue构造函数挂载全局方法(静态方法)或属性的代码</div><div class="line">│   │   ├── components -------------------- 包含抽象出来的通用组件</div><div class="line">│   ├── server ---------------------------- 包含服务端渲染(server-side rendering)的相关代码</div><div class="line">│   ├── platforms ------------------------- 包含平台特有的相关代码</div><div class="line">│   ├── sfc ------------------------------- 包含单文件组件(.vue文件)的解析逻辑，用于vue-template-compiler包</div><div class="line">│   ├── shared ---------------------------- 包含整个代码库通用的代码</div></pre></td></tr></table></figure><p>大概了解了重要目录和文件之后，我们就可以查看 <a href="https://github.com/vuejs/vue/blob/dev/.github/CONTRIBUTING.md#development-setup" target="_blank" rel="external">Development Setup</a> 中的常用命令部分，来了解如何开始这个项目了，我们可以看到这样的介绍：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"># watch and auto re-build dist/vue.js</div><div class="line">$ npm run dev</div><div class="line"></div><div class="line"># watch and auto re-run unit tests in Chrome</div><div class="line">$ npm run dev:test</div></pre></td></tr></table></figure></p><p>现在，我们只需要运行 <code>npm run dev</code> 即可监测文件变化并自动重新构建输出 <code>dist/vue.js</code>，然后运行 <code>npm run dev:test</code> 来测试。不过为了方便，我会在 <code>examples</code> 目录新建一个例子，然后引用 <code>dist/vue.js</code> 这样，我们可以直接拿这个例子一边改Vue源码一边看自己写的代码想怎么玩怎么玩。</p><h1 id="看源码的小提示"><a href="#看源码的小提示" class="headerlink" title="看源码的小提示"></a>看源码的小提示</h1><p>在真正步入源码世界之前，我想简单说一说看源码的技巧：<br><em>注重大体框架，从宏观到微观</em></p><p>当你看一个项目代码的时候，最好是能找到一条主线，先把大体流程结构摸清楚，再深入到细节，逐项击破，拿Vue举个栗子：假如你已经知道Vue中数据状态改变后会采用virtual DOM的方式更新DOM，这个时候，如果你不了解virtual DOM，那么听我一句“暂且不要去研究内部具体实现，因为这会是你丧失主线”，而你仅仅需要知道virtual DOM分为三个步骤：</p><ol><li>createElement(): 用 JavaScript对象(虚拟树) 描述 真实DOM对象(真实树)</li><li>diff(oldNode, newNode) : 对比新旧两个虚拟树的区别，收集差异</li><li>patch() : 将差异应用到真实DOM树</li></ol><p>有的时候 第二步 可能与 第三步 合并成一步(Vue 中的patch就是这样)，除此之外，还比如 <code>src/compiler/codegen</code> 内的代码，可能你不知道他写了什么，直接去看它会让你很痛苦，但是你只需要知道 codegen 是用来将抽象语法树(AST)生成render函数的就OK了，也就是生成类似下面这样的代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">anonymous</span>(<span class="params"></span>) </span>&#123;</div><div class="line"><span class="keyword">with</span>(<span class="keyword">this</span>)&#123;<span class="keyword">return</span> _c(<span class="string">'p'</span>,&#123;<span class="attr">attrs</span>:&#123;<span class="string">"id"</span>:<span class="string">"app"</span>&#125;&#125;,[_v(<span class="string">"\n      "</span>+_s(a)+<span class="string">"\n      "</span>),_c(<span class="string">'my-com'</span>)])&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>当我们知道了一个东西存在，且知道它存在的目的，那么我们就很容易抓住这条主线，这个系列的第一篇文章就是围绕大体主线展开的。了解大体之后，我们就知道了每部分内容都是做什么的，比如 codegen 是生成类似上面贴出的代码所示的函数的，那么再去看codegen下的代码时，目的性就会更强，就更容易理解。</p><h1 id="Vue-的构造函数是什么样的"><a href="#Vue-的构造函数是什么样的" class="headerlink" title="Vue 的构造函数是什么样的"></a>Vue 的构造函数是什么样的</h1><p>balabala一大堆，开始来干货吧。我们要做的第一件事就是搞清楚 Vue 构造函数到底是什么样子的。<br>我们知道，我们要使用 <code>new</code> 操作符来调用 <code>Vue</code>，那么也就是说 <code>Vue</code> 应该是一个构造函数，所以我们第一件要做的事儿就是把构造函数先扒的一清二楚，如何寻找 <code>Vue</code> 构造函数呢？当然是从 <code>entry</code> 开始啦，还记的我们运行 <code>npm run dev</code> 命令后，会输出 <code>dist/vue.js</code> 吗，那么我们就去看看 <code>npm run dev</code> 干了什么：</p><pre><code>&quot;dev&quot;: &quot;TARGET=web-full-dev rollup -w -c build/config.js&quot;,</code></pre><p>首先将 TARGET 得值设置为 ‘web-full-dev’，然后，然后，然后如果你不了解 rollup 就应该简单去看一下啦……，简单的说就是一个JavaScript模块打包器，你可以把它简单的理解为和 webpack 一样，只不过它有他的优势，比如 Tree-shaking (webpack2也有)，但同样，在某些场景它也有他的劣势。。。废话不多说，其中 <code>-w</code> 就是watch，<code>-c</code> 就是指定配置文件为 <code>build/config.js</code> ，我们打开这个配置文件看一看：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">// 引入依赖，定义 banner</span></div><div class="line">...</div><div class="line"></div><div class="line"><span class="comment">// builds 对象</span></div><div class="line"><span class="keyword">const</span> builds = &#123;</div><div class="line">...</div><div class="line"><span class="comment">// Runtime+compiler development build (Browser)</span></div><div class="line"><span class="string">'web-full-dev'</span>: &#123;</div><div class="line">    entry: path.resolve(__dirname, <span class="string">'../src/entries/web-runtime-with-compiler.js'</span>),</div><div class="line">    dest: path.resolve(__dirname, <span class="string">'../dist/vue.js'</span>),</div><div class="line">    format: <span class="string">'umd'</span>,</div><div class="line">    env: <span class="string">'development'</span>,</div><div class="line">    alias: &#123; <span class="attr">he</span>: <span class="string">'./entity-decoder'</span> &#125;,</div><div class="line">    banner</div><div class="line">&#125;,</div><div class="line">...</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 生成配置的方法</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">genConfig</span>(<span class="params">opts</span>)</span>&#123;</div><div class="line">...</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (process.env.TARGET) &#123;</div><div class="line">  <span class="built_in">module</span>.exports = genConfig(builds[process.env.TARGET])</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">  exports.getBuild = <span class="function"><span class="params">name</span> =&gt;</span> genConfig(builds[name])</div><div class="line">  exports.getAllBuilds = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">Object</span>.keys(builds).map(<span class="function"><span class="params">name</span> =&gt;</span> genConfig(builds[name]))</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>上面的代码是简化过的，当我们运行<code>npm run dev</code> 的时候 <code>process.env.TARGET</code> 的值等于 ‘web-full-dev’，所以</p><pre><code>module.exports = genConfig(builds[process.env.TARGET])</code></pre><p>这句代码相当于：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = genConfig(&#123;</div><div class="line">    entry: path.resolve(__dirname, <span class="string">'../src/entries/web-runtime-with-compiler.js'</span>),</div><div class="line">    dest: path.resolve(__dirname, <span class="string">'../dist/vue.js'</span>),</div><div class="line">    format: <span class="string">'umd'</span>,</div><div class="line">    env: <span class="string">'development'</span>,</div><div class="line">    alias: &#123; <span class="attr">he</span>: <span class="string">'./entity-decoder'</span> &#125;,</div><div class="line">    banner</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p><p>最终，genConfig 函数返回一个 config 对象，这个config对象就是Rollup的配置对象。那么我们就不难看到，入口文件是：</p><pre><code>src/entries/web-runtime-with-compiler.js</code></pre><p>我们打开这个文件，不要忘了我们的主题，我们在寻找Vue构造函数，所以当我们看到这个文件的第一行代码是：</p><pre><code>import Vue from &apos;./web-runtime&apos;</code></pre><p>这个时候，你就应该知道，这个文件暂时与你无缘，你应该打开 <code>web-runtime.js</code>文件，不过当你打开这个文件时，你发现第一行是这样的：</p><pre><code>import Vue from &apos;core/index&apos;</code></pre><p>依照此思路，最终我们寻找到Vue构造函数的位置应该是在 <code>src/core/instance/index.js</code> 文件中，其实我们猜也猜得到，上面介绍目录的时候说过：instance 是存放Vue构造函数设计相关代码的目录。总结一下，我们寻找的过程是这样的：</p><p><img src="http://7xlolm.com1.z0.glb.clouddn.com/vueimg2BD0DCC6-D689-4809-93D3-2F979E8F8C0C.png" alt=""></p><p>我们回头看一看 <code>src/core/instance/index.js</code> 文件，很简单：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">import</span> &#123; initMixin &#125; <span class="keyword">from</span> <span class="string">'./init'</span></div><div class="line"><span class="keyword">import</span> &#123; stateMixin &#125; <span class="keyword">from</span> <span class="string">'./state'</span></div><div class="line"><span class="keyword">import</span> &#123; renderMixin &#125; <span class="keyword">from</span> <span class="string">'./render'</span></div><div class="line"><span class="keyword">import</span> &#123; eventsMixin &#125; <span class="keyword">from</span> <span class="string">'./events'</span></div><div class="line"><span class="keyword">import</span> &#123; lifecycleMixin &#125; <span class="keyword">from</span> <span class="string">'./lifecycle'</span></div><div class="line"><span class="keyword">import</span> &#123; warn &#125; <span class="keyword">from</span> <span class="string">'../util/index'</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Vue</span> (<span class="params">options</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp;</div><div class="line">    !(<span class="keyword">this</span> <span class="keyword">instanceof</span> Vue)) &#123;</div><div class="line">    warn(<span class="string">'Vue is a constructor and should be called with the `new` keyword'</span>)</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">this</span>._init(options)</div><div class="line">&#125;</div><div class="line"></div><div class="line">initMixin(Vue)</div><div class="line">stateMixin(Vue)</div><div class="line">eventsMixin(Vue)</div><div class="line">lifecycleMixin(Vue)</div><div class="line">renderMixin(Vue)</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> Vue</div></pre></td></tr></table></figure></p><p>引入依赖，定义 Vue 构造函数，然后以Vue构造函数为参数，调用了五个方法，最后导出 Vue。这五个方法分别来自五个文件：<code>init.js state.js render.js events.js</code> 以及 <code>lifecycle.js</code>。<br>打开这五个文件，找到相应的方法，你会发现，这些方法的作用，就是在 Vue 的原型 prototype 上挂载方法或属性，经历了这五个方法后的Vue会变成这样：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">// initMixin(Vue)src/core/instance/init.js **************************************************</span></div><div class="line">Vue.prototype._init = <span class="function"><span class="keyword">function</span> (<span class="params">options?: Object</span>) </span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="comment">// stateMixin(Vue)src/core/instance/state.js **************************************************</span></div><div class="line">Vue.prototype.$data</div><div class="line">Vue.prototype.$set = set</div><div class="line">Vue.prototype.$<span class="keyword">delete</span> = del</div><div class="line">Vue.prototype.$watch = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="comment">// renderMixin(Vue)src/core/instance/render.js **************************************************</span></div><div class="line">Vue.prototype.$nextTick = <span class="function"><span class="keyword">function</span> (<span class="params">fn: Function</span>) </span>&#123;&#125;</div><div class="line">Vue.prototype._render = <span class="function"><span class="keyword">function</span> (<span class="params"></span>): <span class="title">VNode</span> </span>&#123;&#125;</div><div class="line">Vue.prototype._s = _toString</div><div class="line">Vue.prototype._v = createTextVNode</div><div class="line">Vue.prototype._n = toNumber</div><div class="line">Vue.prototype._e = createEmptyVNode</div><div class="line">Vue.prototype._q = looseEqual</div><div class="line">Vue.prototype._i = looseIndexOf</div><div class="line">Vue.prototype._m = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line">Vue.prototype._o = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line">Vue.prototype._f = <span class="function"><span class="keyword">function</span> <span class="title">resolveFilter</span> (<span class="params">id</span>) </span>&#123;&#125;</div><div class="line">Vue.prototype._l = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line">Vue.prototype._t = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line">Vue.prototype._b = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line">Vue.prototype._k = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="comment">// eventsMixin(Vue)src/core/instance/events.js **************************************************</span></div><div class="line">Vue.prototype.$on = <span class="function"><span class="keyword">function</span> (<span class="params">event: string, fn: Function</span>): <span class="title">Component</span> </span>&#123;&#125;</div><div class="line">Vue.prototype.$once = <span class="function"><span class="keyword">function</span> (<span class="params">event: string, fn: Function</span>): <span class="title">Component</span> </span>&#123;&#125;</div><div class="line">Vue.prototype.$off = <span class="function"><span class="keyword">function</span> (<span class="params">event?: string, fn?: Function</span>): <span class="title">Component</span> </span>&#123;&#125;</div><div class="line">Vue.prototype.$emit = <span class="function"><span class="keyword">function</span> (<span class="params">event: string</span>): <span class="title">Component</span> </span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="comment">// lifecycleMixin(Vue)src/core/instance/lifecycle.js **************************************************</span></div><div class="line">Vue.prototype._mount = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line">Vue.prototype._update = <span class="function"><span class="keyword">function</span> (<span class="params">vnode: VNode, hydrating?: boolean</span>) </span>&#123;&#125;</div><div class="line">Vue.prototype._updateFromParent = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line">Vue.prototype.$forceUpdate = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</div><div class="line">Vue.prototype.$destroy = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</div></pre></td></tr></table></figure></p><p>这样就结束了吗？并没有，根据我们之前寻找 Vue 的路线，这只是刚刚开始，我们追溯路线往回走，那么下一个处理 Vue 构造函数的应该是 <code>src/core/index.js</code> 文件，我们打开它：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'./instance/index'</span></div><div class="line"><span class="keyword">import</span> &#123; initGlobalAPI &#125; <span class="keyword">from</span> <span class="string">'./global-api/index'</span></div><div class="line"><span class="keyword">import</span> &#123; isServerRendering &#125; <span class="keyword">from</span> <span class="string">'core/util/env'</span></div><div class="line"></div><div class="line">initGlobalAPI(Vue)</div><div class="line"></div><div class="line"><span class="built_in">Object</span>.defineProperty(Vue.prototype, <span class="string">'$isServer'</span>, &#123;</div><div class="line">  get: isServerRendering</div><div class="line">&#125;)</div><div class="line"></div><div class="line">Vue.version = <span class="string">'__VERSION__'</span></div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> Vue</div></pre></td></tr></table></figure></p><p>这个文件也很简单，从 <code>instance/index</code> 中导入已经在原型上挂载了方法和属性后的 Vue，然后导入 <code>initGlobalAPI</code> 和 <code>isServerRendering</code>，之后将Vue作为参数传给 initGlobalAPI ，最后又在 <code>Vue.prototype</code> 上挂载了 <code>$isServer</code> ，在 <code>Vue</code>上挂载了 <code>version</code> 属性。<br><code>initGlobalAPI</code> 的作用是在 <code>Vue</code> 构造函数上挂载静态属性和方法，<code>Vue</code> 在经过 <code>initGlobalAPI</code> 之后，会变成这样：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">// src/core/index.js / src/core/global-api/index.js</span></div><div class="line">Vue.config</div><div class="line">Vue.util = util</div><div class="line">Vue.set = set</div><div class="line">Vue.delete = del</div><div class="line">Vue.nextTick = util.nextTick</div><div class="line">Vue.options = &#123;</div><div class="line">    components: &#123;</div><div class="line">        KeepAlive</div><div class="line">    &#125;,</div><div class="line">    directives: &#123;&#125;,</div><div class="line">    filters: &#123;&#125;,</div><div class="line">    _base: Vue</div><div class="line">&#125;</div><div class="line">Vue.use</div><div class="line">Vue.mixin</div><div class="line">Vue.cid = <span class="number">0</span></div><div class="line">Vue.extend</div><div class="line">Vue.component = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line">Vue.directive = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line">Vue.filter = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line"></div><div class="line">Vue.prototype.$isServer</div><div class="line">Vue.version = <span class="string">'__VERSION__'</span></div></pre></td></tr></table></figure></p><p>其中，稍微复杂一点的就是 <code>Vue.options</code>，大家稍微分析分析就会知道他的确长成那个样子。下一个就是 <code>web-runtime.js</code> 文件了，<code>web-runtime.js</code> 文件主要做了三件事儿：</p><ol><li>覆盖 <code>Vue.config</code> 的属性，将其设置为平台特有的一些方法</li><li><code>Vue.options.directives</code> 和 <code>Vue.options.components</code> 安装平台特有的指令和组件</li><li>在 <code>Vue.prototype</code> 上定义 <code>__patch__</code> 和 <code>$mount</code></li></ol><p>经过 <code>web-runtime.js</code> 文件之后，<code>Vue</code> 变成下面这个样子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">// 安装平台特定的utils</span></div><div class="line">Vue.config.isUnknownElement = isUnknownElement</div><div class="line">Vue.config.isReservedTag = isReservedTag</div><div class="line">Vue.config.getTagNamespace = getTagNamespace</div><div class="line">Vue.config.mustUseProp = mustUseProp</div><div class="line"><span class="comment">// 安装平台特定的 指令 和 组件</span></div><div class="line">Vue.options = &#123;</div><div class="line">    components: &#123;</div><div class="line">        KeepAlive,</div><div class="line">        Transition,</div><div class="line">        TransitionGroup</div><div class="line">    &#125;,</div><div class="line">    directives: &#123;</div><div class="line">        model,</div><div class="line">        show</div><div class="line">    &#125;,</div><div class="line">    filters: &#123;&#125;,</div><div class="line">    _base: Vue</div><div class="line">&#125;</div><div class="line">Vue.prototype.__patch__</div><div class="line">Vue.prototype.$mount</div></pre></td></tr></table></figure></p><p>这里大家要注意的是 <code>Vue.options</code> 的变化。另外这里的 <code>$mount</code> 方法很简单：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">Vue.prototype.$mount = <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></div><div class="line"><span class="function"><span class="params">  el?: string | Element,</span></span></div><div class="line"><span class="function"><span class="params">  hydrating?: boolean</span></span></div><div class="line"><span class="function"><span class="params"></span>): <span class="title">Component</span> </span>&#123;</div><div class="line">  el = el &amp;&amp; inBrowser ? query(el) : <span class="literal">undefined</span></div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>._mount(el, hydrating)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>首先根据是否是浏览器环境决定要不要 <code>query(el)</code> 获取元素，然后将 <code>el</code> 作为参数传递给 <code>this._mount()</code>。<br>最后一个处理 <code>Vue</code> 的文件就是入口文件 <code>web-runtime-with-compiler.js</code> 了，该文件做了两件事：</p><ol><li>缓存来自 <code>web-runtime.js</code> 文件的 <code>$mount</code> 函数 <code>const mount = Vue.prototype.$mount</code> 然后覆盖覆盖了 Vue.prototype.$mount</li><li>在 <code>Vue</code> 上挂载 <code>compile</code>   <code>Vue.compile = compileToFunctions</code> ,  <code>compileToFunctions</code> 函数的作用，就是将模板 <code>template</code> 编译为<code>render</code>函数。</li></ol><p>至此，我们算是还原了 Vue 构造函数，总结一下：</p><ol><li><code>Vue.prototype</code> 下的属性和方法的挂载主要是在 <code>src/core/instance</code> 目录中的代码处理的</li><li><code>Vue</code> 下的静态属性和方法的挂载主要是在 <code>src/core/global-api</code> 目录下的代码处理的</li><li><code>web-runtime.js</code> 主要是添加web平台特有的配置、组件和指令，<code>web-runtime-with-compiler.js</code> 给<code>Vue</code>的 <code>$mount</code> 方法添加 <code>compiler</code> 编译器，支持 <code>template</code>。</li></ol><h1 id="一个贯穿始终的例子"><a href="#一个贯穿始终的例子" class="headerlink" title="一个贯穿始终的例子"></a>一个贯穿始终的例子</h1><p>在了解了 <code>Vue</code> 构造函数的设计之后，接下来，我们一个贯穿始终的例子就要登场了，掌声有请：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">let</span> v = <span class="keyword">new</span> Vue(&#123;</div><div class="line">el: <span class="string">'#app'</span>,</div><div class="line">data: &#123;</div><div class="line">a: <span class="number">1</span>,</div><div class="line">b: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div><div class="line">&#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p><p>好吧，我承认这段代码你家没满月的孩子都会写了。这段代码就是我们贯穿始终的例子，它就是这篇文章的主线，在后续的讲解中，都会以这段代码为例，当讲到必要的地方，会为其添加选项，比如讲计算属性的时候当然要加上一个 <code>computed</code> 属性了。不过在最开始，我只传递了两个选项 <code>el</code> 以及 <code>data</code>，“我们看看接下来会发生什么，让我们拭目以待“ —- NBA球星在接受采访时最喜欢说这句话。<br><em>当我们按照例子那样编码使用Vue的时候，Vue都做了什么？</em><br>想要知道Vue都干了什么，我们就要找到 Vue 初始化程序，查看 Vue 构造函数：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Vue</span> (<span class="params">options</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp;</div><div class="line">    !(<span class="keyword">this</span> <span class="keyword">instanceof</span> Vue)) &#123;</div><div class="line">    warn(<span class="string">'Vue is a constructor and should be called with the `new` keyword'</span>)</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">this</span>._init(options)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>我们发现，<code>_init()</code> 方法就是<code>Vue</code>调用的第一个方法，然后将我们的参数 <code>options</code> 透传了过去。在调用 <code>_init()</code> 之前，还做了一个安全模式的处理，告诉开发者必须使用 <code>new</code> 操作符调用 <code>Vue</code>。根据之前我们的整理，<code>_init()</code> 方法应该是在 <code>src/core/instance/init.js</code> 文件中定义的，我们打开这个文件查看 <code>_init()</code> 方法：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">Vue.prototype._init = <span class="function"><span class="keyword">function</span> (<span class="params">options?: Object</span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> vm: Component = <span class="keyword">this</span></div><div class="line">  <span class="comment">// a uid</span></div><div class="line">  vm._uid = uid++</div><div class="line">  <span class="comment">// a flag to avoid this being observed</span></div><div class="line">  vm._isVue = <span class="literal">true</span></div><div class="line">  <span class="comment">// merge options</span></div><div class="line">  <span class="keyword">if</span> (options &amp;&amp; options._isComponent) &#123;</div><div class="line">    <span class="comment">// optimize internal component instantiation</span></div><div class="line">    <span class="comment">// since dynamic options merging is pretty slow, and none of the</span></div><div class="line">    <span class="comment">// internal component options needs special treatment.</span></div><div class="line">    initInternalComponent(vm, options)</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    vm.$options = mergeOptions(</div><div class="line">      resolveConstructorOptions(vm.constructor),</div><div class="line">      options || &#123;&#125;,</div><div class="line">      vm</div><div class="line">    )</div><div class="line">  &#125;</div><div class="line">  <span class="comment">/* istanbul ignore else */</span></div><div class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</div><div class="line">    initProxy(vm)</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    vm._renderProxy = vm</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// expose real self</span></div><div class="line">  vm._self = vm</div><div class="line">  initLifecycle(vm)</div><div class="line">  initEvents(vm)</div><div class="line">  callHook(vm, <span class="string">'beforeCreate'</span>)</div><div class="line">  initState(vm)</div><div class="line">  callHook(vm, <span class="string">'created'</span>)</div><div class="line">  initRender(vm)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><code>_init()</code> 方法在一开始的时候，在 <code>this</code> 对象上定义了两个属性：<code>_uid</code> 和 <code>_isVue</code>，然后判断有没有定义 <code>options._isComponent</code>，在使用 V<code>ue</code> 开发项目的时候，我们是不会使用 <code>_isComponent</code> 选项的，这个选项是 <code>Vue</code> 内部使用的，按照本节开头的例子，这里会走 <code>else</code> 分支，也就是这段代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">vm.$options = mergeOptions(</div><div class="line">  resolveConstructorOptions(vm.constructor),</div><div class="line">  options || &#123;&#125;,</div><div class="line">  vm</div><div class="line">)</div></pre></td></tr></table></figure></p><p>这样 <code>Vue</code> 第一步所做的事情就来了：<em><span style="color: red">使用策略对象合并参数选项</span></em><br>可以发现，<code>Vue</code>使用 <code>mergeOptions</code> 来处理我们调用Vue时传入的参数选项(options)，然后将返回值赋值给 <code>this.$options (vm === this)</code>，传给 <code>mergeOptions</code> 方法三个参数，我们分别来看一看，首先是：<code>resolveConstructorOptions(vm.constructor)</code>，我们查看一下这个方法：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">resolveConstructorOptions</span> (<span class="params">Ctor: Class&lt;Component&gt;</span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> options = Ctor.options</div><div class="line">  <span class="keyword">if</span> (Ctor.super) &#123;</div><div class="line">    <span class="keyword">const</span> superOptions = Ctor.super.options</div><div class="line">    <span class="keyword">const</span> cachedSuperOptions = Ctor.superOptions</div><div class="line">    <span class="keyword">const</span> extendOptions = Ctor.extendOptions</div><div class="line">    <span class="keyword">if</span> (superOptions !== cachedSuperOptions) &#123;</div><div class="line">      <span class="comment">// super option changed</span></div><div class="line">      Ctor.superOptions = superOptions</div><div class="line">      extendOptions.render = options.render</div><div class="line">      extendOptions.staticRenderFns = options.staticRenderFns</div><div class="line">      extendOptions._scopeId = options._scopeId</div><div class="line">      options = Ctor.options = mergeOptions(superOptions, extendOptions)</div><div class="line">      <span class="keyword">if</span> (options.name) &#123;</div><div class="line">        options.components[options.name] = Ctor</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> options</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这个方法接收一个参数 <code>Ctor</code>，通过传入的 <code>vm.constructor</code> 我们可以知道，其实就是 <code>Vue</code> 构造函数本身。所以下面这句代码：<code>let options = Ctor.options</code>, 相当于：<code>let options = Vue.options</code></p><p>大家还记得 <code>Vue.options</code> 吗？在寻找Vue构造函数一节里，我们整理了 <code>Vue.options</code> 应该长成下面这个样子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Vue.options = &#123;</div><div class="line">    components: &#123;</div><div class="line">        KeepAlive,</div><div class="line">        Transition,</div><div class="line">        TransitionGroup</div><div class="line">    &#125;,</div><div class="line">    directives: &#123;</div><div class="line">        model,</div><div class="line">        show</div><div class="line">    &#125;,</div><div class="line">    filters: &#123;&#125;,</div><div class="line">    _base: Vue</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>之后判断是否定义了 <code>Vue.super</code> ，这个是用来处理继承的，我们后续再讲，在本例中，<code>resolveConstructorOption</code>s 方法直接返回了 <code>Vue.options</code>。也就是说，传递给 <code>mergeOptions</code> 方法的第一个参数就是 <code>Vue.options</code>。<br>传给 <code>mergeOptions</code> 方法的第二个参数是我们调用<code>Vue</code>构造函数时的参数选项，第三个参数是 <code>vm</code> 也就是 <code>this</code> 对象，按照本节开头的例子那样使用 <code>Vue</code>，最终运行的代码应该如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">vm.$options = mergeOptions(</div><div class="line"> <span class="comment">// Vue.options</span></div><div class="line">   &#123;</div><div class="line">    components: &#123;</div><div class="line">        KeepAlive,</div><div class="line">        Transition,</div><div class="line">        TransitionGroup</div><div class="line">    &#125;,</div><div class="line">    directives: &#123;</div><div class="line">        model,</div><div class="line">        show</div><div class="line">    &#125;,</div><div class="line">    filters: &#123;&#125;,</div><div class="line">    _base: Vue</div><div class="line">&#125;,</div><div class="line"><span class="comment">// 调用Vue构造函数时传入的参数选项 options</span></div><div class="line">   &#123;</div><div class="line">   el: <span class="string">'#app'</span>,</div><div class="line">data: &#123;</div><div class="line">a: <span class="number">1</span>,</div><div class="line">b: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div><div class="line">&#125;</div><div class="line">   &#125;,</div><div class="line">   <span class="comment">// this</span></div><div class="line">   vm</div><div class="line"> )</div></pre></td></tr></table></figure></p><p>了解了这些，我们就可以看看 <code>mergeOptions</code> 到底做了些什么了，根据引用寻找到 <code>mergeOptions</code> 应该是在 <code>src/core/util/options.js</code> 文件中定义的。这个文件第一次看可能会头大，下面是我处理后的简略展示，大家看上去应该更容易理解了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">// 1、引用依赖</div><div class="line">import Vue from &apos;../instance/index&apos;</div><div class="line">其他引用...</div><div class="line"></div><div class="line">// 2、合并父子选项值为最终值的策略对象，此时 strats 是一个空对象，因为 config.optionMergeStrategies = Object.create(null)</div><div class="line">const strats = config.optionMergeStrategies</div><div class="line">// 3、在 strats 对象上定义与参数选项名称相同的方法</div><div class="line">strats.el = </div><div class="line">strats.propsData = function (parent, child, vm, key)&#123;&#125;</div><div class="line">strats.data = function (parentVal, childVal, vm)</div><div class="line"></div><div class="line">config._lifecycleHooks.forEach(hook =&gt; &#123;</div><div class="line">  strats[hook] = mergeHook</div><div class="line">&#125;)</div><div class="line"></div><div class="line">config._assetTypes.forEach(function (type) &#123;</div><div class="line">  strats[type + &apos;s&apos;] = mergeAssets</div><div class="line">&#125;)</div><div class="line"></div><div class="line">strats.watch = function (parentVal, childVal)</div><div class="line"></div><div class="line">strats.props =</div><div class="line">strats.methods =</div><div class="line">strats.computed = function (parentVal: ?Object, childVal: ?Object)</div><div class="line">// 默认的合并策略，如果有 `childVal` 则返回 `childVal` 没有则返回 `parentVal`</div><div class="line">const defaultStrat = function (parentVal: any, childVal: any): any &#123;</div><div class="line">  return childVal === undefined</div><div class="line">    ? parentVal</div><div class="line">    : childVal</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 4、mergeOptions 中根据参数选项调用同名的策略方法进行合并处理</div><div class="line">export function mergeOptions (</div><div class="line">  parent: Object,</div><div class="line">  child: Object,</div><div class="line">  vm?: Component</div><div class="line">): Object &#123;</div><div class="line"></div><div class="line">  // 其他代码</div><div class="line">  ...</div><div class="line"></div><div class="line">  const options = &#123;&#125;</div><div class="line">  let key</div><div class="line">  for (key in parent) &#123;</div><div class="line">    mergeField(key)</div><div class="line">  &#125;</div><div class="line">  for (key in child) &#123;</div><div class="line">    if (!hasOwn(parent, key)) &#123;</div><div class="line">      mergeField(key)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  function mergeField (key) &#123;</div><div class="line">    const strat = strats[key] || defaultStrat</div><div class="line">    options[key] = strat(parent[key], child[key], vm, key)</div><div class="line">  &#125;</div><div class="line">  return options</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>上面的代码中，我省略了一些工具函数，例如 <code>mergeHook</code> 和 <code>mergeAssets</code> 等等，唯一需要注意的是这段代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">config._lifecycleHooks.forEach(<span class="function"><span class="params">hook</span> =&gt;</span> &#123;</div><div class="line">  strats[hook] = mergeHook</div><div class="line">&#125;)</div><div class="line"></div><div class="line">config._assetTypes.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">type</span>) </span>&#123;</div><div class="line">  strats[type + <span class="string">'s'</span>] = mergeAssets</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p><p><code>config</code> 对象引用自<code>src/core/config.js</code> 文件，最终的结果就是在 <code>strats</code> 下添加了相应的生命周期选项的合并策略函数为 <code>mergeHook</code>，添加指令(<code>directives</code>)、组件(<code>components</code>)、过滤器(<code>filters</code>)等选项的合并策略函数为 <code>mergeAssets</code>。<br>这样看来就清晰多了，拿我们贯穿本文的例子来说：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">let v = new Vue(&#123;</div><div class="line">el: &apos;#app&apos;,</div><div class="line">data: &#123;</div><div class="line">a: 1,</div><div class="line">b: [1, 2, 3]</div><div class="line">&#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p><p>其中 <code>el</code> 选项会使用 <code>defaultStrat</code> 默认策略函数处理，<code>data</code> 选项则会使用 <code>strats.data</code> 策略函数处理，并且根据 <code>strats.data</code> 中的逻辑，<code>strats.data</code> 方法最终会返回一个函数：<code>mergedInstanceDataFn</code>。<br>这里就不详细的讲解每一个策略函数的内容了，后续都会讲到，这里我们还是抓住主线理清思路为主，只需要知道Vue在处理选项的时候，使用了一个策略对象对父子选项进行合并。并将最终的值赋值给实例下的 <code>$options</code> 属性即：<code>this.$options</code>，那么我们继续查看 <code>_init()</code> 方法在合并完选项之后，又做了什么：<br>合并完选项之后，<code>Vue</code> 第二部做的事情就来了：初始化工作与<code>Vue</code>实例对象的设计<br>前面讲了 <code>Vue</code> 构造函数的设计，并且整理了 Vue原型属性与方法 和 Vue静态属性与方法，而 Vue 实例对象就是通过构造函数创造出来的，让我们来看一看 Vue 实例对象是如何设计的，下面的代码是 <code>_init()</code> 方法合并完选项之后的代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/* istanbul ignore else */</span></div><div class="line">   <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</div><div class="line">     initProxy(vm)</div><div class="line">   &#125; <span class="keyword">else</span> &#123;</div><div class="line">     vm._renderProxy = vm</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="comment">// expose real self</span></div><div class="line">vm._self = vm</div><div class="line">   initLifecycle(vm)</div><div class="line">   initEvents(vm)</div><div class="line">   callHook(vm, <span class="string">'beforeCreate'</span>)</div><div class="line">   initState(vm)</div><div class="line">   callHook(vm, <span class="string">'created'</span>)</div><div class="line">   initRender(vm)</div></pre></td></tr></table></figure></p><p>根据上面的代码，在生产环境下会为实例添加两个属性，并且属性值都为实例本身：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">vm._renderProxy = vm</div><div class="line">vm._self = vm</div></pre></td></tr></table></figure></p><p>然后，调用了四个 <code>init*</code> 方法分别为：<code>initLifecycle</code>、<code>initEvents</code>、<code>initState</code>、<code>initRender</code>，且在 <code>initState</code> 前后分别回调了生命周期钩子 <code>beforeCreate</code> 和 <code>created</code>，而 <code>initRender</code> 是在 <code>created</code> 钩子执行之后执行的，看到这里，也就明白了为什么 <code>created</code> 的时候不能操作DOM了。因为这个时候还没有渲染真正的DOM元素到文档中。<code>created</code> 仅仅代表数据状态的初始化完成。<br>根据四个 <code>init*</code> 方法的引用关系打开对应的文件查看对应的方法，我们发现，这些方法是在处理Vue实例对象，以及做一些初始化的工作，类似整理Vue构造函数一样，我同样针对Vue实例做了属性和方法的整理，如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">// 在 Vue.prototype._init 中添加的属性 **********************************************************</span></div><div class="line"><span class="keyword">this</span>._uid = uid++</div><div class="line"><span class="keyword">this</span>._isVue = <span class="literal">true</span></div><div class="line"><span class="keyword">this</span>.$options = &#123;</div><div class="line">    components,</div><div class="line">    directives,</div><div class="line">    filters,</div><div class="line">    _base,</div><div class="line">    el,</div><div class="line">    data: mergedInstanceDataFn()</div><div class="line">&#125;</div><div class="line"><span class="keyword">this</span>._renderProxy = <span class="keyword">this</span></div><div class="line"><span class="keyword">this</span>._self = <span class="keyword">this</span></div><div class="line"></div><div class="line"><span class="comment">// 在 initLifecycle 中添加的属性**********************************************************</span></div><div class="line"><span class="keyword">this</span>.$parent = parent</div><div class="line"><span class="keyword">this</span>.$root = parent ? parent.$root : <span class="keyword">this</span></div><div class="line"> </div><div class="line"><span class="keyword">this</span>.$children = []</div><div class="line"><span class="keyword">this</span>.$refs = &#123;&#125;</div><div class="line"></div><div class="line"><span class="keyword">this</span>._watcher = <span class="literal">null</span></div><div class="line"><span class="keyword">this</span>._inactive = <span class="literal">false</span></div><div class="line"><span class="keyword">this</span>._isMounted = <span class="literal">false</span></div><div class="line"><span class="keyword">this</span>._isDestroyed = <span class="literal">false</span></div><div class="line"><span class="keyword">this</span>._isBeingDestroyed = <span class="literal">false</span></div><div class="line"></div><div class="line"><span class="comment">// 在 initEvents 中添加的属性 **********************************************************</span></div><div class="line"><span class="keyword">this</span>._events = &#123;&#125;</div><div class="line"><span class="keyword">this</span>._updateListeners = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="comment">// 在 initState 中添加的属性**********************************************************</span></div><div class="line"><span class="keyword">this</span>._watchers = []</div><div class="line">    <span class="comment">// initData</span></div><div class="line">    <span class="keyword">this</span>._data</div><div class="line"></div><div class="line"><span class="comment">// 在 initRender 中添加的属性 **********************************************************</span></div><div class="line"><span class="keyword">this</span>.$vnode = <span class="literal">null</span> <span class="comment">// the placeholder node in parent tree</span></div><div class="line"><span class="keyword">this</span>._vnode = <span class="literal">null</span> <span class="comment">// the root of the child tree</span></div><div class="line"><span class="keyword">this</span>._staticTrees = <span class="literal">null</span></div><div class="line"><span class="keyword">this</span>.$slots</div><div class="line"><span class="keyword">this</span>.$scopedSlots</div><div class="line"><span class="keyword">this</span>._c</div><div class="line"><span class="keyword">this</span>.$createElement</div></pre></td></tr></table></figure></p><p>以上就是一个Vue实例所包含的属性和方法，除此之外要注意的是，在 <code>initEvents</code> 中除了添加属性之外，如果有 <code>vm.$options._parentListeners</code> 还要调用 <code>vm._updateListeners()</code> 方法，在 <code>initState</code> 中又调用了一些其他<code>init</code>方法，如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initState</span> (<span class="params">vm: Component</span>) </span>&#123;</div><div class="line">  vm._watchers = []</div><div class="line">  initProps(vm)</div><div class="line">  initMethods(vm)</div><div class="line">  initData(vm)</div><div class="line">  initComputed(vm)</div><div class="line">  initWatch(vm)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>最后在 <code>initRender</code> 中如果有 <code>vm.$options.el</code> 还要调用 <code>vm.$mount(vm.$options.el)</code>，如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (vm.$options.el) &#123;</div><div class="line">  vm.$mount(vm.$options.el)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这就是为什么如果不传递 <code>el</code> 选项就需要手动 <code>mount</code> 的原因了。<br>那么我们依照我们本节开头的的例子，以及初始化的先后顺序来逐一看一看都发生了什么。我们将 <code>initState</code> 中的 <code>init*</code> 方法展开来看，执行顺序应该是这样的（从上到下的顺序执行）：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">initLifecycle(vm)</div><div class="line">initEvents(vm)</div><div class="line">callHook(vm, <span class="string">'beforeCreate'</span>)</div><div class="line">initProps(vm)</div><div class="line">initMethods(vm)</div><div class="line">initData(vm)</div><div class="line">initComputed(vm)</div><div class="line">initWatch(vm)</div><div class="line">callHook(vm, <span class="string">'created'</span>)</div><div class="line">initRender(vm)</div></pre></td></tr></table></figure></p><p>首先是 <code>initLifecycle</code>，这个函数的作用就是在实例上添加一些属性，然后是 <code>initEvents</code>，由于 <code>vm.$options._parentListeners</code> 的值为 <code>undefined</code> 所以也仅仅是在实例上添加属性， <code>vm._updateListeners(listeners)</code> 并不会执行，由于我们只传递了 <code>el</code> 和 <code>data</code>，所以 <code>initProps</code>、<code>initMethods</code>、<code>initComputed</code>、<code>initWatch</code> 这四个方法什么都不会做，只有 <code>initData</code> 会执行。最后是 <code>initRender</code>，除了在实例上添加一些属性外，由于我们传递了 <code>el</code> 选项，所以会执行 <code>vm.$mount(vm.$options.el)</code>。<br>综上所述：按照我们的例子那样写，初始化工作只包含两个主要内容即：<code>initData</code> 和 <code>initRender</code>。</p><h1 id="通过initData看Vue的数据响应系统"><a href="#通过initData看Vue的数据响应系统" class="headerlink" title="通过initData看Vue的数据响应系统"></a>通过initData看Vue的数据响应系统</h1><p>Vue的数据响应系统包含三个部分：<code>Observer</code>、<code>Dep</code>、<code>Watcher</code>。关于数据响应系统的内容真的已经被文章讲烂了，所以我就简单的说一下，力求大家能理解就ok，我们还是先看一下 <code>initData</code> 中的代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">initData</span> (<span class="params">vm: Component</span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> data = vm.$options.data</div><div class="line">  data = vm._data = <span class="keyword">typeof</span> data === <span class="string">'function'</span></div><div class="line">    ? data.call(vm)</div><div class="line">    : data || &#123;&#125;</div><div class="line">  <span class="keyword">if</span> (!isPlainObject(data)) &#123;</div><div class="line">    data = &#123;&#125;</div><div class="line">    process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; warn(</div><div class="line">      <span class="string">'data functions should return an object:\n'</span> +</div><div class="line">      <span class="string">'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function'</span>,</div><div class="line">      vm</div><div class="line">    )</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// proxy data on instance</span></div><div class="line">  <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(data)</div><div class="line">  <span class="keyword">const</span> props = vm.$options.props</div><div class="line">  <span class="keyword">let</span> i = keys.length</div><div class="line">  <span class="keyword">while</span> (i--) &#123;</div><div class="line">    <span class="keyword">if</span> (props &amp;&amp; hasOwn(props, keys[i])) &#123;</div><div class="line">      process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; warn(</div><div class="line">        <span class="string">`The data property "<span class="subst">$&#123;keys[i]&#125;</span>" is already declared as a prop. `</span> +</div><div class="line">        <span class="string">`Use prop default value instead.`</span>,</div><div class="line">        vm</div><div class="line">      )</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      proxy(vm, keys[i])</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// observe data</span></div><div class="line">  observe(data)</div><div class="line">  data.__ob__ &amp;&amp; data.__ob__.vmCount++</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>首先，先拿到 <code>data</code> 数据：<code>let data = vm.$options.data</code>，大家还记得此时<code>vm.$options.data</code> 的值应该是通过 <code>mergeOptions</code> 合并处理后的 <code>mergedInstanceDataFn</code> 函数吗？所以在得到 <code>data</code> 后，它又判断了 <code>data</code> 的数据类型是不是 ‘function’，最终的结果是：<code>data</code> 还是我们传入的数据选项的 <code>data</code>，即：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">data: &#123;</div><div class="line">a: <span class="number">1</span>,</div><div class="line">b: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>然后在实例对象上定义 <code>_data</code> 属性，该属性与 <code>data</code> 是相同的引用。<br>然后是一个 <code>while</code> 循环，循环的目的是在实例对象上对数据进行代理，这样我们就能通过 <code>this.a</code> 来访问 <code>data.a</code> 了，代码的处理是在 <code>proxy</code> 函数中，该函数非常简单，仅仅是在实例对象上设置与 <code>data</code> 属性同名的访问器属性，然后使用 <code>_data</code> 做数据劫持，如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">proxy</span> (<span class="params">vm: Component, key: string</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (!isReserved(key)) &#123;</div><div class="line">    <span class="built_in">Object</span>.defineProperty(vm, key, &#123;</div><div class="line">      configurable: <span class="literal">true</span>,</div><div class="line">      enumerable: <span class="literal">true</span>,</div><div class="line">      get: <span class="function"><span class="keyword">function</span> <span class="title">proxyGetter</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> vm._data[key]</div><div class="line">      &#125;,</div><div class="line">      set: <span class="function"><span class="keyword">function</span> <span class="title">proxySetter</span> (<span class="params">val</span>) </span>&#123;</div><div class="line">        vm._data[key] = val</div><div class="line">      &#125;</div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>做完数据的代理，就正式进入响应系统，<code>**observe(data)**</code></p><p>我们说过，数据响应系统主要包含三部分：<code>Observer</code>、<code>Dep</code>、<code>Watcher</code>，代码分别存放在：<code>observer/index.js</code>、<code>observer/dep.js</code> 以及 <code>observer/watcher.js</code> 文件中，这回我们换一种方式，我们先不看其源码，大家先跟着我的思路来思考，最后回头再去看代码，你会有一种：”奥，不过如此“的感觉。<br>假如，我们有如下代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> data = &#123;</div><div class="line">    a: <span class="number">1</span>,</div><div class="line">    b: &#123;</div><div class="line">        c: <span class="number">2</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">observer(data)</div><div class="line"></div><div class="line"><span class="keyword">new</span> Watch(<span class="string">'a'</span>, () =&gt; &#123;</div><div class="line">    alert(<span class="number">9</span>)</div><div class="line">&#125;)</div><div class="line"><span class="keyword">new</span> Watch(<span class="string">'a'</span>, () =&gt; &#123;</div><div class="line">    alert(<span class="number">90</span>)</div><div class="line">&#125;)</div><div class="line"><span class="keyword">new</span> Watch(<span class="string">'b.c'</span>, () =&gt; &#123;</div><div class="line">    alert(<span class="number">80</span>)</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p><p>这段代码目的是，首先定义一个数据对象 <code>data</code>，然后通过 <code>observer</code> 对其进行观测，之后定义了三个观察者，当数据有变化时，执行相应的方法，这个功能使用Vue的实现原来要如何去实现？其实就是在问 <code>observer</code> 怎么写？<code>Watch</code> 构造函数又怎么写？接下来我们逐一实现。<br>首先，<code>observer</code> 的作用是：将数据对象<code>data</code>的属性转换为访问器属性：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span> (data) &#123;</div><div class="line">        <span class="keyword">this</span>.walk(data)</div><div class="line">    &#125;</div><div class="line">    walk (data) &#123;</div><div class="line">        <span class="comment">// 遍历 data 对象属性，调用 defineReactive 方法</span></div><div class="line">        <span class="keyword">let</span> keys = <span class="built_in">Object</span>.keys(data)</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keys.length; i++)&#123;</div><div class="line">            defineReactive(data, keys[i], data[keys[i]])</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// defineReactive方法仅仅将data的属性转换为访问器属性</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span> (<span class="params">data, key, val</span>) </span>&#123;</div><div class="line"><span class="comment">// 递归观测子属性</span></div><div class="line">    observer(val)</div><div class="line"></div><div class="line">    <span class="built_in">Object</span>.defineProperty(data, key, &#123;</div><div class="line">        enumerable: <span class="literal">true</span>,</div><div class="line">        configurable: <span class="literal">true</span>,</div><div class="line">        get: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> val</div><div class="line">        &#125;,</div><div class="line">        set: <span class="function"><span class="keyword">function</span> (<span class="params">newVal</span>) </span>&#123;</div><div class="line">            <span class="keyword">if</span>(val === newVal)&#123;</div><div class="line">                <span class="keyword">return</span></div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 对新值进行观测</span></div><div class="line">            observer(newVal)</div><div class="line">        &#125;</div><div class="line">    &#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// observer 方法首先判断data是不是纯JavaScript对象，如果是，调用 Observer 类进行观测</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">observer</span> (<span class="params">data</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="built_in">Object</span>.prototype.toString.call(data) !== <span class="string">'[object Object]'</span>) &#123;</div><div class="line">        <span class="keyword">return</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">new</span> Observer(data)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>上面的代码中，我们定义了 <code>observer</code> 方法，该方法检测了数据<code>data</code>是不是纯<code>JavaScript</code>对象，如果是就调用 <code>Observer</code> 类，并将 <code>data</code> 作为参数透传。在 <code>Observer</code> 类中，我们使用 <code>walk</code> 方法对数据<code>data</code>的属性循环调用 <code>defineReactive</code> 方法，<code>defineReactive</code> 方法很简单，仅仅是将数据<code>data</code>的属性转为访问器属性，并对数据进行递归观测，否则只能观测数据data的直属子属性。这样我们的第一步工作就完成了，当我们修改或者获取data属性值的时候，通过 <code>get</code> 和 <code>set</code> 即能获取到通知。<br>我们继续往下看，来看一下 <code>Watch</code>：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> Watch(<span class="string">'a'</span>, () =&gt; &#123;</div><div class="line">    alert(<span class="number">9</span>)</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p><p>现在的问题是，<code>Watch</code> 要怎么和 <code>observer</code> 关联？？？？？？？我们看看 <code>Watch</code> 它知道些什么，通过上面调用 <code>Watch</code> 的方式，传递给 <code>Watch</code> 两个参数，一个是 ‘a’ 我们可以称其为表达式，另外一个是回调函数。所以我们目前只能写出这样的代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watch</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span> (exp, fn) &#123;</div><div class="line">        <span class="keyword">this</span>.exp = exp</div><div class="line">        <span class="keyword">this</span>.fn = fn</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>那么要怎么关联呢，大家看下面的代码会发生什么：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watch</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span> (exp, fn) &#123;</div><div class="line">        <span class="keyword">this</span>.exp = exp</div><div class="line">        <span class="keyword">this</span>.fn = fn</div><div class="line">        data[exp]</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>多了一句 <code>data[exp]</code>，这句话是在干什么？是不是在获取 <code>data</code> 下某个属性的值，比如 <code>exp</code> 为 ‘a’ 的话，那么 <code>data[exp]</code> 就相当于在获取 <code>data.a</code>的值，那这会放生什么？大家不要忘了，此时数据 <code>data</code> 下的属性已经是访问器属性了，所以这么做的结果会直接触发对应属性的 <code>get</code> 函数，这样我们就成功的和 <code>observer</code> 产生了关联，但这样还不够，我们还是没有达到目的，不过我们已经无限接近了，我们继续思考看一下可不可以这样：</p><blockquote><p>既然在 <code>Watch</code> 中对表达式求值，能够触发 <code>observer</code> 的 <code>get</code>，那么可不可以在 <code>get</code> 中收集 <code>Watch</code> 中函数呢？<br>答案是可以的，不过这个时候我们就需要 <code>Dep</code> 出场了，它是一个依赖收集器。我们的思路是：<code>data</code> 下的每一个属性都有一个唯一的 <code>Dep</code> 对象，在 <code>get</code> 中收集仅针对该属性的依赖，然后在 <code>set</code> 方法中触发所有收集的依赖，这样就搞定了，看如下代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span> () &#123;</div><div class="line">        <span class="keyword">this</span>.subs = []</div><div class="line">    &#125;</div><div class="line">    addSub () &#123;</div><div class="line">        <span class="keyword">this</span>.subs.push(Dep.target)</div><div class="line">    &#125;</div><div class="line">    notify () &#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.subs.length; i++)&#123;</div><div class="line">            <span class="keyword">this</span>.subs[i].fn()</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">Dep.target = <span class="literal">null</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">pushTarget</span>(<span class="params">watch</span>)</span>&#123;</div><div class="line">    Dep.target = watch</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watch</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span> (exp, fn) &#123;</div><div class="line">        <span class="keyword">this</span>.exp = exp</div><div class="line">        <span class="keyword">this</span>.fn = fn</div><div class="line">        pushTarget(<span class="keyword">this</span>)</div><div class="line">        data[exp]</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p></blockquote><p>上面的代码中，我们在 <code>Watch</code> 中增加了<code>pushTarget(this)</code>，可以发现，这句代码的作用是将 <code>Dep.target</code> 的值设置为该<code>Watch</code>对象。在 <code>pushTarget</code> 之后我们才对表达式进行求值，接着，我们修改 <code>defineReactive</code> 代码如下<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span> (<span class="params">data, key, val</span>) </span>&#123;</div><div class="line">    observer(val)</div><div class="line">    <span class="keyword">let</span> dep = <span class="keyword">new</span> Dep()<span class="comment">// 新增</span></div><div class="line">    <span class="built_in">Object</span>.defineProperty(data, key, &#123;</div><div class="line">        enumerable: <span class="literal">true</span>,</div><div class="line">        configurable: <span class="literal">true</span>,</div><div class="line">        get: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            dep.addSub()<span class="comment">// 新增</span></div><div class="line">            <span class="keyword">return</span> val</div><div class="line">        &#125;,</div><div class="line">        set: <span class="function"><span class="keyword">function</span> (<span class="params">newVal</span>) </span>&#123;</div><div class="line">            <span class="keyword">if</span>(val === newVal)&#123;</div><div class="line">                <span class="keyword">return</span></div><div class="line">            &#125;</div><div class="line">            observer(newVal)</div><div class="line">            dep.notify()<span class="comment">// 新增</span></div><div class="line">        &#125;</div><div class="line">    &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>如标注，新增了三句代码，我们知道，<code>Watch</code> 中对表达式求值会触发 <code>get</code> 方法，我们在 <code>get</code> 方法中调用了 <code>dep.addSub</code>，也就执行了这句代码：<code>this.subs.push(Dep.target)</code>，由于在这句代码执行之前，<code>Dep.target</code>的值已经被设置为一个 <code>Watch</code> 对象了，所以最终结果就是收集了一个 <code>Watch</code> 对象，然后在 <code>set</code> 方法中我们调用了 <code>dep.notify</code>，所以当<code>data</code>属性值变化的时候，就会通过 <code>dep.notify</code>循环调用所有收集的<code>Watch</code>对象中的回调函数：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">notify () &#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.subs.length; i++)&#123;</div><div class="line">        <span class="keyword">this</span>.subs[i].fn()</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这样 <code>observer</code>、<code>Dep</code>、<code>Watch</code> 三者就联系成为一个有机的整体，实现了我们最初的目标，完整的代码可以戳这里：<code>observer-dep-watch</code>。这里还给大家挖了个坑，因为我们没有处理对数组的观测，由于比较复杂并且这又不是我们讨论的重点，如果大家想了解可以戳我的这篇文章：J<code>avaScript</code>实现MVVM之我就是想监测一个普通对象的变化，另外，在 <code>Watch</code> 中对表达式求值的时候也只做了直接子属性的求值，所以如果 <code>exp</code> 的值为 ‘a.b’ 的时候，就不可以用了，Vue的做法是使用 <code>.</code> 分割表达式字符串为数组，然后遍历一下对其进行求值，大家可以查看其源码。如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Parse simple path.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">const</span> bailRE = <span class="regexp">/[^\w.$]/</span></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">parsePath</span> (<span class="params">path: string</span>): <span class="title">any</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (bailRE.test(path)) &#123;</div><div class="line">    <span class="keyword">return</span></div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">const</span> segments = path.split(<span class="string">'.'</span>)</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</div><div class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; segments.length; i++) &#123;</div><div class="line">        <span class="keyword">if</span> (!obj) <span class="keyword">return</span></div><div class="line">        obj = obj[segments[i]]</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">return</span> obj</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><code>Vue</code> 的求值代码是在 <code>src/core/util/lang.js</code> 文件中 <code>parsePath</code> 函数中实现的。总结一下Vue的依赖收集过程应该是这样的：</p><p><img src="http://7xlolm.com1.z0.glb.clouddn.com/vueimgdep.png" alt=""></p><p>实际上，<code>Vue</code>并没有直接在 <code>get</code> 中调用 <code>addSub</code>，而是调用的 <code>dep.depend</code>，目的是将当前的 <code>dep</code> 对象收集到 <code>watch</code> 对象中，如果要完整的流程，应该是这样的：（大家注意数据的每一个字段都拥有自己的 <code>dep</code> 对象和 <code>get</code> 方法。）</p><p><img src="http://7xlolm.com1.z0.glb.clouddn.com/all.png" alt=""></p><p>这样 <code>Vue</code> 就建立了一套数据响应系统，之前我们说过，按照我们的例子那样写，初始化工作只包含两个主要内容即：<code>initData</code> 和 <code>initRender</code>。现在 <code>initData</code> 我们分析完了，接下来看一看 <code>initRender</code></p><h1 id="通过initRender看Vue的-render-渲染-与-re-render-重新渲染"><a href="#通过initRender看Vue的-render-渲染-与-re-render-重新渲染" class="headerlink" title="通过initRender看Vue的 render(渲染) 与 re-render(重新渲染)"></a>通过initRender看Vue的 render(渲染) 与 re-render(重新渲染)</h1><p>在 <code>initRender</code> 方法中，因为我们的例子中传递了 <code>el</code> 选项，所以下面的代码会执行：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (vm.$options.el) &#123;</div><div class="line">  vm.$mount(vm.$options.el)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这里，调用了 <code>$mount</code> 方法，在还原Vue构造函数的时候，我们整理过所有的方法，其中 <code>$mount</code> 方法在两个地方出现过：</p><ol><li>在 <code>web-runtime.js</code> 文件中：<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Vue.prototype.$mount = <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></div><div class="line"><span class="function"><span class="params">  el?: string | Element,</span></span></div><div class="line"><span class="function"><span class="params">  hydrating?: boolean</span></span></div><div class="line"><span class="function"><span class="params"></span>): <span class="title">Component</span> </span>&#123;</div><div class="line">  el = el &amp;&amp; inBrowser ? query(el) : <span class="literal">undefined</span></div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>._mount(el, hydrating)</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ol><p>它的作用是通过 <code>el</code> 获取相应的DOM元素，然后调用<code>lifecycle.js</code> 文件中的 <code>_mount</code> 方法。</p><ol><li>在 <code>web-runtime-with-compiler.js</code> 文件中：<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">// 缓存了来自 web-runtime.js 的 $mount 方法</span></div><div class="line"><span class="keyword">const</span> mount = Vue.prototype.$mount</div><div class="line"><span class="comment">// 重写 $mount 方法</span></div><div class="line">Vue.prototype.$mount = <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></div><div class="line"><span class="function"><span class="params">  el?: string | Element,</span></span></div><div class="line"><span class="function"><span class="params">  hydrating?: boolean</span></span></div><div class="line"><span class="function"><span class="params"></span>): <span class="title">Component</span> </span>&#123;</div><div class="line">  <span class="comment">// 根据 el 获取相应的DOM元素</span></div><div class="line">  el = el &amp;&amp; query(el)</div><div class="line">  <span class="comment">// 不允许你将 el 挂载到 html 标签或者 body 标签</span></div><div class="line">  <span class="keyword">if</span> (el === <span class="built_in">document</span>.body || el === <span class="built_in">document</span>.documentElement) &#123;</div><div class="line">    process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; warn(</div><div class="line">      <span class="string">`Do not mount Vue to &lt;html&gt; or &lt;body&gt; - mount to normal elements instead.`</span></div><div class="line">    )</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> options = <span class="keyword">this</span>.$options</div><div class="line">  <span class="comment">// 如果我们没有写 render 选项，那么就尝试将 template 或者 el 转化为 render 函数</span></div><div class="line">  <span class="keyword">if</span> (!options.render) &#123;</div><div class="line">    <span class="keyword">let</span> template = options.template</div><div class="line">    <span class="keyword">if</span> (template) &#123;</div><div class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> template === <span class="string">'string'</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (template.charAt(<span class="number">0</span>) === <span class="string">'#'</span>) &#123;</div><div class="line">          template = idToTemplate(template)</div><div class="line">          <span class="comment">/* istanbul ignore if */</span></div><div class="line">          <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; !template) &#123;</div><div class="line">            warn(</div><div class="line">              <span class="string">`Template element not found or is empty: <span class="subst">$&#123;options.template&#125;</span>`</span>,</div><div class="line">              <span class="keyword">this</span></div><div class="line">            )</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (template.nodeType) &#123;</div><div class="line">        template = template.innerHTML</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</div><div class="line">          warn(<span class="string">'invalid template option:'</span> + template, <span class="keyword">this</span>)</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span></div><div class="line">      &#125;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (el) &#123;</div><div class="line">      template = getOuterHTML(el)</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (template) &#123;</div><div class="line">      <span class="keyword">const</span> &#123; render, staticRenderFns &#125; = compileToFunctions(template, &#123;</div><div class="line">        warn,</div><div class="line">        shouldDecodeNewlines,</div><div class="line">        delimiters: options.delimiters</div><div class="line">      &#125;, <span class="keyword">this</span>)</div><div class="line">      options.render = render</div><div class="line">      options.staticRenderFns = staticRenderFns</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 调用已经缓存下来的 web-runtime.js 文件中的 $mount 方法</span></div><div class="line">  <span class="keyword">return</span> mount.call(<span class="keyword">this</span>, el, hydrating)</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ol><p>分析一下可知 <code>web-runtime-with-compiler.js</code> 的逻辑如下：</p><ol><li>缓存来自 <code>web-runtime.js</code> 文件的 <code>$mount</code> 方法</li><li>判断有没有传递 <code>render</code> 选项，如果有直接调用来自 <code>web-runtime.js</code> 文件的 <code>$mount</code> 方法</li><li>如果没有传递 <code>render</code> 选项，那么查看有没有 <code>template</code> 选项，如果有就使用 <code>compileToFunctions</code> 函数根据其内容编译成 <code>render</code> 函数</li><li>如果没有 <code>template</code> 选项，那么查看有没有 <code>el</code> 选项，如果有就使用 <code>compileToFunctions</code> 函数将其内容(<code>template = getOuterHTML(el)</code>)编译成 <code>render</code> 函数</li><li>将编译成的 <code>render</code> 函数挂载到 <code>this.$options</code> 属性下，并调用缓存下来的<code>web-runtime.js</code> 文件中的 <code>$mount</code> 方法<br>简单的用一张图表示 <code>mount</code> 方法的调用关系，从上至下调用：</li></ol><p><img src="http://7xlolm.com1.z0.glb.clouddn.com/vueimgmount.png" alt=""></p><p>不过不管怎样，我们发现这些步骤的最终目的是生成 render 函数，然后再调用 <code>lifecycle.js</code> 文件中的 <code>_mount</code> 方法，我们看看这个方法做了什么事情，查看 <code>_mount</code> 方法的代码，这是简化过得：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">Vue.prototype._mount = <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></div><div class="line"><span class="function"><span class="params">  el?: Element | void,</span></span></div><div class="line"><span class="function"><span class="params">  hydrating?: boolean</span></span></div><div class="line"><span class="function"><span class="params"></span>): <span class="title">Component</span> </span>&#123;</div><div class="line">  <span class="keyword">const</span> vm: Component = <span class="keyword">this</span></div><div class="line"></div><div class="line">  <span class="comment">// 在Vue实例对象上添加 $el 属性，指向挂载点元素</span></div><div class="line">  vm.$el = el</div><div class="line"></div><div class="line">  <span class="comment">// 触发 beforeMount 生命周期钩子</span></div><div class="line">  callHook(vm, <span class="string">'beforeMount'</span>)</div><div class="line"></div><div class="line">  vm._watcher = <span class="keyword">new</span> Watcher(vm, () =&gt; &#123;</div><div class="line">    vm._update(vm._render(), hydrating)</div><div class="line">  &#125;, noop)</div><div class="line"></div><div class="line">  <span class="comment">// 如果是第一次mount则触发 mounted 生命周期钩子</span></div><div class="line">  <span class="keyword">if</span> (vm.$vnode == <span class="literal">null</span>) &#123;</div><div class="line">    vm._isMounted = <span class="literal">true</span></div><div class="line">    callHook(vm, <span class="string">'mounted'</span>)</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> vm</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>上面的代码很简单，该注释的都注释了，唯一需要看的就是这段代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">vm._watcher = <span class="keyword">new</span> Watcher(vm, () =&gt; &#123;</div><div class="line">  vm._update(vm._render(), hydrating)</div><div class="line">&#125;, noop)</div></pre></td></tr></table></figure></p><p>看上去很眼熟有没有？我们平时使用Vue都是这样使用 <code>watch</code>的：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.$watch(<span class="string">'a'</span>, (newVal, oldVal) =&gt; &#123;</div><div class="line"></div><div class="line">&#125;)</div><div class="line"><span class="comment">// 或者</span></div><div class="line"><span class="keyword">this</span>.$watch(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line"><span class="keyword">return</span> <span class="keyword">this</span>.a + <span class="keyword">this</span>.b</div><div class="line">&#125;, (newVal, oldVal) =&gt; &#123;</div><div class="line"></div><div class="line">&#125;)</div></pre></td></tr></table></figure></p><p>第一个参数是 表达式或者函数，第二个参数是回调函数，第三个参数是可选的选项。原理是 <code>Watch</code> 内部对表达式求值或者对函数求值从而触发数据的 <code>get</code> 方法收集依赖。可是<code>_mount</code> 方法中使用 <code>Watcher</code> 的时候第一个参数 <code>vm</code> 是什么鬼。我们不妨去看看源码中 <code>$watch</code> 函数是如何实现的，根据之前还原Vue构造函数中所整理的内容可知：<code>$warch</code> 方法是在 <code>src/core/instance/state.js</code>文件中的 <code>stateMixin</code> 方法中定义的，源码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">Vue.prototype.$watch = <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></div><div class="line"><span class="function"><span class="params">  expOrFn: string | Function,</span></span></div><div class="line"><span class="function"><span class="params">  cb: Function,</span></span></div><div class="line"><span class="function"><span class="params">  options?: Object</span></span></div><div class="line"><span class="function"><span class="params"></span>): <span class="title">Function</span> </span>&#123;</div><div class="line">  <span class="keyword">const</span> vm: Component = <span class="keyword">this</span></div><div class="line">  options = options || &#123;&#125;</div><div class="line">  options.user = <span class="literal">true</span></div><div class="line">  <span class="keyword">const</span> watcher = <span class="keyword">new</span> Watcher(vm, expOrFn, cb, options)</div><div class="line">  <span class="keyword">if</span> (options.immediate) &#123;</div><div class="line">    cb.call(vm, watcher.value)</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">unwatchFn</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    watcher.teardown()</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>我们可以发现，<code>$warch</code> 其实是对 <code>Watcher</code> 的一个封装，内部的 <code>Watcher</code> 的第一个参数实际上也是 <code>vm</code> 即：<code>Vue</code>实例对象，这一点我们可以在<code>Watcher</code> 的源码中得到验证，代开 <code>observer/watcher.js</code> 文件查看：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">constructor</span> (</div><div class="line">    vm: Component,</div><div class="line">    expOrFn: string | Function,</div><div class="line">    cb: Function,</div><div class="line">    options?: Object = &#123;&#125;</div><div class="line">  ) &#123;</div><div class="line">    </div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>可以发现真正的 <code>Watcher</code> 第一个参数实际上就是 <code>vm</code>。第二个参数是表达式或者函数，然后以此类推，所以现在再来看 <code>_mount</code> 中的这段代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">vm._watcher = <span class="keyword">new</span> Watcher(vm, () =&gt; &#123;</div><div class="line">  vm._update(vm._render(), hydrating)</div><div class="line">&#125;, noop)</div></pre></td></tr></table></figure></p><p>忽略第一个参数 <code>vm</code>，也就说，<code>Watcher</code> 内部应该对第二个参数求值，也就是运行这个函数：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">() =&gt; &#123;</div><div class="line">  vm._update(vm._render(), hydrating)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>所以 <code>vm._render()</code> 函数被第一个执行，该函数在 <code>src/core/instance/render.js</code> 中，该方法中的代码很多，下面是简化过的：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">Vue.prototype._render = <span class="function"><span class="keyword">function</span> (<span class="params"></span>): <span class="title">VNode</span> </span>&#123;</div><div class="line">  <span class="keyword">const</span> vm: Component = <span class="keyword">this</span></div><div class="line">  <span class="comment">// 解构出 $options 中的 render 函数</span></div><div class="line">  <span class="keyword">const</span> &#123;</div><div class="line">    render,</div><div class="line">    staticRenderFns,</div><div class="line">    _parentVnode</div><div class="line">  &#125; = vm.$options</div><div class="line">  ...</div><div class="line"></div><div class="line">  <span class="keyword">let</span> vnode</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    <span class="comment">// 运行 render 函数</span></div><div class="line">    vnode = render.call(vm._renderProxy, vm.$createElement)</div><div class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</div><div class="line">    ...</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="comment">// set parent</span></div><div class="line">  vnode.parent = _parentVnode</div><div class="line">  <span class="keyword">return</span> vnode</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><code>_render</code> 方法首先从 <code>vm.$options</code> 中解构出 <code>render</code> 函数，大家应该记得：<code>vm</code>.<code>$options.render</code> 方法是在<code>web-runtime-with-compiler.js</code> 文件中通过 <code>compileToFunctions</code> 方法将 <code>template</code> 或 <code>el</code> 编译而来的。解构出 <code>render</code> 函数后，接下来便执行了该方法：</p><pre><code>vnode = render.call(vm._renderProxy, vm.$createElement)</code></pre><p>其中使用 <code>call</code> 指定了 <code>render</code> 函数的作用域环境为 <code>vm._renderProxy</code>，这个属性在我们整理实例对象的时候知道，他是在 <code>Vue.prototype._init</code> 方法中被添加的，即：<code>vm._renderProxy = vm</code>，其实就是Vue实例对象本身，然后传递了一个参数：<code>vm.$createElement</code>。那么 <code>render</code> 函数到底是干什么的呢？让我们根据上面那句代码猜一猜，我们已经知道 render 函数是从 <code>template</code> 或 <code>el</code> 编译而来的，如果没错的话应该是返回一个虚拟DOM对象。我们不妨使用 <code>console.log</code> 打印一下 <code>render</code> 函数，当我们的模板这样编写时：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;&#123;a&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div></pre></td></tr></table></figure></p><p>打印的 <code>render</code> 函数如下：</p><p><img src="http://7xlolm.com1.z0.glb.clouddn.com/vueimgr2.png" alt=""></p><p>其实了解Vue2.x版本的同学都知道，Vue提供了 <code>render</code> 选项，作为 <code>template</code> 的代替方案，同时为JavaScript提供了完全编程的能力，下面两种编写模板的方式实际是等价的：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 方案一：</span></div><div class="line"><span class="keyword">new</span> Vue(&#123;</div><div class="line">el: <span class="string">'#app'</span>,</div><div class="line">data: &#123;</div><div class="line">a: <span class="number">1</span></div><div class="line">&#125;,</div><div class="line">template: <span class="string">'&lt;ul&gt;&lt;li&gt;&#123;&#123;a&#125;&#125;&lt;/li&gt;&lt;li&gt;&#123;&#123;a&#125;&#125;&lt;/li&gt;&lt;/ul&gt;'</span></div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">// 方案二：</span></div><div class="line"><span class="keyword">new</span> Vue(&#123;</div><div class="line">el: <span class="string">'#app'</span>,</div><div class="line">render: <span class="function"><span class="keyword">function</span> (<span class="params">createElement</span>) </span>&#123;</div><div class="line">createElement(<span class="string">'ul'</span>, [</div><div class="line">createElement(<span class="string">'li'</span>, <span class="keyword">this</span>.a),</div><div class="line">createElement(<span class="string">'li'</span>, <span class="keyword">this</span>.a)</div><div class="line">])</div><div class="line">&#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p><p>现在我们再来看我们打印的 <code>render</code> 函数：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">anonymous</span>(<span class="params"></span>) </span>&#123;</div><div class="line"><span class="keyword">with</span>(<span class="keyword">this</span>)&#123;</div><div class="line"><span class="keyword">return</span> _c(<span class="string">'ul'</span>, &#123; </div><div class="line">attrs: &#123;<span class="string">"id"</span>: <span class="string">"app"</span>&#125;</div><div class="line">&#125;,[</div><div class="line">_c(<span class="string">'li'</span>, [_v(_s(a))])</div><div class="line">])</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>是不是与我们自己写 <code>render</code> 函数很像？因为 <code>render</code> 函数的作用域被绑定到了Vue实例，即：<code>render.call(vm._renderProxy</code>, v<code>m.$createElement)</code>，所以上面代码中 <code>_c</code>、<code>_v</code>、<code>_s</code> 以及变量 <code>a</code>相当于Vue实例下的方法和变量。大家还记得诸如 <code>_c</code>、<code>_v</code>、<code>_s</code> 这样的方法在哪里定义的吗？我们在整理Vue构造函数的时候知道，他们在 <code>src/core/instance/render.js</code> 文件中的 <code>renderMixin</code> 方法中定义，除了这些之外还有诸如：<code>_l</code>、 <code>_m</code>、 <code>_o</code> 等等。其中 <code>_l</code> 就在我们使用 <code>v-for</code> 指令的时候出现了。所以现在大家知道为什么这些方法都被定义在 <code>render.js</code> 文件中了吧，因为他们就是为了构造出 <code>render</code> 函数而存在的。<br>现在我们已经知道了 <code>render</code> 函数的长相，也知道了 <code>render</code> 函数的作用域是Vue实例本身即：<code>this</code>(或<code>vm</code>)。那么当我们执行 render 函数时，其中的变量如：<code>a</code>，就相当于：<code>this.a</code>，我们知道这是在求值，所以 <code>_mount</code> 中的这段代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">vm._watcher = <span class="keyword">new</span> Watcher(vm, () =&gt; &#123;</div><div class="line">  vm._update(vm._render(), hydrating)</div><div class="line">&#125;, noop)</div></pre></td></tr></table></figure></p><p>当 <code>vm._render</code> 执行的时候，所依赖的变量就会被求值，并被收集为依赖。按照Vue中<code>watcher.js</code> 的逻辑，当依赖的变量有变化时不仅仅回调函数被执行，实际上还要重新求值，即还要执行一遍：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">() =&gt; &#123;</div><div class="line">  vm._update(vm._render(), hydrating)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这实际上就做到了 <code>re-render</code>，因为 <code>vm._update</code> 就是文章开头所说的虚拟DOM中的最后一步：<code>patch</code><br><code>vm_render</code> 方法最终返回一个 <code>vnode</code> 对象，即虚拟DOM，然后作为 <code>vm_update</code>的第一个参数传递了过去，我们看一下 <code>vm_update</code> 的逻辑，在 <code>src/core/instance/lifecycle.js</code> 文件中有这么一段代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (!prevVnode) &#123;</div><div class="line">  <span class="comment">// initial render</span></div><div class="line">  vm.$el = vm.__patch__(</div><div class="line">    vm.$el, vnode, hydrating, <span class="literal">false</span> <span class="comment">/* removeOnly */</span>,</div><div class="line">    vm.$options._parentElm,</div><div class="line">    vm.$options._refElm</div><div class="line">  )</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">  <span class="comment">// updates</span></div><div class="line">  vm.$el = vm.__patch__(prevVnode, vnode)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>如果还没有 <code>prevVnode</code> 说明是首次渲染，直接创建真实DOM。如果已经有了 <code>prevVnode</code> 说明不是首次渲染，那么就采用 <code>patch</code> 算法进行必要的DOM操作。这就是Vue更新DOM的逻辑。只不过我们没有将 virtual DOM 内部的实现。<br>现在我们来好好理理思路，当我们写如下代码时：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> Vue(&#123;</div><div class="line">el: <span class="string">'#app'</span>,</div><div class="line">data: &#123;</div><div class="line">a: <span class="number">1</span>,</div><div class="line">b: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div><div class="line">&#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p><p>Vue 所做的事：</p><blockquote><ol><li>构建数据响应系统，使用 <code>Observer</code> 将数据data转换为访问器属性；将 <code>el</code> 编译为 <code>render</code> 函数，<code>render</code> 函数返回值为虚拟DOM</li><li>在 <code>_mount</code> 中对 <code>_update</code>求值，而 <code>_update</code> 又会对 <code>render</code> 求值，<code>render</code> 内部又会对依赖的变量求值，收集为被求值的变量的依赖，当变量改变时，<code>_update</code> 又会重新执行一遍，从而做到 <code>re-render</code></li></ol></blockquote><p>用一张详细一点的图表示就是这样的：</p><p><img src="http://7xlolm.com1.z0.glb.clouddn.com/vueimgdetail.png" alt=""></p><p>到此，我们从大体流程，挑着重点的走了一遍Vue，但是还有很多细节我们没有提及，比如：</p><ol><li>将模板转为 <code>render</code> 函数的时候，实际是先生成的抽象语法树（AST），再将抽象语法树转成的 <code>render</code> 函数，而且这一整套的代码我们也没有提及，因为他在复杂了，其实这部分内容就是在完正则。</li><li>我们也没有详细的讲 Virtual DOM 的实现原理，网上已经有文章讲了，大家可以搜一搜</li><li>我们的例子中仅仅传递了 <code>el</code> ，<code>data</code> 选项，大家知道 <code>Vue</code> 支持的选项很多，比如我们都没有讲到，但都是触类旁通的，比如你搞清楚了 <code>data</code> 选项再去看 <code>computed</code> 选项或者 <code>props</code> 选项就会很容易，比如你知道了 <code>Watcher</code> 的工作机制再去看 <code>watch</code> 选项就会很容易。<br>本篇文章作为Vue源码的启蒙文章，也许还有很多缺陷，全当抛砖引玉了。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;纸上得来终觉浅，绝知此事要躬&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;前段时间看到尤雨溪推荐了一篇vue源码的文章，自己一直也想研究下源码，这几天抽空看了，&lt;a href=&quot;http://hcysun.me/2017/03/03/Vue%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;原文猛戳&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;原本文章的名字叫做《源码解析》，不过后来想想，还是用“源码学习”来的合适一点，在没有彻底掌握源码中的每一个字母之前，“解析”就有点标题党了。建议在看这篇文章之前，最好打开&lt;code&gt;2.1.7&lt;/code&gt;的源码对照着看，这样可能更容易理解。另外本人水平有限，文中有错误或不妥的地方望大家多多指正共同成长。&lt;/p&gt;
&lt;p&gt;补充：&lt;code&gt;Vue 2.2&lt;/code&gt; 刚刚发布，作为一个系列文章的第一篇，本篇文章主要从Vue代码的组织，Vue构造函数的还原，原型的设计，以及参数选项的处理和已经被写烂了的数据绑定与如何使用 Virtual DOM 更新视图入手。从整体的大方向观察框架，这么看来 &lt;code&gt;V2.1.7&lt;/code&gt; 对于理解 &lt;code&gt;V2.2&lt;/code&gt;的代码不会有太大的影响。该系列文章的后续文章，都会从最新的源码入手，并对改动的地方做相应的提示。&lt;/p&gt;
&lt;p&gt;很久之前写过一篇文章：&lt;a href=&quot;http://hcysun.me/2016/04/28/JavaScript%E5%AE%9E%E7%8E%B0MVVM%E4%B9%8B%E6%88%91%E5%B0%B1%E6%98%AF%E6%83%B3%E7%9B%91%E6%B5%8B%E4%B8%80%E4%B8%AA%E6%99%AE%E9%80%9A%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8F%98%E5%8C%96/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;JavaScript实现MVVM之我就是想监测一个普通对象的变化&lt;/a&gt;，文章开头提到了我写博客的风格，还是那句话，只写努力让小白，甚至是小学生都能看明白的文章。这不免会导致对于某些同学来说这篇文章有些墨迹，所以大家根据自己的喜好，可以详细的看，也可以跳跃着看。&lt;br&gt;
    
    </summary>
    
      <category term="基础杂谈" scheme="https://dsb123dsb.github.io/categories/%E5%9F%BA%E7%A1%80%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="vue.js" scheme="https://dsb123dsb.github.io/tags/vue-js/"/>
    
      <category term="源码" scheme="https://dsb123dsb.github.io/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>CSS Grid布局浅谈</title>
    <link href="https://dsb123dsb.github.io/2017/05/04/CSS-Grid%E5%B8%83%E5%B1%80%E6%B5%85%E8%B0%88/"/>
    <id>https://dsb123dsb.github.io/2017/05/04/CSS-Grid布局浅谈/</id>
    <published>2017-05-04T08:13:29.000Z</published>
    <updated>2017-10-03T13:53:51.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>纸上得来终觉浅，绝知此事要躬行</p></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>中文原文（“大漠”，W3CPlus创始人，目前就职于手淘。）猛搓<a href="http://www.w3cplus.com/css3/playing-with-css-grid-layout.html著作权归作者所有。" target="_blank" rel="external">http://www.w3cplus.com/css3/playing-with-css-grid-layout.html</a>（原文很多概念并未涉及，个人建议将作者建议的一些中文外文链接参考也阅读了，以期全面了解和掌握）</p><p>自从去年下半年开始，CSS Grid布局的相关教程在互联网上就铺天盖地，可谓是声势浩大。就针对于Web布局而言，个人认为Grid布局将是Web布局的神器，它改变了以往任何一种布局方式或者方法。不管以前的采用什么布局方法都可以说是一维的布局方式，而Grid最大的特色，采用了二维布局。@Rachel Andrew也一直致力于完善Grid的规范。</p><p>就我个人而言，我也一直在不断的关注这个布局利器的相关更新，自从最初规范的出来，到目前规范的完善。在站上也不断的在更新<a href="https://www.w3cplus.com/blog/tags/356.html" target="_blank" rel="external">CSS Grid布局</a>的使用。虽然这方向的教程已经很多了，但各有千秋，我追求以最简单，最直接的方式来阐述它的使用方式方法。让初学者能尽快的掌握其使用规则。</p><p>前段时间@Mirza Joldic<a href="https://medium.com/@purplecones/playing-with-css-grid-layout-a75836098370" target="_blank" rel="external">在Medium上发布了一篇文章</a>，通过几个Gif动态非常形象的阐述了CSS Grid的几个核心概念以及使用方法，今天我就借花献佛，用这几张图让初学者快速掌握CSS Grid的核心概念和使用技巧。</p><h1 id="Web布局的历史演变"><a href="#Web布局的历史演变" class="headerlink" title="Web布局的历史演变"></a>Web布局的历史演变</h1><p>自从Web出来至今，Web的布局也经过了几个演变，下图可以一目了然：</p><p><img src="https://www.w3cplus.com/sites/default/files/blogs/2017/1704/learning-grid-gif-1.png" alt=""><br><a id="more"></a><br>有关于Web布局的演变史，去年也整理过一篇相关的文章简单的阐述了这方面的故事，如果你感兴趣的话，<a href="https://www.w3cplus.com/css/css-layout-model.html" target="_blank" rel="external">可以点击这里进行了解</a>。在Web的学习过程中，<a href="https://www.w3cplus.com/css/learn-css-layout.html" target="_blank" rel="external">学习Web布局</a>是一个不可避免的过程，而随着前端技术的日新月异的变化，布局方式也在不断的更新，早在2013年@Peter Gasston就对<a href="https://www.w3cplus.com/css3/future-css-layouts.html" target="_blank" rel="external">CSS布局的未来趋势</a>就做过预判断，文章中就提供了CSS Grid的布局。如果今天来看，这种趋势的预判是正确的，特别是今年3月份之后，各大主流浏览器都发布了对CSS Grid的支持。既然如此，学习CSS Grid相关的知识就很有必要。</p><p>既然掌握CSS Grid很有必要，那用什么样的方式能最快的掌握CSS Grid相关的知识呢？这很重要。 特别是@Mirza Joldic在Medium上发布的文章，里面的动图让我耳目一新，通过简单的几张图，就把CSS Grid的几个核心介绍的非常清楚，我觉得很有必要拿出来与大家分享。</p><p>在继续下面的内容之前，再次感谢@Mirza Joldic的付出。那咱们就不说废话了，开始今天的学习之旅。</p><h1 id="CSS-Grid布局的介绍"><a href="#CSS-Grid布局的介绍" class="headerlink" title="CSS Grid布局的介绍"></a>CSS Grid布局的介绍</h1><p>学习CSS Grid布局更多的相关知识，我觉得通过一些工具会对大家的理解更有帮助，到目前为止，这方面的在线工具已经有很多种，比如：</p><ul><li><a href="https://cssgridgarden.com/" target="_blank" rel="external">GRID GARDEN</a>：通过一个小游戏的方式，让你快速掌握CSS Grid的相关知识，这个有点类似于<a href="https://flexboxfroggy.com/" target="_blank" rel="external">FLEXBOX FROGGY</a></li><li><a href="https://griddy.io/" target="_blank" rel="external">Griddy</a> by @drewisthe</li><li><a href="https://alialaa.github.io/css-grid-cheat-sheet/" target="_blank" rel="external">CSS Grid Cheat Sheet</a> by @alialaa</li></ul><p>下面的动图是使用@Mirza Joldic写的<a href="https://www.cssgridplayground.com/" target="_blank" rel="external">CSS Grid Playground</a>小工具。动图来了：</p><p><img src="https://www.w3cplus.com/sites/default/files/blogs/2017/1704/learning-grid-gif-2.gif" alt=""></p><p>这里要提两个核心概念，这两个核心概念有点类似于Flexbox布局：</p><ul><li>Grid容器（对应Flexbox布局中的Flex容器）</li><li>Grid项目（对应Flexbox布局中的Flex项目）</li></ul><p>比如一个这样的HTML结构：</p><p><img src="https://www.w3cplus.com/sites/default/files/blogs/2017/1704/learning-grid-gif-3.png" alt=""></p><p>使用 CSS Grid布局首要的第一步，就是通过<code>display:grid</code>;来对容器声明一个网格容器，那么这个div元素里面对应的子元素就自动成为网格项目。</p><p><img src="https://www.w3cplus.com/sites/default/files/blogs/2017/1704/learning-grid-gif-4.gif" alt=""></p><p>虽然你在<code>div.grid-container</code>中设置了<code>display:grid</code>;，声明了这个元素为Grid容器，但在浏览器中，并看不到有任何的变化。但在在幕后中，他们还是发生了变化，<code>div.grid-container</code>是一个Grid容器，他的所有子元素就自动变成了网格项目。</p><p>接下来，使用<code>grid-template-columns: 1fr 1fr 1fr</code>;来定义三列网格：</p><p><img src="https://www.w3cplus.com/sites/default/files/blogs/2017/1704/learning-grid-gif-5.gif" alt=""></p><p>从gif图中就明显的看出来，现在有点变化了，颜色块变小了，但很难区分出有何变化，为了让效果之间有更突出的差异，再给<code>.grid-container</code>中添加<code>grid-gap:5px</code>：</p><p><img src="https://www.w3cplus.com/sites/default/files/blogs/2017/1704/learning-grid-gif-6.gif" alt=""></p><p>看到变化了吧，整个网格分了三个列，单元格之间有<code>5px</code>的间距，同时每列的列宽是整个宽度的三分之一，那是因为我们采用了<code>fr</code>单位，而且把整个网格分成了三列，每列的宽度是1fr。这里告诉我们三个知识点：</p><ul><li><code>grid-template-columns</code>用来把网格指定列的宽度</li><li><code>grid-gap</code>用来指定列（或行）的间距</li><li><code>fr</code>可以自动根据网格容器的宽度来计算列的宽度</li></ul><p>现在我们把<code>grid-template-columns</code>的值改成：<code>1fr 2fr 1fr</code>，对应的效果就会变成：</p><p><img src="https://www.w3cplus.com/sites/default/files/blogs/2017/1704/learning-grid-gif-7.gif" alt=""></p><p>现在第二列的宽度是第一列和最后一列的两倍。这也再次证明fr单位的强大之处，使用它可以让你很容易定义你的网格尺寸。</p><p>现在越来越接近我们想要的网格。但需求是不断变化的，比如我们现在想让顶部的第一行尽可能的宽，比如说跨整个网格列（比如我们网页的头部，或者说我们常见的导航）。如此一来，只需要在第一个网格上使用<code>grid-column: 1 / 4</code>：</p><p><img src="https://www.w3cplus.com/sites/default/files/blogs/2017/1704/learning-grid-gif-8.gif" alt=""></p><p>或许第一次接触<code>1 / 4</code>会令你感到神秘，其实这个涉及到了CSS Grid中的重要概念之一，那就是网格线，其中第一个数字是列的起始网格线位置，第二个数字是线束网格线的位置。对于一个CSS Grid，可以通过grid-<code>template-columns</code>创建列网格线，<code>grid-template-rows</code>创建行网格线。这种方式创建的是一种显式的网格线。当然，除了这种方式，还可以创建隐式网格线。除此之外，还可以使用<code>grid-auto-rows</code>和<code>grid-auto-columns</code>可以创建一个隐式网格。这个隐式网格对应的网格线就被称之为隐式网格线。下图简单的展示了示例中的网格线示意图：</p><p><img src="https://www.w3cplus.com/sites/default/files/blogs/2017/1704/learning-grid-gif-9.png" alt=""></p><p>接下来，我们想要有一个<code>300px</code>的侧边栏高度，并且让他的位置是垂直方向的<code>2 / 3</code>。我们可以使用<code>grid-row: 2 / 4</code>来实现，这个特性和<code>grid-column</code>非常的类似。这个时候，效果变成这样：</p><p><img src="https://www.w3cplus.com/sites/default/files/blogs/2017/1704/learning-grid-gif-10.gif" alt=""></p><p>其实CSS Grid看上去和表格非常的类似，在表格中我们有一个专业的术语，合并单元格。其实在CSS Grid布局中，我们同样有一个类似的特性，那就是在<code>grid-column</code>或者<code>grid-row</code>中引入关键词<code>span</code>，在关键词<code>span</code>后面紧跟一个数值，就是表示合并单元格的数量，先来看下图：</p><p><img src="https://www.w3cplus.com/sites/default/files/blogs/2017/1704/learning-grid-gif-11.gif" alt=""></p><p>上面的示例中，我们使用到了<code>grid-column: 2 / span 1</code>和<code>grid-row: 2 / span 2</code>。其中<code>grid-column: 2 / span 1</code>表示从列网格线2开始，跨度是1个列网格线（其实就是合并一个列单元格）。而<code>grid-row: 2 / span 2</code>表示的是从行网格线2开始，跨度是两个两个线（其实就是合并两个行单元格）。</p><p>接着我们来做页脚，在做页脚之前，我们先删除两个网格项目，因为不需要他们了。做页脚和做页头非常的类似，继续使用g<code>rid-column: 1 / 4</code>即可：</p><p><img src="https://www.w3cplus.com/sites/default/files/blogs/2017/1704/learning-grid-gif-12.gif" alt=""></p><p>通过上面的方式，我们可以轻易的控制网格，也能非常容易的实现一个Web面页的布局，比如一个三列的布局。但我们在布局中经常还需要控制对齐方式，特别是在CSS Grid的布局当中，比如下面的示例中，我们第三列并未占满整个高度，这个时候希望它能底部对齐。此时为了实现这样的效果，需要使用到CSS中的对齐模块特性，比如在这里，我们可以使用<code>align-self: end</code>来实现：</p><p><img src="https://www.w3cplus.com/sites/default/files/blogs/2017/1704/learning-grid-gif-13.gif" alt=""></p><p><code>align-self</code>是CSS中的一个新模块特性<a href="https://www.w3.org/TR/css-align-3/" target="_blank" rel="external">Box Alignment</a>中的一个属性。有关于这个模块的的功能还是非常的实用。@Rachel Andrew整理了一份<a href="https://rachelandrew.co.uk/css/cheatsheets/box-alignment" target="_blank" rel="external">Box Alignment Cheatsheet</a>，里面详细介绍了Box Alignment的使用。简单的来讲，这个规范中有三个关键部分：</p><ul><li><a href="https://drafts.csswg.org/css-align/#positional-values" target="_blank" rel="external">Positional Alignment</a>：关键词有start、end、center</li><li><a href="https://drafts.csswg.org/css-align/#baseline-values" target="_blank" rel="external">Baseline Alignment</a>：关键词有baseline、first baseline、last baseline</li><li><a href="https://drafts.csswg.org/css-align/#distribution-values" target="_blank" rel="external">Distributed Alignment</a>：关键词有space-between和space-around</li></ul><p>其实你要是对<a href="https://www.w3cplus.com/blog/tags/157.html" target="_blank" rel="external">Flexbox</a>熟悉的话，你或许感觉这个Box Alignment有点类似于Flexbox中的一些控制Flex项目对齐方式的属性。事实是这样的，如果你感兴趣想深入的了解这方面的相关知识，建议你花点时间阅读<a href="https://www.w3cplus.com/css/css-grids-flexbox-and-box-alignment-our-new-system-for-web-layout.html" target="_blank" rel="external">《Web布局新系统：CSS Grid,Flexbox和Box Alignment》</a>一文</p><p>如果你对上面的相关知识有所了解的话，你就可以很轻易的使用CSS Grid相关知识实现一个常用的Web页面布局效果。比如下面这张图，为了好完，我把主内容的容器设置了具体的宽度，并且通过Box Alignment属性，让这个区域水平垂直居中：</p><p><img src="https://www.w3cplus.com/sites/default/files/blogs/2017/1704/learning-grid-gif-14.gif" alt=""></p><p>整个题外话，虽然<a href="https://www.w3cplus.com/blog/tags/357.html" target="_blank" rel="external">实现水平垂直居中的解决方案</a>已有很多种了，但Box Alignment模块将是最佳方式。</p><p>如果你感兴趣的话，你也可以通过@Mirza Joldic写的<a href="https://www.cssgridplayground.com/" target="_blank" rel="external">CSS Grid Playground</a>小工具去尝试各式各样的网格布局效果。从而加强对CSS Grid的概念。当然，在使用它去做一些事情或者做一些创意之前，还是很有必要对CSS Grid基础要有一个简单的了解。个人建议你花点时间阅读一下下面几篇文章：</p><ul><li><a href="https://www.w3cplus.com/css3/css-grid-layout-terminology-part1.html" target="_blank" rel="external">CSS Grid布局：图解网格布局中术语之一</a></li><li><a href="https://www.w3cplus.com/css3/css-grid-layout-terminology-part2.html" target="_blank" rel="external">CSS Grid布局：图解网格布局中术语二</a></li><li><a href="https://www.w3cplus.com/css3/css-grid-layout-terminology-part3.html" target="_blank" rel="external">CSS Grid布局：图解网格布局中术语三</a></li><li><a href="https://www.w3cplus.com/css3/a-complete-guide-css-grid-layout.html" target="_blank" rel="external">CSS Grid布局指南</a></li></ul><p>当然，如果你深入的学习CSS Grid的相关知识，个人强列你仔细阅读<a href="https://www.w3cplus.com/blog/tags/356.html" target="_blank" rel="external">完这里的所有文章</a>。其实我个人也是CSS Grid的极度爱好者，我将在这里不断的更新和发布有关于CSS Grid的相关文章。希望这些文章对你学习和使用CSS Grid有所帮助。</p><p>中文原文（“大漠”，W3CPlus创始人，目前就职于手淘。）<a href="http://www.w3cplus.com/css3/playing-with-css-grid-layout.html著作权归作者所有。" target="_blank" rel="external">http://www.w3cplus.com/css3/playing-with-css-grid-layout.html</a></p><p>英文参考地址Mirza Joldic在Medium<a href="https://medium.com/@purplecones/playing-with-css-grid-layout-a75836098370" target="_blank" rel="external">https://medium.com/@purplecones/playing-with-css-grid-layout-a75836098370</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;纸上得来终觉浅，绝知此事要躬行&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;中文原文（“大漠”，W3CPlus创始人，目前就职于手淘。）猛搓&lt;a href=&quot;http://www.w3cplus.com/css3/playing-with-css-grid-layout.html著作权归作者所有。&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.w3cplus.com/css3/playing-with-css-grid-layout.html&lt;/a&gt;（原文很多概念并未涉及，个人建议将作者建议的一些中文外文链接参考也阅读了，以期全面了解和掌握）&lt;/p&gt;
&lt;p&gt;自从去年下半年开始，CSS Grid布局的相关教程在互联网上就铺天盖地，可谓是声势浩大。就针对于Web布局而言，个人认为Grid布局将是Web布局的神器，它改变了以往任何一种布局方式或者方法。不管以前的采用什么布局方法都可以说是一维的布局方式，而Grid最大的特色，采用了二维布局。@Rachel Andrew也一直致力于完善Grid的规范。&lt;/p&gt;
&lt;p&gt;就我个人而言，我也一直在不断的关注这个布局利器的相关更新，自从最初规范的出来，到目前规范的完善。在站上也不断的在更新&lt;a href=&quot;https://www.w3cplus.com/blog/tags/356.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CSS Grid布局&lt;/a&gt;的使用。虽然这方向的教程已经很多了，但各有千秋，我追求以最简单，最直接的方式来阐述它的使用方式方法。让初学者能尽快的掌握其使用规则。&lt;/p&gt;
&lt;p&gt;前段时间@Mirza Joldic&lt;a href=&quot;https://medium.com/@purplecones/playing-with-css-grid-layout-a75836098370&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;在Medium上发布了一篇文章&lt;/a&gt;，通过几个Gif动态非常形象的阐述了CSS Grid的几个核心概念以及使用方法，今天我就借花献佛，用这几张图让初学者快速掌握CSS Grid的核心概念和使用技巧。&lt;/p&gt;
&lt;h1 id=&quot;Web布局的历史演变&quot;&gt;&lt;a href=&quot;#Web布局的历史演变&quot; class=&quot;headerlink&quot; title=&quot;Web布局的历史演变&quot;&gt;&lt;/a&gt;Web布局的历史演变&lt;/h1&gt;&lt;p&gt;自从Web出来至今，Web的布局也经过了几个演变，下图可以一目了然：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.w3cplus.com/sites/default/files/blogs/2017/1704/learning-grid-gif-1.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="技术分享" scheme="https://dsb123dsb.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="css" scheme="https://dsb123dsb.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript监听全部Ajax请求事件的方法</title>
    <link href="https://dsb123dsb.github.io/2017/05/02/JavaScript%E7%9B%91%E5%90%AC%E5%85%A8%E9%83%A8Ajax%E8%AF%B7%E6%B1%82%E4%BA%8B%E4%BB%B6%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>https://dsb123dsb.github.io/2017/05/02/JavaScript监听全部Ajax请求事件的方法/</id>
    <published>2017-05-02T07:34:59.000Z</published>
    <updated>2017-10-03T13:53:51.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>纸上得来终觉浅，绝知此事要躬行</p></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前段时间做阿里暑期实习笔试题目，抽到的试题最后一道要求写个组件监听页面所有ajax请求，当时大概能猜到要改写XMLHttpReuqest对象，不过最后还是没写出来，回来查了下资料：</p><ol><li>若Ajax请求是由jQuery的$.ajax发起的，默认情况下可以使用 jQuery的Global Ajax Event Handlers监听到Ajax事件，</li><li>然而我遇到的却是用原生JavaScript发起的Ajax请求，所以这种方法行不通。</li><li>还有其他方法，比如说 Pub/Sub，但是这个发起请求的 js 代码我是无法改动的，也就不存在向代码里添加 publish 的问题。同理，jQuery 的 .bind 和 .trigger 也无法使用。</li></ol><p>最后的方案：实现主要是两点：<code>**override XMLHttpRequest**</code>和<strong>自定义事件</strong>（这一块红宝书有讲，也看过，并没有重视，自己没有好好钻研，怨不得别人）<br><a id="more"></a></p><h1 id="1-0实现"><a href="#1-0实现" class="headerlink" title="1.0实现"></a>1.0实现</h1><p>在 StackOverflow 上搜索，发现有个歪果仁给出了一个不靠谱的解决方法，嗯，贴出来给大家看看：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">;(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line"> <span class="keyword">var</span> open = <span class="built_in">window</span>.XMLHttpRequest.prototype.open,</div><div class="line">  send = <span class="built_in">window</span>.XMLHttpRequest.prototype.send,</div><div class="line">  onReadyStateChange;</div><div class="line">  </div><div class="line"> <span class="function"><span class="keyword">function</span> <span class="title">openReplacement</span>(<span class="params">method, url, async, user, password</span>) </span>&#123;</div><div class="line">  <span class="comment">// some code</span></div><div class="line">  </div><div class="line">  <span class="keyword">return</span> open.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</div><div class="line"> &#125;</div><div class="line">  </div><div class="line"> <span class="function"><span class="keyword">function</span> <span class="title">sendReplacement</span>(<span class="params">data</span>) </span>&#123;</div><div class="line">  <span class="comment">// some code</span></div><div class="line">  </div><div class="line">  <span class="keyword">if</span>(<span class="keyword">this</span>.onreadystatechange) <span class="keyword">this</span>._onreadystatechange = <span class="keyword">this</span>.onreadystatechange;</div><div class="line">  <span class="keyword">this</span>.onreadystatechange = onReadyStateChangeReplacement;</div><div class="line">  </div><div class="line">  <span class="keyword">return</span> send.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</div><div class="line"> &#125;</div><div class="line">  </div><div class="line"> <span class="function"><span class="keyword">function</span> <span class="title">onReadyStateChangeReplacement</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// some code</span></div><div class="line">  </div><div class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>._onreadystatechange) <span class="keyword">return</span> <span class="keyword">this</span>._onreadystatechange.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</div><div class="line"> &#125;</div><div class="line">  </div><div class="line"> <span class="built_in">window</span>.XMLHttpRequest.prototype.open = openReplacement;</div><div class="line"> <span class="built_in">window</span>.XMLHttpRequest.prototype.send = sendReplacement;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure></p><p>这个解决方案，无法监听全部的 <code>XHR Events</code> ，而且 <code>readystatechange</code> 事件是在调用 <code>send</code> 方法后才监听，也就无法监听到<code>readyState = 1</code>时的事件。同时，如果在使用 <code>send</code> 方法后再对 <code>onreadystatechange</code> 设置回调函数，会将<code>override</code> 的代码又一次 <code>override</code>，也就无法产生预想的效果。</p><h1 id="2-0实现"><a href="#2-0实现" class="headerlink" title="2.0实现"></a>2.0实现</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">;(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line"> <span class="function"><span class="keyword">function</span> <span class="title">ajaxEventTrigger</span>(<span class="params">event</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> ajaxEvent = <span class="keyword">new</span> CustomEvent(event, &#123; <span class="attr">detail</span>: <span class="keyword">this</span> &#125;);</div><div class="line">  <span class="built_in">window</span>.dispatchEvent(ajaxEvent);</div><div class="line"> &#125;</div><div class="line">   </div><div class="line"> <span class="keyword">var</span> oldXHR = <span class="built_in">window</span>.XMLHttpRequest;</div><div class="line">  </div><div class="line"> <span class="function"><span class="keyword">function</span> <span class="title">newXHR</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> realXHR = <span class="keyword">new</span> oldXHR();</div><div class="line">  <span class="comment">// this指向window</span></div><div class="line">  realXHR.addEventListener(<span class="string">'abort'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; ajaxEventTrigger.call(<span class="keyword">this</span>, <span class="string">'ajaxAbort'</span>); &#125;, <span class="literal">false</span>);</div><div class="line">  </div><div class="line">  realXHR.addEventListener(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; ajaxEventTrigger.call(<span class="keyword">this</span>, <span class="string">'ajaxError'</span>); &#125;, <span class="literal">false</span>);</div><div class="line">  </div><div class="line">  realXHR.addEventListener(<span class="string">'load'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; ajaxEventTrigger.call(<span class="keyword">this</span>, <span class="string">'ajaxLoad'</span>); &#125;, <span class="literal">false</span>);</div><div class="line">  </div><div class="line">  realXHR.addEventListener(<span class="string">'loadstart'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; ajaxEventTrigger.call(<span class="keyword">this</span>, <span class="string">'ajaxLoadStart'</span>); &#125;, <span class="literal">false</span>);</div><div class="line">  </div><div class="line">  realXHR.addEventListener(<span class="string">'progress'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; ajaxEventTrigger.call(<span class="keyword">this</span>, <span class="string">'ajaxProgress'</span>); &#125;, <span class="literal">false</span>);</div><div class="line">  </div><div class="line">  realXHR.addEventListener(<span class="string">'timeout'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; ajaxEventTrigger.call(<span class="keyword">this</span>, <span class="string">'ajaxTimeout'</span>); &#125;, <span class="literal">false</span>);</div><div class="line">  </div><div class="line">  realXHR.addEventListener(<span class="string">'loadend'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; ajaxEventTrigger.call(<span class="keyword">this</span>, <span class="string">'ajaxLoadEnd'</span>); &#125;, <span class="literal">false</span>);</div><div class="line">  </div><div class="line">  realXHR.addEventListener(<span class="string">'readystatechange'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; ajaxEventTrigger.call(<span class="keyword">this</span>, <span class="string">'ajaxReadyStateChange'</span>); &#125;, <span class="literal">false</span>);</div><div class="line">  </div><div class="line">  <span class="keyword">return</span> realXHR;</div><div class="line"> &#125;</div><div class="line">  </div><div class="line"> <span class="built_in">window</span>.XMLHttpRequest = newXHR;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure><p>这样，就为 <code>XHR</code> 添加了自定义事件。如何调用？<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</div><div class="line">  </div><div class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'ajaxReadyStateChange'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</div><div class="line"> <span class="built_in">console</span>.log(e.detail); <span class="comment">// XMLHttpRequest Object</span></div><div class="line">&#125;);</div><div class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'ajaxAbort'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</div><div class="line"> <span class="built_in">console</span>.log(e.detail.responseText); <span class="comment">// XHR 返回的内容</span></div><div class="line">&#125;);</div><div class="line">  </div><div class="line">xhr.open(<span class="string">'GET'</span>, <span class="string">'info.json'</span>);</div><div class="line">xhr.send();</div></pre></td></tr></table></figure></p><p>需要注意的是，正常的 <code>readystatechange</code> 等事件 <code>handler</code> 返回的 <code>e</code> 是 <code>XMLHttpRequest</code> 对象，但是自定义方法 <code>ajaxReadyStateChange</code> 等事件 <code>handler</code> 返回的 <code>e</code> 是 <code>CustomEvent</code> 对象，而 <code>e.detail</code>才是真正的 <code>XMLHttpRequest</code> 对象。而获得 <code>Ajax</code> 请求返回内容的 <code>e.responseText</code> 也需要修改为 <code>e.detail.responseText</code>。<br>同时，<code>addEventListener</code> 方法必须挂载在 <code>window</code> 对象上，而不能是 <code>XHR</code> 实例上。</p><h1 id="改进？"><a href="#改进？" class="headerlink" title="改进？"></a>改进？</h1><p>以上代码使用了 <code>CustomEvent</code> 构造函数，在现代浏览器上可以正常使用，但是在 IE 下，甚至连 IE 11 都不支持，所以需要加上 <code>Polyfill</code>，变成这样：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">;(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line"> <span class="keyword">if</span> ( <span class="keyword">typeof</span> <span class="built_in">window</span>.CustomEvent === <span class="string">"function"</span> ) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">  </div><div class="line"> <span class="function"><span class="keyword">function</span> <span class="title">CustomEvent</span> (<span class="params"> event, params </span>) </span>&#123;</div><div class="line">  params = params || &#123; <span class="attr">bubbles</span>: <span class="literal">false</span>, <span class="attr">cancelable</span>: <span class="literal">false</span>, <span class="attr">detail</span>: <span class="literal">undefined</span> &#125;;</div><div class="line">  <span class="keyword">var</span> evt = <span class="built_in">document</span>.createEvent( <span class="string">'CustomEvent'</span> );</div><div class="line">  evt.initCustomEvent( event, params.bubbles, params.cancelable, params.detail );</div><div class="line">  <span class="keyword">return</span> evt;</div><div class="line"> &#125;</div><div class="line">  </div><div class="line"> CustomEvent.prototype = <span class="built_in">window</span>.Event.prototype;</div><div class="line">  </div><div class="line"> <span class="built_in">window</span>.CustomEvent = CustomEvent;</div><div class="line">&#125;)();</div><div class="line">;(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line"> <span class="function"><span class="keyword">function</span> <span class="title">ajaxEventTrigger</span>(<span class="params">event</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> ajaxEvent = <span class="keyword">new</span> CustomEvent(event, &#123; <span class="attr">detail</span>: <span class="keyword">this</span> &#125;);</div><div class="line">  <span class="built_in">window</span>.dispatchEvent(ajaxEvent);</div><div class="line"> &#125;</div><div class="line">   </div><div class="line"> <span class="keyword">var</span> oldXHR = <span class="built_in">window</span>.XMLHttpRequest;</div><div class="line">  </div><div class="line"> <span class="function"><span class="keyword">function</span> <span class="title">newXHR</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> realXHR = <span class="keyword">new</span> oldXHR();</div><div class="line">  </div><div class="line">  realXHR.addEventListener(<span class="string">'abort'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; ajaxEventTrigger.call(<span class="keyword">this</span>, <span class="string">'ajaxAbort'</span>); &#125;, <span class="literal">false</span>);</div><div class="line">  </div><div class="line">  realXHR.addEventListener(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; ajaxEventTrigger.call(<span class="keyword">this</span>, <span class="string">'ajaxError'</span>); &#125;, <span class="literal">false</span>);</div><div class="line">  </div><div class="line">  realXHR.addEventListener(<span class="string">'load'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; ajaxEventTrigger.call(<span class="keyword">this</span>, <span class="string">'ajaxLoad'</span>); &#125;, <span class="literal">false</span>);</div><div class="line">  </div><div class="line">  realXHR.addEventListener(<span class="string">'loadstart'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; ajaxEventTrigger.call(<span class="keyword">this</span>, <span class="string">'ajaxLoadStart'</span>); &#125;, <span class="literal">false</span>);</div><div class="line">  </div><div class="line">  realXHR.addEventListener(<span class="string">'progress'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; ajaxEventTrigger.call(<span class="keyword">this</span>, <span class="string">'ajaxProgress'</span>); &#125;, <span class="literal">false</span>);</div><div class="line">  </div><div class="line">  realXHR.addEventListener(<span class="string">'timeout'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; ajaxEventTrigger.call(<span class="keyword">this</span>, <span class="string">'ajaxTimeout'</span>); &#125;, <span class="literal">false</span>);</div><div class="line">  </div><div class="line">  realXHR.addEventListener(<span class="string">'loadend'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; ajaxEventTrigger.call(<span class="keyword">this</span>, <span class="string">'ajaxLoadEnd'</span>); &#125;, <span class="literal">false</span>);</div><div class="line">  </div><div class="line">  realXHR.addEventListener(<span class="string">'readystatechange'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; ajaxEventTrigger.call(<span class="keyword">this</span>, <span class="string">'ajaxReadyStateChange'</span>); &#125;, <span class="literal">false</span>);</div><div class="line">  </div><div class="line">  <span class="keyword">return</span> realXHR;</div><div class="line"> &#125;</div><div class="line">  </div><div class="line"> <span class="built_in">window</span>.XMLHttpRequest = newXHR;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure></p><p>此时，就可以在 IE 9+、Chrome 15+、FireFox 11+、Edge、Safari 6.1+、Opera 12.1+ 上愉快地使用了，以上就是本文的全部内容，希望大家能够喜欢。</p><p>参考原文——–<a href="http://www.jb51.net/article/91419.htm" target="_blank" rel="external">http://www.jb51.net/article/91419.htm</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;纸上得来终觉浅，绝知此事要躬行&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;前段时间做阿里暑期实习笔试题目，抽到的试题最后一道要求写个组件监听页面所有ajax请求，当时大概能猜到要改写XMLHttpReuqest对象，不过最后还是没写出来，回来查了下资料：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;若Ajax请求是由jQuery的$.ajax发起的，默认情况下可以使用 jQuery的Global Ajax Event Handlers监听到Ajax事件，&lt;/li&gt;
&lt;li&gt;然而我遇到的却是用原生JavaScript发起的Ajax请求，所以这种方法行不通。&lt;/li&gt;
&lt;li&gt;还有其他方法，比如说 Pub/Sub，但是这个发起请求的 js 代码我是无法改动的，也就不存在向代码里添加 publish 的问题。同理，jQuery 的 .bind 和 .trigger 也无法使用。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;最后的方案：实现主要是两点：&lt;code&gt;**override XMLHttpRequest**&lt;/code&gt;和&lt;strong&gt;自定义事件&lt;/strong&gt;（这一块红宝书有讲，也看过，并没有重视，自己没有好好钻研，怨不得别人）&lt;br&gt;
    
    </summary>
    
      <category term="技术分享" scheme="https://dsb123dsb.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="ajax" scheme="https://dsb123dsb.github.io/tags/ajax/"/>
    
  </entry>
  
  <entry>
    <title>如何用原生 JS 实现手势解锁组件</title>
    <link href="https://dsb123dsb.github.io/2017/04/30/%E5%A6%82%E4%BD%95%E7%94%A8%E5%8E%9F%E7%94%9F-JS-%E5%AE%9E%E7%8E%B0%E6%89%8B%E5%8A%BF%E8%A7%A3%E9%94%81%E7%BB%84%E4%BB%B6/"/>
    <id>https://dsb123dsb.github.io/2017/04/30/如何用原生-JS-实现手势解锁组件/</id>
    <published>2017-04-30T13:46:46.000Z</published>
    <updated>2017-10-03T13:53:51.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>纸上得来终觉浅，绝知此事要躬行</p></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>原文猛戳月影大大博客<a href="https://www.h5jun.com/post/handlock-comp.html#toc-af9" target="_blank" rel="external">—十年踪迹—-</a>,读了一遍干货很多，先转过来，后面再慢慢消化。<br>这是<a href="https://html5.360.cn/star" target="_blank" rel="external">第三届 360 前端星计划</a>的选拔<a href="https://www.h5jun.com/post/75team-star-handlock.html" target="_blank" rel="external">作业题</a>。600多名学生参与了解答，最后通过了60人。这60名同学完成的不错，思路、代码风格、功能完成度颇有可取之处，不过也有一些欠考虑的地方，比如发现很多同学能按照需求实现完整的功能，但是不知道应当如何<em>设计开放的 API</em>，或者说，如何分析和预判产品需求和未来的变化，从而决定什么应当开放，什么应当封装。这无关于答案正确与否，还是和经验有关。<br><a id="more"></a><br>在这里，我提供一个<a href="https://github.com/akira-cn/handlock" target="_blank" rel="external">参考的版本</a>，并不是说这一版就最好，而是说，通过这一版，分析当我们遇到这样的比较复杂的 UI 需求的时候，我们应该怎样思考和实现。</p><p><img src="https://p.ssl.qhimg.com/d/inn/603c0bc8/06692681-E1C6-400A-A516-D7F8B26732C7.png" alt=""></p><h1 id="组件设计的一般步骤"><a href="#组件设计的一般步骤" class="headerlink" title="组件设计的一般步骤"></a>组件设计的一般步骤</h1><p>组件设计一般来说包括如下一些过程：</p><ol><li>理解需求</li><li>技术选型</li><li>结构（UI）设计</li><li>数据和API设计</li><li>流程设计</li><li>兼容性和细节优化</li><li>工具 &amp; 工程化</li></ol><p>这些过程并不是每个组件设计的时候都会遇到，但是通常来说一个项目总会在其中一些过程里遇到问题需要解决。下面我们来简单分析一下</p><h2 id="理解需求"><a href="#理解需求" class="headerlink" title="理解需求"></a>理解需求</h2><p>作业本身只是说设计一个常见的手势密码的 UI 交互，可以通过选择验证密码和设置密码来切换两种状态，每种状态有自己的流程。因此大部分同学就照着需求把整个组件的状态切换和流程封装了起来，有的同学提供了一定的 UI 样式配置能力，但是基本上没有同学能将流程和状态切换过程中的节点给开放出来。实际上这个组件如果要给用户使用，显然需要将过程节点开放出来，也就是说，<strong>需要由使用者决定设置密码的过程里执行什么操作、验证密码的过程和密码验证成功后执行什么操作</strong>，这些是组件开发者无法代替使用者来决定的。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> password = <span class="string">'11121323'</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> locker = <span class="keyword">new</span> HandLock.Locker(&#123;</div><div class="line">  container: <span class="built_in">document</span>.querySelector(<span class="string">'#handlock'</span>),</div><div class="line">  check: &#123;</div><div class="line">    checked: <span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</div><div class="line">      <span class="keyword">if</span>(res.err)&#123;</div><div class="line">        <span class="built_in">console</span>.error(res.err); <span class="comment">//密码错误或长度太短</span></div><div class="line">        [执行操作...]</div><div class="line">      &#125;<span class="keyword">else</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">`正确，密码是：<span class="subst">$&#123;res.records&#125;</span>`</span>);</div><div class="line">        [执行操作...]</div><div class="line">      &#125;</div><div class="line">    &#125;,</div><div class="line">  &#125;,</div><div class="line">  update:&#123;</div><div class="line">    beforeRepeat: <span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</div><div class="line">      <span class="keyword">if</span>(res.err)&#123;</div><div class="line">        <span class="built_in">console</span>.error(res.err); <span class="comment">//密码长度太短</span></div><div class="line">        [执行操作...]</div><div class="line">      &#125;<span class="keyword">else</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">`密码初次输入完成，等待重复输入`</span>);</div><div class="line">        [执行操作...]</div><div class="line">      &#125;</div><div class="line">    &#125;,</div><div class="line">    afterRepeat: <span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</div><div class="line">      <span class="keyword">if</span>(res.err)&#123;</div><div class="line">        <span class="built_in">console</span>.error(res.err); <span class="comment">//密码长度太短或者两次密码输入不一致</span></div><div class="line">        [执行操作...]</div><div class="line">      &#125;<span class="keyword">else</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">`密码更新完成，新密码是：<span class="subst">$&#123;res.records&#125;</span>`</span>);</div><div class="line">        [执行操作...]</div><div class="line">      &#125;</div><div class="line">    &#125;,</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">locker.check(password);</div></pre></td></tr></table></figure></p><h2 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h2><p>这个问题的 UI 展现的核心是九宫格和选中的小圆点，从技术上来讲，我们有三种可选方案： DOM/Canvas/SVG，三者都是可以实现主体 UI 的。</p><p>如果使用 DOM，最简单的方式是使用 flex 布局，这样能够做成响应式的</p><p><a class="jsbin-embed" href="//code.h5jun.com/dago/5/embed?html,css,js,output">JS Bin on jsbin.com</a><script src="https:////code.h5jun.com/js/embed.min.js?3.40.2"></script></p><p>使用 DOM 的优点是容易实现响应式，事件处理简单，布局也不复杂（但是和 Canvas 比起来略微复杂），但是斜线（demo 里没有画）的长度和斜率需要计算。</p><p>除了使用 DOM 外，使用 Canvas 绘制也很方便：</p><p><a class="jsbin-embed" href="//code.h5jun.com/biz/1/embed?html,css,js,output">JS Bin on jsbin.com</a><script src="https:////code.h5jun.com/js/embed.min.js?3.40.2"></script></p><p>用 Canvas 实现有两个小细节，第一是要实现响应式，可以用 DOM 构造一个正方形的容器：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">#container &#123;</div><div class="line">  position: relative;</div><div class="line">  overflow: hidden;</div><div class="line">  width: <span class="number">100</span>%;</div><div class="line">  padding-top: <span class="number">100</span>%;</div><div class="line">  height: <span class="number">0</span>px;</div><div class="line">  background-color: white;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在这里我们使用 <code>padding-top:100%</code> 撑开容器高度使它等于容器宽度。</p><p>第二个细节是为了在 retina 屏上获得清晰的显示效果，我们将 Canvas 的宽高增加一倍，然后通过 <code>transform: scale(0.5)</code> 来缩小到匹配容器宽高。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#container canvas&#123;</div><div class="line">  position: absolute;</div><div class="line">  left: <span class="number">50</span>%;</div><div class="line">  top: <span class="number">50</span>%;</div><div class="line">  transform: translate(<span class="number">-50</span>%, <span class="number">-50</span>%) scale(<span class="number">0.5</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>由于 Canvas 的定位是 absolute，它本身的默认宽高并不等于容器的宽高，需要通过 JS 设置：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> width = <span class="number">2</span> * container.getBoundingClientRect().width;</div><div class="line">canvas.width = canvas.height = width;</div></pre></td></tr></table></figure></p><p>这样我们就可以通过在 Canvas 上绘制实心圆和连线来实现 UI 了。具体的方法在后续的内容里有更详细的讲解。</p><p>最后我们来看一下用 SVG 绘制：</p><p><a class="jsbin-embed" href="//code.h5jun.com/kuf/1/embed?html,css,js,output">JS Bin on jsbin.com</a><script src="https:////code.h5jun.com/js/embed.min.js?3.40.2"></script></p><p>由于 SVG 原生操作的 API 不是很方便，这里使用了 Snap.svg 库，实现起来和使用 Canvas 大同小异，这里就不赘述了。</p><p>SVG 的问题是移动端兼容性不如 DOM 和 Canvas 好。</p><p>综合上面三者的情况，最终我选择使用 Canvas 来实现。</p><h2 id="结构设计"><a href="#结构设计" class="headerlink" title="结构设计"></a>结构设计</h2><p>使用 Canvas 实现的话 DOM 结构就比较简单。为了响应式，我们需要实现一个自适应宽度的正方形容器，方法前面已经介绍过。接着在容器中创建 Canvas。这里需要注意的一点是，我们应当把 Canvas 分层。这是因为 Canvas 的渲染机制里，要更新画布的内容，需要刷新要更新的区域重新绘制。因为我们有必要把频繁变化的内容和基本不变的内容分层管理，这样能显著提升性能。</p><h3 id="分成-3-个图层"><a href="#分成-3-个图层" class="headerlink" title="分成 3 个图层"></a>分成 3 个图层</h3><p><img src="https://p4.ssl.qhimg.com/t01e8fbcac1b8d2f472.png" alt=""></p><p>在这里我把 UI 分别绘制在 3 个图层里，对应 3 个 Canvas。最上层只有随着手指头移动的那个线段，中间是九个点，最下层是已经绘制好的线。之所以这样分，是因为随手指头移动的那条线需要不断刷新，底下两层都不用频繁更新，但是把连好的线放在最底层是因为我要做出圆点把线的一部分遮挡住的效果。</p><h3 id="确定圆点的位置"><a href="#确定圆点的位置" class="headerlink" title="确定圆点的位置"></a>确定圆点的位置</h3><p><img src="https://p0.ssl.qhimg.com/t01a663c97f0dd807e3.png" alt=""></p><p>圆点的位置有两种定位法，第一种是九个九宫格，圆点在小九宫格的中心位置。如果认真的同学，已经发现在前面 DOM 方案里，我们就是采用这样的方式，圆点的直径为 11.1%。第二种方式是用横竖三条线把宽高四等分，圆点在这些线的交点处。</p><p>在 Canvas 里我们采用第二种方法来确定圆点（代码里的 n = 3）。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> range = <span class="built_in">Math</span>.round(width / (n + <span class="number">1</span>));</div><div class="line"></div><div class="line"><span class="keyword">let</span> circles = [];</div><div class="line"></div><div class="line"><span class="comment">//drawCircleCenters</span></div><div class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</div><div class="line">    <span class="keyword">let</span> y = range * i, x = range * j;</div><div class="line">    drawSolidCircle(circleCtx, fgColor, x, y, innerRadius);</div><div class="line">    <span class="keyword">let</span> circlePoint = &#123;x, y&#125;;</div><div class="line">    circlePoint.pos = [i, j];</div><div class="line">    circles.push(circlePoint);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>最后一点，严格说不属于结构设计，但是因为我们的 UI 是通过触屏操作，我们需要考虑 Touch 事件处理和坐标的转换。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCanvasPoint</span>(<span class="params">canvas, x, y</span>)</span>&#123;</div><div class="line">  <span class="keyword">let</span> rect = canvas.getBoundingClientRect();</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    x: <span class="number">2</span> * (x - rect.left), </div><div class="line">    y: <span class="number">2</span> * (y - rect.top),</div><div class="line">  &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>我们将 Touch 相对于屏幕的坐标转换为 Canvas 相对于画布的坐标。代码里的 2 倍是因为我们前面说了要让 retina 屏下清晰，我们将 Canvas 放大为原来的 2 倍。</p><h2 id="API-设计"><a href="#API-设计" class="headerlink" title="API 设计"></a>API 设计</h2><p>接下来我们需要设计给使用者使用的 API 了。在这里，我们将组件功能分解一下，独立出一个单纯记录手势的 Recorder。将组件功能分解为更加底层的组件，是一种简化组件设计的常用模式。</p><p><img src="https://p5.ssl.qhimg.com/t01cf2097cf8acb1cb7.png" alt=""></p><p>我们抽取出底层的 Recorder，让 Locker 继承 Recorder，Recorder 负责记录，Locker 管理实际的设置和验证密码的过程。</p><p>我们的 Recorder 只负责记录用户行为，由于用户操作是异步操作，我们将它设计为 Promise 规范的 API，它可以以如下方式使用：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> recorder = <span class="keyword">new</span> HandLock.Recorder(&#123;</div><div class="line">  container: <span class="built_in">document</span>.querySelector(<span class="string">'#main'</span>)</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">recorded</span>(<span class="params">res</span>)</span>&#123;</div><div class="line">  <span class="keyword">if</span>(res.err)&#123;</div><div class="line">    <span class="built_in">console</span>.error(res.err);</div><div class="line">    recorder.clearPath();</div><div class="line">    <span class="keyword">if</span>(res.err.message !== HandLock.Recorder.ERR_USER_CANCELED)&#123;</div><div class="line">      recorder.record().then(recorded);</div><div class="line">    &#125;</div><div class="line">  &#125;<span class="keyword">else</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(res.records);</div><div class="line">    recorder.record().then(recorded);</div><div class="line">  &#125;      </div><div class="line">&#125;</div><div class="line"></div><div class="line">recorder.record().then(recorded);</div></pre></td></tr></table></figure></p><p>对于输出结果，我们简单用选中圆点的行列坐标拼接起来得到一个唯一的序列。例如 “11121323” 就是如下选择图形：</p><p><img src="https://p4.ssl.qhimg.com/t012a1dd06ae9814468.png" alt=""></p><p>为了让 UI 显示具有灵活性，我们还可以将外观配置抽取出来。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> defaultOptions = &#123;</div><div class="line">  container: <span class="literal">null</span>, <span class="comment">//创建canvas的容器，如果不填，自动在 body 上创建覆盖全屏的层</span></div><div class="line">  focusColor: <span class="string">'#e06555'</span>,  <span class="comment">//当前选中的圆的颜色</span></div><div class="line">  fgColor: <span class="string">'#d6dae5'</span>,     <span class="comment">//未选中的圆的颜色</span></div><div class="line">  bgColor: <span class="string">'#fff'</span>,        <span class="comment">//canvas背景颜色</span></div><div class="line">  n: <span class="number">3</span>, <span class="comment">//圆点的数量： n x n</span></div><div class="line">  innerRadius: <span class="number">20</span>,  <span class="comment">//圆点的内半径</span></div><div class="line">  outerRadius: <span class="number">50</span>,  <span class="comment">//圆点的外半径，focus 的时候显示</span></div><div class="line">  touchRadius: <span class="number">70</span>,  <span class="comment">//判定touch事件的圆半径</span></div><div class="line">  render: <span class="literal">true</span>,     <span class="comment">//自动渲染</span></div><div class="line">  customStyle: <span class="literal">false</span>, <span class="comment">//自定义样式</span></div><div class="line">  minPoints: <span class="number">4</span>,     <span class="comment">//最小允许的点数</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>这样我们实现完整的 Recorder 对象，核心代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div></pre></td><td class="code"><pre><div class="line">[...] <span class="comment">//定义一些私有方法</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> defaultOptions = &#123;</div><div class="line">  container: <span class="literal">null</span>, <span class="comment">//创建canvas的容器，如果不填，自动在 body 上创建覆盖全屏的层</span></div><div class="line">  focusColor: <span class="string">'#e06555'</span>,  <span class="comment">//当前选中的圆的颜色</span></div><div class="line">  fgColor: <span class="string">'#d6dae5'</span>,     <span class="comment">//未选中的圆的颜色</span></div><div class="line">  bgColor: <span class="string">'#fff'</span>,        <span class="comment">//canvas背景颜色</span></div><div class="line">  n: <span class="number">3</span>, <span class="comment">//圆点的数量： n x n</span></div><div class="line">  innerRadius: <span class="number">20</span>,  <span class="comment">//圆点的内半径</span></div><div class="line">  outerRadius: <span class="number">50</span>,  <span class="comment">//圆点的外半径，focus 的时候显示</span></div><div class="line">  touchRadius: <span class="number">70</span>,  <span class="comment">//判定touch事件的圆半径</span></div><div class="line">  render: <span class="literal">true</span>,     <span class="comment">//自动渲染</span></div><div class="line">  customStyle: <span class="literal">false</span>, <span class="comment">//自定义样式</span></div><div class="line">  minPoints: <span class="number">4</span>,     <span class="comment">//最小允许的点数</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Recorder</span></span>&#123;</div><div class="line">  <span class="keyword">static</span> get ERR_NOT_ENOUGH_POINTS()&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">'not enough points'</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">static</span> get ERR_USER_CANCELED()&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">'user canceled'</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">static</span> get ERR_NO_TASK()&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">'no task'</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">constructor</span>(options)&#123;</div><div class="line">    options = <span class="built_in">Object</span>.assign(&#123;&#125;, defaultOptions, options);</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.options = options;</div><div class="line">    <span class="keyword">this</span>.path = [];</div><div class="line"></div><div class="line">    <span class="keyword">if</span>(options.render)&#123;</div><div class="line">      <span class="keyword">this</span>.render();</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  render()&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.circleCanvas) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line"></div><div class="line">    <span class="keyword">let</span> options = <span class="keyword">this</span>.options;</div><div class="line">    <span class="keyword">let</span> container = options.container || <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</div><div class="line"></div><div class="line">    <span class="keyword">if</span>(!options.container &amp;&amp; !options.customStyle)&#123;</div><div class="line">      <span class="built_in">Object</span>.assign(container.style, &#123;</div><div class="line">        position: <span class="string">'absolute'</span>,</div><div class="line">        top: <span class="number">0</span>,</div><div class="line">        left: <span class="number">0</span>,</div><div class="line">        width: <span class="string">'100%'</span>,</div><div class="line">        height: <span class="string">'100%'</span>,</div><div class="line">        lineHeight: <span class="string">'100%'</span>,</div><div class="line">        overflow: <span class="string">'hidden'</span>,</div><div class="line">        backgroundColor: options.bgColor</div><div class="line">      &#125;);</div><div class="line">      <span class="built_in">document</span>.body.appendChild(container); </div><div class="line">    &#125;</div><div class="line">    <span class="keyword">this</span>.container = container;</div><div class="line"></div><div class="line">    <span class="keyword">let</span> &#123;width, height&#125; = container.getBoundingClientRect();</div><div class="line"></div><div class="line">    <span class="comment">//画圆的 canvas，也是最外层监听事件的 canvas</span></div><div class="line">    <span class="keyword">let</span> circleCanvas = <span class="built_in">document</span>.createElement(<span class="string">'canvas'</span>); </div><div class="line"></div><div class="line">    <span class="comment">//2 倍大小，为了支持 retina 屏</span></div><div class="line">    circleCanvas.width = circleCanvas.height = <span class="number">2</span> * <span class="built_in">Math</span>.min(width, height);</div><div class="line">    <span class="keyword">if</span>(!options.customStyle)&#123;</div><div class="line">      <span class="built_in">Object</span>.assign(circleCanvas.style, &#123;</div><div class="line">        position: <span class="string">'absolute'</span>,</div><div class="line">        top: <span class="string">'50%'</span>,</div><div class="line">        left: <span class="string">'50%'</span>,</div><div class="line">        transform: <span class="string">'translate(-50%, -50%) scale(0.5)'</span>, </div><div class="line">      &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//画固定线条的 canvas</span></div><div class="line">    <span class="keyword">let</span> lineCanvas = circleCanvas.cloneNode(<span class="literal">true</span>);</div><div class="line"></div><div class="line">    <span class="comment">//画不固定线条的 canvas</span></div><div class="line">    <span class="keyword">let</span> moveCanvas = circleCanvas.cloneNode(<span class="literal">true</span>);</div><div class="line"></div><div class="line">    container.appendChild(lineCanvas);</div><div class="line">    container.appendChild(moveCanvas);</div><div class="line">    container.appendChild(circleCanvas);</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.lineCanvas = lineCanvas;</div><div class="line">    <span class="keyword">this</span>.moveCanvas = moveCanvas;</div><div class="line">    <span class="keyword">this</span>.circleCanvas = circleCanvas;</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.container.addEventListener(<span class="string">'touchmove'</span>, </div><div class="line">      evt =&gt; evt.preventDefault(), &#123;<span class="attr">passive</span>: <span class="literal">false</span>&#125;);</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.clearPath();</div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">  &#125;</div><div class="line">  clearPath()&#123;</div><div class="line">    <span class="keyword">if</span>(!<span class="keyword">this</span>.circleCanvas) <span class="keyword">this</span>.render();</div><div class="line"></div><div class="line">    <span class="keyword">let</span> &#123;circleCanvas, lineCanvas, moveCanvas&#125; = <span class="keyword">this</span>,</div><div class="line">        circleCtx = circleCanvas.getContext(<span class="string">'2d'</span>),</div><div class="line">        lineCtx = lineCanvas.getContext(<span class="string">'2d'</span>),</div><div class="line">        moveCtx = moveCanvas.getContext(<span class="string">'2d'</span>),</div><div class="line">        width = circleCanvas.width,</div><div class="line">        &#123;n, fgColor, innerRadius&#125; = <span class="keyword">this</span>.options;</div><div class="line"></div><div class="line">    circleCtx.clearRect(<span class="number">0</span>, <span class="number">0</span>, width, width);</div><div class="line">    lineCtx.clearRect(<span class="number">0</span>, <span class="number">0</span>, width, width);</div><div class="line">    moveCtx.clearRect(<span class="number">0</span>, <span class="number">0</span>, width, width);</div><div class="line"></div><div class="line">    <span class="keyword">let</span> range = <span class="built_in">Math</span>.round(width / (n + <span class="number">1</span>));</div><div class="line"></div><div class="line">    <span class="keyword">let</span> circles = [];</div><div class="line"></div><div class="line">    <span class="comment">//drawCircleCenters</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</div><div class="line">      <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</div><div class="line">        <span class="keyword">let</span> y = range * i, x = range * j;</div><div class="line">        drawSolidCircle(circleCtx, fgColor, x, y, innerRadius);</div><div class="line">        <span class="keyword">let</span> circlePoint = &#123;x, y&#125;;</div><div class="line">        circlePoint.pos = [i, j];</div><div class="line">        circles.push(circlePoint);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.circles = circles;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">async</span> cancel()&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.recordingTask)&#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.recordingTask.cancel();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(&#123;<span class="attr">err</span>: <span class="keyword">new</span> <span class="built_in">Error</span>(Recorder.ERR_NO_TASK)&#125;);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">async</span> record()&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.recordingTask) <span class="keyword">return</span> <span class="keyword">this</span>.recordingTask.promise;</div><div class="line"></div><div class="line">    <span class="keyword">let</span> &#123;circleCanvas, lineCanvas, moveCanvas, options&#125; = <span class="keyword">this</span>,</div><div class="line">        circleCtx = circleCanvas.getContext(<span class="string">'2d'</span>),</div><div class="line">        lineCtx = lineCanvas.getContext(<span class="string">'2d'</span>),</div><div class="line">        moveCtx = moveCanvas.getContext(<span class="string">'2d'</span>);</div><div class="line"></div><div class="line">    circleCanvas.addEventListener(<span class="string">'touchstart'</span>, ()=&gt;&#123;</div><div class="line">      <span class="keyword">this</span>.clearPath();</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    <span class="keyword">let</span> records = [];</div><div class="line"></div><div class="line">    <span class="keyword">let</span> handler = <span class="function"><span class="params">evt</span> =&gt;</span> &#123;</div><div class="line">      <span class="keyword">let</span> &#123;clientX, clientY&#125; = evt.changedTouches[<span class="number">0</span>],</div><div class="line">          &#123;bgColor, focusColor, innerRadius, outerRadius, touchRadius&#125; = options,</div><div class="line">          touchPoint = getCanvasPoint(moveCanvas, clientX, clientY);</div><div class="line"></div><div class="line">      <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.circles.length; i++)&#123;</div><div class="line">        <span class="keyword">let</span> point = <span class="keyword">this</span>.circles[i],</div><div class="line">            x0 = point.x,</div><div class="line">            y0 = point.y;</div><div class="line"></div><div class="line">        <span class="keyword">if</span>(distance(point, touchPoint) &lt; touchRadius)&#123;</div><div class="line">          drawSolidCircle(circleCtx, bgColor, x0, y0, outerRadius);</div><div class="line">          drawSolidCircle(circleCtx, focusColor, x0, y0, innerRadius);</div><div class="line">          drawHollowCircle(circleCtx, focusColor, x0, y0, outerRadius);</div><div class="line"></div><div class="line">          <span class="keyword">if</span>(records.length)&#123;</div><div class="line">            <span class="keyword">let</span> p2 = records[records.length - <span class="number">1</span>],</div><div class="line">                x1 = p2.x,</div><div class="line">                y1 = p2.y;</div><div class="line"></div><div class="line">            drawLine(lineCtx, focusColor, x0, y0, x1, y1);</div><div class="line">          &#125;</div><div class="line"></div><div class="line">          <span class="keyword">let</span> circle = <span class="keyword">this</span>.circles.splice(i, <span class="number">1</span>);</div><div class="line">          records.push(circle[<span class="number">0</span>]);</div><div class="line">          <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="keyword">if</span>(records.length)&#123;</div><div class="line">        <span class="keyword">let</span> point = records[records.length - <span class="number">1</span>],</div><div class="line">            x0 = point.x,</div><div class="line">            y0 = point.y,</div><div class="line">            x1 = touchPoint.x,</div><div class="line">            y1 = touchPoint.y;</div><div class="line"></div><div class="line">        moveCtx.clearRect(<span class="number">0</span>, <span class="number">0</span>, moveCanvas.width, moveCanvas.height);</div><div class="line">        drawLine(moveCtx, focusColor, x0, y0, x1, y1);        </div><div class="line">      &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line"></div><div class="line">    circleCanvas.addEventListener(<span class="string">'touchstart'</span>, handler);</div><div class="line">    circleCanvas.addEventListener(<span class="string">'touchmove'</span>, handler);</div><div class="line"></div><div class="line">    <span class="keyword">let</span> recordingTask = &#123;&#125;;</div><div class="line">    <span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</div><div class="line">      recordingTask.cancel = <span class="function">(<span class="params">res = &#123;&#125;</span>) =&gt;</span> &#123;</div><div class="line">        <span class="keyword">let</span> promise = <span class="keyword">this</span>.recordingTask.promise;</div><div class="line"></div><div class="line">        res.err = res.err || <span class="keyword">new</span> <span class="built_in">Error</span>(Recorder.ERR_USER_CANCELED);</div><div class="line">        circleCanvas.removeEventListener(<span class="string">'touchstart'</span>, handler);</div><div class="line">        circleCanvas.removeEventListener(<span class="string">'touchmove'</span>, handler);</div><div class="line">        <span class="built_in">document</span>.removeEventListener(<span class="string">'touchend'</span>, done);</div><div class="line">        resolve(res);</div><div class="line">        <span class="keyword">this</span>.recordingTask = <span class="literal">null</span>;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> promise;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="keyword">let</span> done = <span class="function"><span class="params">evt</span> =&gt;</span> &#123;</div><div class="line">        moveCtx.clearRect(<span class="number">0</span>, <span class="number">0</span>, moveCanvas.width, moveCanvas.height);</div><div class="line">        <span class="keyword">if</span>(!records.length) <span class="keyword">return</span>;</div><div class="line"></div><div class="line">        circleCanvas.removeEventListener(<span class="string">'touchstart'</span>, handler);</div><div class="line">        circleCanvas.removeEventListener(<span class="string">'touchmove'</span>, handler);</div><div class="line">        <span class="built_in">document</span>.removeEventListener(<span class="string">'touchend'</span>, done);</div><div class="line"></div><div class="line">        <span class="keyword">let</span> err = <span class="literal">null</span>;</div><div class="line"></div><div class="line">        <span class="keyword">if</span>(records.length &lt; options.minPoints)&#123;</div><div class="line">          err = <span class="keyword">new</span> <span class="built_in">Error</span>(Recorder.ERR_NOT_ENOUGH_POINTS);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//这里可以选择一些复杂的编码方式，本例子用最简单的直接把坐标转成字符串</span></div><div class="line">        <span class="keyword">let</span> res = &#123;err, <span class="attr">records</span>: records.map(<span class="function"><span class="params">o</span> =&gt;</span> o.pos.join(<span class="string">''</span>)).join(<span class="string">''</span>)&#125;;</div><div class="line"></div><div class="line">        resolve(res);</div><div class="line">        <span class="keyword">this</span>.recordingTask = <span class="literal">null</span>;</div><div class="line">      &#125;;</div><div class="line">      <span class="built_in">document</span>.addEventListener(<span class="string">'touchend'</span>, done);</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    recordingTask.promise = promise;</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.recordingTask = recordingTask;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> promise;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>它的几个公开的方法，recorder 负责记录绘制结果， clearPath 负责在画布上清除上一次记录的结果，cancel 负责终止记录过程，这是为后续流程准备的。</p><h2 id="流程设计"><a href="#流程设计" class="headerlink" title="流程设计"></a>流程设计</h2><p>接下来我们基于 Recorder 来设计设置和验证密码的流程：</p><h3 id="验证密码"><a href="#验证密码" class="headerlink" title="验证密码"></a>验证密码</h3><p><img src="https://p5.ssl.qhimg.com/t01c6fccad2c6c01576.png" alt=""></p><h3 id="设置密码"><a href="#设置密码" class="headerlink" title="设置密码"></a>设置密码</h3><p><img src="https://p4.ssl.qhimg.com/t0122f23e6530a7b6fb.png" alt=""></p><p>有了前面异步 Promise API 的 Recorder，我们不难实现上面的两个流程。</p><h3 id="验证密码的内部流程"><a href="#验证密码的内部流程" class="headerlink" title="验证密码的内部流程"></a>验证密码的内部流程</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">async</span> check(password)&#123;</div><div class="line">  <span class="keyword">if</span>(<span class="keyword">this</span>.mode !== Locker.MODE_CHECK)&#123;</div><div class="line">    <span class="keyword">await</span> <span class="keyword">this</span>.cancel();</div><div class="line">    <span class="keyword">this</span>.mode = Locker.MODE_CHECK;</div><div class="line">  &#125;  </div><div class="line"></div><div class="line">  <span class="keyword">let</span> checked = <span class="keyword">this</span>.options.check.checked;</div><div class="line"></div><div class="line">  <span class="keyword">let</span> res = <span class="keyword">await</span> <span class="keyword">this</span>.record();</div><div class="line"></div><div class="line">  <span class="keyword">if</span>(res.err &amp;&amp; res.err.message === Locker.ERR_USER_CANCELED)&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(res);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">if</span>(!res.err &amp;&amp; password !== res.records)&#123;</div><div class="line">    res.err = <span class="keyword">new</span> <span class="built_in">Error</span>(Locker.ERR_PASSWORD_MISMATCH)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  checked.call(<span class="keyword">this</span>, res);</div><div class="line">  <span class="keyword">this</span>.check(password);</div><div class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(res);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="设置密码的内部流程"><a href="#设置密码的内部流程" class="headerlink" title="设置密码的内部流程"></a>设置密码的内部流程</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">async</span> update()&#123;</div><div class="line">  <span class="keyword">if</span>(<span class="keyword">this</span>.mode !== Locker.MODE_UPDATE)&#123;</div><div class="line">    <span class="keyword">await</span> <span class="keyword">this</span>.cancel();</div><div class="line">    <span class="keyword">this</span>.mode = Locker.MODE_UPDATE;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">let</span> beforeRepeat = <span class="keyword">this</span>.options.update.beforeRepeat, </div><div class="line">      afterRepeat = <span class="keyword">this</span>.options.update.afterRepeat;</div><div class="line"></div><div class="line">  <span class="keyword">let</span> first = <span class="keyword">await</span> <span class="keyword">this</span>.record();</div><div class="line"></div><div class="line">  <span class="keyword">if</span>(first.err &amp;&amp; first.err.message === Locker.ERR_USER_CANCELED)&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(first);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">if</span>(first.err)&#123;</div><div class="line">    <span class="keyword">this</span>.update();</div><div class="line">    beforeRepeat.call(<span class="keyword">this</span>, first);</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(first);   </div><div class="line">  &#125;</div><div class="line"></div><div class="line">  beforeRepeat.call(<span class="keyword">this</span>, first);</div><div class="line"></div><div class="line">  <span class="keyword">let</span> second = <span class="keyword">await</span> <span class="keyword">this</span>.record();      </div><div class="line"></div><div class="line">  <span class="keyword">if</span>(second.err &amp;&amp; second.err.message === Locker.ERR_USER_CANCELED)&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(second);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">if</span>(!second.err &amp;&amp; first.records !== second.records)&#123;</div><div class="line">    second.err = <span class="keyword">new</span> <span class="built_in">Error</span>(Locker.ERR_PASSWORD_MISMATCH);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">this</span>.update();</div><div class="line">  afterRepeat.call(<span class="keyword">this</span>, second);</div><div class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(second);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>可以看到，有了 Recorder 之后，Locker 的验证和设置密码基本上就是顺着流程用 async/await 写下来就行了。</p><h2 id="细节问题"><a href="#细节问题" class="headerlink" title="细节问题"></a>细节问题</h2><p>实际手机触屏时，如果上下拖动，浏览器有默认行为，会导致页面上下移动，需要阻止 touchmove 的默认事件。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.container.addEventListener(<span class="string">'touchmove'</span>, </div><div class="line">      evt =&gt; evt.preventDefault(), &#123;<span class="attr">passive</span>: <span class="literal">false</span>&#125;);</div></pre></td></tr></table></figure></p><p>这里仍然需要注意的一点是， touchmove 事件在 chrome 下默认是一个 <a href="https://dom.spec.whatwg.org/#in-passive-listener-flag" target="_blank" rel="external">Passive Event</a>，因此 addEventListener 的时候需要传参 {passive: false}，否则的话不能 preventDefault。</p><h2 id="工具-amp-工程化"><a href="#工具-amp-工程化" class="headerlink" title="工具 &amp; 工程化"></a>工具 &amp; 工程化</h2><p>因为我们的代码使用了 ES6+，所以需要引入 babel 编译，我们的组件也使用 webpack 进行打包，以便于使用者在浏览器中直接引入。</p><p>这方面的内容，在之前的<a href="https://www.h5jun.com/post/using-webpack2-and-npm-scripts.html" target="_blank" rel="external">博客里有介绍，</a>这里就不再一一说明。</p><p>最后，具体的代码可以直接<a href="https://github.com/akira-cn/handlock" target="_blank" rel="external">查看 GitHub 工程</a>。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上就是今天要讲的全部内容，这里面有几个点我想再强调一下：</p><ol><li>在设计 API 的时候思考真正的需求，判断什么该开放、什么该封装</li><li>做好技术调研和核心方案研究，选择合适的方案</li><li>优化和解决细节问题</li></ol><p>最后，如有任何问题，欢迎大家在下方评论区探讨。</p><p>本文链接：<a href="https://www.h5jun.com/post/handlock-comp.html" target="_blank" rel="external">https://www.h5jun.com/post/handlock-comp.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;纸上得来终觉浅，绝知此事要躬行&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;原文猛戳月影大大博客&lt;a href=&quot;https://www.h5jun.com/post/handlock-comp.html#toc-af9&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;—十年踪迹—-&lt;/a&gt;,读了一遍干货很多，先转过来，后面再慢慢消化。&lt;br&gt;这是&lt;a href=&quot;https://html5.360.cn/star&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;第三届 360 前端星计划&lt;/a&gt;的选拔&lt;a href=&quot;https://www.h5jun.com/post/75team-star-handlock.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;作业题&lt;/a&gt;。600多名学生参与了解答，最后通过了60人。这60名同学完成的不错，思路、代码风格、功能完成度颇有可取之处，不过也有一些欠考虑的地方，比如发现很多同学能按照需求实现完整的功能，但是不知道应当如何&lt;em&gt;设计开放的 API&lt;/em&gt;，或者说，如何分析和预判产品需求和未来的变化，从而决定什么应当开放，什么应当封装。这无关于答案正确与否，还是和经验有关。&lt;br&gt;
    
    </summary>
    
      <category term="编程实战" scheme="https://dsb123dsb.github.io/categories/%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="js" scheme="https://dsb123dsb.github.io/tags/js/"/>
    
      <category term="工程化" scheme="https://dsb123dsb.github.io/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
  </entry>
  
</feed>
