<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>XX雨中人</title>
  
  <subtitle>纸上得来终觉浅，绝知此事要躬行</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://dsb123dsb.github.io/"/>
  <updated>2017-10-28T06:07:21.000Z</updated>
  <id>https://dsb123dsb.github.io/</id>
  
  <author>
    <name>qijiIng</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>http2.0小结</title>
    <link href="https://dsb123dsb.github.io/2017/10/28/http2-0%E5%B0%8F%E7%BB%93/"/>
    <id>https://dsb123dsb.github.io/2017/10/28/http2-0小结/</id>
    <published>2017-10-28T04:35:31.000Z</published>
    <updated>2017-10-28T06:07:21.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>纸上得来终觉浅，觉知此事要躬行</p></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>如今，http1.1是互联网中的主要协议，随着web技术的飞速发展，http1.1已经无法满足用户对性能的要求，此后谷歌推出SPDY,意在解决http1.1中广为人知的性能问题，其在被行业采用并证明能够大幅提升性能后，已经具备了成为一个标准的条件。</p><p>Http2.0是http协议自1999年http1.1发布后的首个更新，主要基于SPDY协议，於2015年正式发表。</p><h1 id="http2-0变化"><a href="#http2-0变化" class="headerlink" title="http2.0变化"></a>http2.0变化</h1><h2 id="二进制分帧"><a href="#二进制分帧" class="headerlink" title="二进制分帧"></a>二进制分帧</h2><p>帧：http2.0数据通信的最小单位。</p><p>消息（message）：指http2.0中逻辑上的http消息。例如请求和响应，消息由一个或多个帧组成。</p><p>流：存在于连接中的一个虚拟通道。流可以承载双向消息，每个流都有一个唯一的证书ID。</p><p>http2.0采用二进制格式传输数据，而非http1x的文本格式，二进制协议解析起来更高效。</p><p>Http1.x的请求和响应报文，都是起始行，首部和整体正文（可选）组成，各部分之间以文本换行符分隔。http2.0将请求和响应数据分割为更小的帧，并且它们采用二进制编码。</p><p>http2.0中，同域名下所有通信都在单个连接上完成（多路复用中介绍），这个连接可以承载任意数量数量的双向数据流。每个数据流都以消息的形式发送，而消息又由一个或多个帧组成。多个帧之间可以乱序发送，因为根据帧首部的流标识可以重新组装。</p><h2 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h2><p>多路复用，代替原来的序列和阻塞机制。所有的请求都是通过==一个TCP==连接并发完成。</p><p>http1.x中，如果想并发多个请求，必须使用多个tcp连接，并且浏览器为了控制资源，还会对单个域名有6-8个数限制，如下图，红色圈出来的请求就因域名链接数超过限制，而被挂起等待了一段时间：</p><p><img src="" alt="http://blog.upyun.com/wp-content/uploads/2017/03/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.png"></p><p>在http2.0中，有了二进制分帧后，就不再依赖TCP连接去实现多流并行了：</p><ul><li>同域名下所用通信都在单个连接上完成</li><li>单个连接可以承载任意数量的双向数据流</li><li>数据流以消息的形式发送，而消息又由一个或多个帧组成，多个帧可以乱序发送，因为根据帧首部的流标识可以重新组装</li></ul><p>这一特性，性能会有极大提升，因为：</p><ul><li>同个域名下只需要占用一个TCP连接，消除了因多个TCP连接而带来的延时和内存消耗</li><li>单个连接上可以并行交错请求和响应，之间互不干扰</li><li>在http2.0中，每个请求都可以带一个31bit的优先值，0表示最高优先级，数值越大优先级越低。有了这个优先值，客户端和服务器就可以在处理不同的流时采取不同的策略，以最优的方式发送流、消息和帧</li></ul><h2 id="服务器推送"><a href="#服务器推送" class="headerlink" title="服务器推送"></a>服务器推送</h2><p>服务端可以在发送页面html时主动推送其它资源，而不用等到浏览器解析到相应位置，发起请求再响应。例如服务端可以主动把js和css文件推送给客户端，而不需要客户端解析html在请求发送这些请求。服务端可以主动送，客户端也有权利选择接收与否，如果服务端推送的资源已经被浏览器缓存过，浏览器可以通过RST_STREAM帧来拒收。主动推送也遵守同源策略，服务端不会随便推送第三方资源给客户端。</p><h2 id="头部压缩"><a href="#头部压缩" class="headerlink" title="头部压缩"></a>头部压缩</h2><p>Http1.1请求的大小变得越来越大，有时甚至会大于TCP窗口的初始大小，因为它们需要等待带着ACK的响应回来以后才能继续发送。http2.0对消息头部采用HACK（专门为http2头部设计的压缩格式）进行压缩传输，能够节省消息头占用的网络流量。而http1.x每次请求，都会携带大量冗余头部信息，浪费很多带宽资源，如果算cookie，增加的负荷会达到上千字节，为了减少开销并且提升性能，http2.0会压缩首部元数据。</p><ul><li>http2.0在客户端和服务端使用“首部表”来跟踪和存储之前发送的键-值对，对于相同的数据，不再通过每次请求和响应发送</li><li>首部表在http2.0的连接存续期内始终存在，由客户端和服务端共同渐进的更新</li><li>每个新的首部键-值对要么被追加到当前表尾部，要么替换表中之前的值</li></ul><p>于是，http2.0连接的两端都知道已经发送了那些首部，这些首部的值是什么，从而针对之前的数据至编码发送这些差异的数据。在通信期间几乎不会改变的键值对只需要发送一次即可，这就大大提高了数据的载荷。</p><p>头部压缩需要客户端和服务端做好以下工作：</p><ul><li>维护一份相同的静态字典（Static Table），包含常见的头部名称，以及特别常见的头部名称和值的组合</li><li>维护一份相同的动态字典（Dynamic Table），可以动态的添加内容</li><li>支持基于静态哈夫曼编码（Huffman Coding）</li></ul><p>静态字典的作用有两个：</p><ol><li>对于完全匹配的头部键值对，可以直接使用一个字符表示</li><li>对于头部名称可以匹配的键值对，可以将名称使用一个字符表示</li></ol><p>哈夫曼编码的核心理念就是使用最少的位数表示最多的信息，HTTP2.0中这份哈夫曼编码表是根据一个大样本的HTTP报头的统计数据生成，经常出现的字符会用较短的二进制数标识，出现频率较低的字符用较长的二进制数标识，这样就保证了综合来看报头信息占用了较少的空间，进一步压缩了报头信息。</p><p>在服务端接收到压缩过的报头信息后，会先进行哈夫曼编码解码，得到报首信息后，再结合维护的静态字典和动态字典信息得出完整的报首信息，随后进行请求的处理和响应。在需要更新动态字典信息时，对字典进行更新。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>向HTTP2.0的迁移不可能瞬间完成，无论服务器端还是客户端都需要进行必要的更新升级才能使用。好消息是，大多数现代浏览器都内置有高效的后台升级机制，对大多数既有用户来说，这些浏览器可以很快的支持HTTP2.0，不会带来很大困扰。然而，服务器端和中间设备的升级、更新就不是那么容易，是一个长期的过程，而且很费力、费钱。</p><p>HTTP1.X至少还会存续十年以上，大多数服务器和客户端在此期间必须同时支持1.x和2.0标准。于是，支持HTTP2.0的客户端在发起新请求之前，必须能发现服务器及中间设备是否支持HTTP2.0协议。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;纸上得来终觉浅，觉知此事要躬行&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;如今，http1.1是互联网中的主要协议
      
    
    </summary>
    
      <category term="基础杂谈" scheme="https://dsb123dsb.github.io/categories/%E5%9F%BA%E7%A1%80%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="http2.0" scheme="https://dsb123dsb.github.io/tags/http2-0/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://dsb123dsb.github.io/2017/10/03/hello-world/"/>
    <id>https://dsb123dsb.github.io/2017/10/03/hello-world/</id>
    <published>2017-10-03T13:53:51.000Z</published>
    <updated>2017-10-03T13:53:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.<br><a id="more"></a></p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;GitHub&lt;/a&gt;.&lt;br&gt;
    
    </summary>
    
      <category term="搭建bog" scheme="https://dsb123dsb.github.io/categories/%E6%90%AD%E5%BB%BAbog/"/>
    
    
      <category term="initial" scheme="https://dsb123dsb.github.io/tags/initial/"/>
    
  </entry>
  
  <entry>
    <title>redux和flux学习</title>
    <link href="https://dsb123dsb.github.io/2017/09/30/redux%E5%92%8Cflux%E5%AD%A6%E4%B9%A0/"/>
    <id>https://dsb123dsb.github.io/2017/09/30/redux和flux学习/</id>
    <published>2017-09-30T03:25:21.000Z</published>
    <updated>2017-10-03T13:53:51.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>纸上得来终觉浅，绝知此事要躬行</p></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>工作虽然一直用react，但是都是现学现用，花了点时间通读《深入react技术栈》，学习笔记略作整理</p><p>传统MVC缺点，在项目越来越大，逻辑越来越复杂时，数据流动变的越来越混乱。<br><img src="https://i.imgur.com/oIfBMk2.png" alt=""><br><a id="more"></a></p><h1 id="Flux-的解决方案"><a href="#Flux-的解决方案" class="headerlink" title="Flux 的解决方案"></a>Flux 的解决方案</h1><p>Flux 的核心思想就是数据和逻辑永远单向流动。<br><strong>flux数据模型</strong><br><img src="https://i.imgur.com/HtXn7dm.png" alt=""></p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>一个 Flux 应用由 3 大部分组成——dispatcher、store 和 view，其中 </p><ol><li>dispatcher 负责分发事件；</li><li>store 负责保存数据，同时响应事件并更新数据；</li><li>view 负责订阅 store 中的数据，并使用这些数据<br>渲染相应的页面</li></ol><p><img src="https://i.imgur.com/1IFv9jz.png" alt=""></p><h2 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h2><ol><li>Flux 的中心化控制。让所有的请求与改变都只能通过 action 发出，统一由 dispatcher 来分配。<ul><li>View 可以保持高度简洁，它不需要关心太多的逻辑，只需要关心传入的数据；</li><li>中心化还控制了所有数据，发生问题时可以方便查询。比起 MVC 架构下数据或逻<br>辑的改动可能来自多个完全不同的源头，Flux 架构追查问题的复杂度和困难度显然要小得多。</li></ul></li><li>Flux 把 action 做了统一归纳，提高了系统抽象程度。不论 action 是由用户触发的，从服务端发起的，还是应用本身的行为，对于我们而言，它都只是一个动作而已。与 MVC 架构下<br>不同的触发方式管理混乱相比，Flux 要优雅许多。<h2 id="flux不足"><a href="#flux不足" class="headerlink" title="flux不足"></a>flux不足</h2></li><li>Flux 的冗余代码太多，Flux 源码中几乎只有 dispatcher的实现，但是在每个应用中都需要手动创建一个 dispatcher 的示例</li><li>Flux 给开发者提供的还是它的思想。Flux 在很大程度上是一种很松散的设计约定，不同的开发者对 Flux 都会有自己的理解<h1 id="redux"><a href="#redux" class="headerlink" title="redux"></a>redux</h1><h2 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h2>Redux 参考了 Flux 的设计，但是对 Flux 许多冗余的部分（如 dispatcher）做了<br>简化，同时将 Elm 语言中函数式编程的思想融合其中。<br><img src="https://i.imgur.com/OzoHXun.png" alt=""><h2 id="Redux-三大原则"><a href="#Redux-三大原则" class="headerlink" title="Redux 三大原则"></a>Redux 三大原则</h2></li><li>单一数据源。 <ul><li>整个应用状态都保存在一个对象中，可以提取出整个应用的状态进行持久化（比如实现一个针对整个应用的即时保存功能）</li><li>也为服务端渲染提供了可能。</li></ul></li><li>状态是只读的。<ul><li>在 Redux 中不会定义一个 store，而是定义一个 reducer，它的功能是根据当前触发的 action 对当前应用的状态（state）进行迭代，这里并没有直接修改应用的状态，而是返回了一份全新的状态。</li><li>Redux 提供的 createStore 方法会根据reducer 生成 store。</li><li>最后，我们可以利用 store. dispatch方法来达到修改状态的目的。</li></ul></li><li>状态修改均由纯函数完成。<ul><li>这是Redux 与Flux 在表现上的最大不同。在 Flux 中，在actionCreator 里调用<br>AppDispatcher.dispatch 方法来触发 action，不仅有冗余的代码，而且因为直接修改了 store 中的数据，导致无法保存每次数据变化前后的状态。</li><li>在 Redux 里，通过定义 reducer 来确定状态的修改，而每一个 reducer 都是纯函数，这意味着它没有副作用，即接受一定的输入，必定会得到一定的输出。<h1 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h1>这里仅对redux和flux的基本知识进行了总结，redux在大型应用的实现后续学习有了深刻体会在做总结</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;纸上得来终觉浅，绝知此事要躬行&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;工作虽然一直用react，但是都是现学现用，花了点时间通读《深入react技术栈》，学习笔记略作整理&lt;/p&gt;
&lt;p&gt;传统MVC缺点，在项目越来越大，逻辑越来越复杂时，数据流动变的越来越混乱。&lt;br&gt;&lt;img src=&quot;https://i.imgur.com/oIfBMk2.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="基础杂谈" scheme="https://dsb123dsb.github.io/categories/%E5%9F%BA%E7%A1%80%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="学习笔记" scheme="https://dsb123dsb.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="react" scheme="https://dsb123dsb.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>携程两个月工作小结</title>
    <link href="https://dsb123dsb.github.io/2017/09/06/%E6%90%BA%E7%A8%8B%E4%B8%A4%E4%B8%AA%E6%9C%88%E5%B7%A5%E4%BD%9C%E5%B0%8F%E7%BB%93/"/>
    <id>https://dsb123dsb.github.io/2017/09/06/携程两个月工作小结/</id>
    <published>2017-09-06T14:41:26.000Z</published>
    <updated>2017-10-03T13:53:51.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>纸上得来终觉浅，绝知此事要躬行</p></blockquote><p>时间过的很快 ，需要放慢脚步来丈量，两个月收获很多，也失去不少</p><h1 id="工作与收获"><a href="#工作与收获" class="headerlink" title="工作与收获"></a>工作与收获</h1><h2 id="软文大赛"><a href="#软文大赛" class="headerlink" title="软文大赛"></a>软文大赛</h2><p>简单的H5页面展示，之前没学过react，利用这个项目，熟悉了react技术栈，能够使用react进行简单页面开发、代码简化。期间也学习了很多技术，大图片快速加载、图片预占位、scss简化代码等</p><h2 id="开通首页兼容性修复"><a href="#开通首页兼容性修复" class="headerlink" title="开通首页兼容性修复"></a>开通首页兼容性修复</h2><p>我们的页面是同时跑在app、微信、和手机浏览器的，发现页面在浏览器会存在拥挤情况，学习了flex布局和hysdk简单使用，使用flex布局使空余空间自动填充，同时考虑在浏览器环境下做专门处理，或者改用滚动布局，思考了很多方案也做了实践</p><h2 id="touchable组件和yo-公共样式"><a href="#touchable组件和yo-公共样式" class="headerlink" title="touchable组件和yo-公共样式"></a>touchable组件和yo-公共样式</h2><p>做这个项目进行项目的组件化和代码复用以及组件源码的学习，养成主动进行项目抽离和阅读源码的习惯。<br>我们页面中使用tuchable组件的地方很多未添加按下态或者按下态不一致，我对组件进行了优化，可进行配置。yo提供了很多封装的现成样式，但是我们代码里基本都是自己写的，没有用到yo封装的样式，通过阅读源码，能使用封装的全部使用，减少代码</p><h2 id="暂停服务公告"><a href="#暂停服务公告" class="headerlink" title="暂停服务公告"></a>暂停服务公告</h2><p>这是完全自己单独写的组件，学习接口设计，展示后端接口返回数据。<br>动画速度和不同字数的计算关系、动画重绘对滚动框影响、动画进入效果优化，动画播放效果优化、flex布局对offsetWidth影响、react生命周期学习，组件的可配置化<br><a id="more"></a></p><h2 id="和第三方app页面交互"><a href="#和第三方app页面交互" class="headerlink" title="和第三方app页面交互"></a>和第三方app页面交互</h2><p>需求是页面需要跳转到另一个页面，然后成功 完成任务后回来，我们页面根据回传参数进行下一步处理，hysdk的学习，app内使用openWebview，期间遇到不同版本app的兼容、h5内直接更换loaction.href, 第三方app通过closeWebview关闭，并且透传参数，通过onreceiveData接收参数，期间调试涉及方面较多，交互逻辑也比较复杂，踩了很多坑。</p><h1 id="后面"><a href="#后面" class="headerlink" title="后面"></a>后面</h1><p>回来需要更加努力学习，基础知识再温习一遍，然后主攻react（进阶知识，高阶组件，redux，源码等）和css，Es6也要温习（promise等）</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;纸上得来终觉浅，绝知此事要躬行&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;时间过的很快 ，需要放慢脚步来丈量，两个月收获很多，也失去不少&lt;/p&gt;
&lt;h1 id=&quot;工作与收获&quot;&gt;&lt;a href=&quot;#工作与收获&quot; class=&quot;headerlink&quot; title=&quot;工作与收获&quot;&gt;&lt;/a&gt;工作与收获&lt;/h1&gt;&lt;h2 id=&quot;软文大赛&quot;&gt;&lt;a href=&quot;#软文大赛&quot; class=&quot;headerlink&quot; title=&quot;软文大赛&quot;&gt;&lt;/a&gt;软文大赛&lt;/h2&gt;&lt;p&gt;简单的H5页面展示，之前没学过react，利用这个项目，熟悉了react技术栈，能够使用react进行简单页面开发、代码简化。期间也学习了很多技术，大图片快速加载、图片预占位、scss简化代码等&lt;/p&gt;
&lt;h2 id=&quot;开通首页兼容性修复&quot;&gt;&lt;a href=&quot;#开通首页兼容性修复&quot; class=&quot;headerlink&quot; title=&quot;开通首页兼容性修复&quot;&gt;&lt;/a&gt;开通首页兼容性修复&lt;/h2&gt;&lt;p&gt;我们的页面是同时跑在app、微信、和手机浏览器的，发现页面在浏览器会存在拥挤情况，学习了flex布局和hysdk简单使用，使用flex布局使空余空间自动填充，同时考虑在浏览器环境下做专门处理，或者改用滚动布局，思考了很多方案也做了实践&lt;/p&gt;
&lt;h2 id=&quot;touchable组件和yo-公共样式&quot;&gt;&lt;a href=&quot;#touchable组件和yo-公共样式&quot; class=&quot;headerlink&quot; title=&quot;touchable组件和yo-公共样式&quot;&gt;&lt;/a&gt;touchable组件和yo-公共样式&lt;/h2&gt;&lt;p&gt;做这个项目进行项目的组件化和代码复用以及组件源码的学习，养成主动进行项目抽离和阅读源码的习惯。&lt;br&gt;我们页面中使用tuchable组件的地方很多未添加按下态或者按下态不一致，我对组件进行了优化，可进行配置。yo提供了很多封装的现成样式，但是我们代码里基本都是自己写的，没有用到yo封装的样式，通过阅读源码，能使用封装的全部使用，减少代码&lt;/p&gt;
&lt;h2 id=&quot;暂停服务公告&quot;&gt;&lt;a href=&quot;#暂停服务公告&quot; class=&quot;headerlink&quot; title=&quot;暂停服务公告&quot;&gt;&lt;/a&gt;暂停服务公告&lt;/h2&gt;&lt;p&gt;这是完全自己单独写的组件，学习接口设计，展示后端接口返回数据。&lt;br&gt;动画速度和不同字数的计算关系、动画重绘对滚动框影响、动画进入效果优化，动画播放效果优化、flex布局对offsetWidth影响、react生命周期学习，组件的可配置化&lt;br&gt;
    
    </summary>
    
      <category term="生活随笔" scheme="https://dsb123dsb.github.io/categories/%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="https://dsb123dsb.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>携程实习小结</title>
    <link href="https://dsb123dsb.github.io/2017/07/30/%E6%90%BA%E7%A8%8B%E5%AE%9E%E4%B9%A0%E5%B0%8F%E7%BB%93/"/>
    <id>https://dsb123dsb.github.io/2017/07/30/携程实习小结/</id>
    <published>2017-07-30T05:57:48.000Z</published>
    <updated>2017-10-03T13:53:51.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>纸上得来终觉浅，绝知此事要躬行</p></blockquote><p>实习后公司学校事情都很多，好久没写点东西，不知不觉月底了，是回顾下总结然后继续去前行的时刻了。</p><h1 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h1><p>本来冲着携程性价比高，不加班来的，事情总是事与愿违，本部门加班简直了，不过还是很高兴学习到了很多哦东西。之前创业公司实习东西要能做出来，后面出问题再改，这里无论是步骤还是流程都更加规范和严格，每次师傅给我review代码都要脱一层皮，感觉自己写的是一坨屎，然后还要和测试review代码，我想象review才是提高和发现错误的契机吧，听闻其他有些部门review代码走过场和没有，更坚定自己好好珍惜这一切，累并快乐着。</p><p>也参加了携程MIT训练营，见了cto，携程能让去哪的人做cto也让人看到了不断加强自身技术导向的意愿，祝好。一起进来的同事们无论积极主动还能力见识都让人侧目。这大概是我们不断奋力向上攀登的魅力吧。</p><h1 id="后面"><a href="#后面" class="headerlink" title="后面"></a>后面</h1><p>很多公司的秋招提前批也开始了，不管未来会不会呆在这里，这是一段美好的旅程，留下一段美好的回忆。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;纸上得来终觉浅，绝知此事要躬行&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;实习后公司学校事情都很多，好久没写点东西，不知不觉月底了，是回顾下总结然后继续去前行的时刻了。&lt;/p&gt;
&lt;h1 id=&quot;收获&quot;&gt;&lt;a href=&quot;#收获&quot; class=&quot;he
      
    
    </summary>
    
      <category term="生活随笔" scheme="https://dsb123dsb.github.io/categories/%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="https://dsb123dsb.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>Flow-JS静态类型检查工具</title>
    <link href="https://dsb123dsb.github.io/2017/06/25/Flow-JS%E9%9D%99%E6%80%81%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5%E5%B7%A5%E5%85%B7/"/>
    <id>https://dsb123dsb.github.io/2017/06/25/Flow-JS静态类型检查工具/</id>
    <published>2017-06-25T12:08:37.000Z</published>
    <updated>2017-10-03T13:53:51.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>纸上得来终觉浅，绝知此事要躬行</p></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近学习vue源码看到下面代码</p><p><img src="http://i.imgur.com/iNBVV3k.png" alt=""></p><p>心里不由WTF,查了下原来是flow代码,就立马去<a href="https://flow.org/en/docs/" target="_blank" rel="external">官网把flow文档</a>撸了一遍，网上又找了几遍文章，做下总结<br><a id="more"></a></p><p>先看下简介</p><p><img src="https://segmentfault.com/img/bVH6mL?w=1200&amp;h=675" alt=""></p><p>Flow本质上也只是个检查工具，它并不会自动修正代码中的错误，也不会强制说你没按照它的警告消息修正，就不会让你运行程序。当然，并没有要求什么时候一定要用这类的工具，只是这种作法可以让你的代码更具强健性与提高阅读性，也可以直接避去很多不必要的数据类型使用上的问题，这种开发方式目前在许多框架与函数库项目，或是以JavaScript应用为主的开发团队中都已经都是必用工具。</p><ul><li>由于Flow还是个年轻的项目，问题仍然很多，功能也没你想像中完整，用起来有时候会卡顿是正常的，效能仍须改善。以后用户愈来愈多就会愈作愈好。</li><li>Windows平台的支持也是不久前(2016.8)时的事，Flow只支持64位元的作业系统，32位元就不能用了。</li><li>如果你是要学或用React或Vue.js等等，Flow是必学的。不管你要用不用，库源码里面都用了。</li></ul><h1 id="Flow介绍"><a href="#Flow介绍" class="headerlink" title="Flow介绍"></a>Flow介绍</h1><p><a href="https://flowtype.org/" target="_blank" rel="external">Flow</a>是个JavaScript的静态类型检查工具，由Facebook出品的开源码项目，问世只有一年多，是个相当年轻的项目。简单来说，它是对比TypeScript语言的解决方式。</p><p>会有这类解决方案，起因是JavaScript是一种弱(动态)数据类型的语言，弱(动态)数据类型代表在代码中，变量或常量会自动依照赋值变更数据类型，而且类型种类也很少，这是直译式脚本语言的常见特性，但有可能是优点也是很大的缺点。优点是容易学习与使用，缺点是像开发者经常会因为赋值或传值的类型错误，造成不如预期的结果。有些时候在使用框架或函数库时，如果没有仔细看文件，亦或是文件写得不清不楚，也容易造成误用的情况。</p><p>这个缺点在应用规模化时，会显得更加严重。我们在开发团队的协同时，一般都是用详尽的文字说明，来降低这个问题的发生，但JS语言本身无法有效阻止这些问题。而且说明文件也需要花时间额外编写，其他的开发者阅读也需要花时间。在现今预先编译器流行的年代，像TypeScript这样的强(静态)类的JavaScript超集语言就开始流行，用严格的角度，以JavaScript语言为基底，来重新打造另一套具有强(静态)类型特性的语言，就如同Java或C#这些语言一样，这也是为什么TypeScript称自己是企业级的开发JavaScript解决方案。</p><blockquote><p>注: 强(静态)类型语言，意思是可以让变量或常量在声明(定义)时，就限制好只能使用哪种类型，之后在使用时如果发生类型不相符时，就会发出错误警告而不能编译。但不只这些，语言本身也会拓展了更多的类型与语法。</p></blockquote><p>TypeScript自然有它的市场，但它有一些明显的问题，首先是JavaScript开发者需要再进一步学习，内容不少，也有一定陡峭的学习曲线，不过这还算小事情。重大的事情是需要把已经在使用的应用代码，都要整个改用TypeScript代码语法，才能发挥完整的功用。这对很多已经有内部代码库的大型应用开发团队而言，将会是个重大的决定，因为如果不往全面重构的路走，将无法发挥强(静态)类型语言的最大效用。</p><p>所以许多现行的开源码函数库或框架，并不会直接使用TypeScript作为代码的语言，另一方面当然因为是TypeScript并非普及到一定程度的语言，社群上有热爱的粉丝也有不是那么支持的反对者。当然，TypeScript也有它的优势，自从TypeScript提出了DefinitelyTyped的解决方式之后，让现有的函数库能额外再定义出里面使用的类型，这也是另一个可以与现有框架与库相整合的方案，这让许多函数库与框架都提交定义档案，提供了另一种选择。另一个优势是，TypeScript也是个活跃的开源码项目，发展到现在也有一段时间，算是逐渐成熟的项目。它的背后有微软公司的支持，在最近发布的知名的、全新打造过的Angular2框架中(由Google主导)，也采用了TypeScript作为基础的开发语言。</p><p>现在，Flow提供了另一个新的选项，它是一种强(静态)类型的辅助检查工具。Flow的功能是让现有的JavaScript语法可以事先作类型的声明(定义)，在开发过程中进行自动检查，当然在最后编译时，一样可以用babel工具来移除这些标记。</p><p>相较于TypeScript是另外重新制定一套语言，最后再经过编译为JavaScript代码来运行。Flow走的则是非强制与非侵入性的路线。Flow的优点是易学易用，它的学习曲线没有TypeScript来得高，虽然内容也很多，但大概一天之内学个大概，就可以渐进式地开始使用。而且因为Flow从头到尾只是个检查工具，并不是新的程序语言或超集语言，所以它可以与各种现有的JavaScript代码兼容，如果你哪天不想用了，就去除掉标记就是回到原来的代码，没什么负担。当然，Flow的功用可能无法像TypeScript这么全面性，也不可能改变要作某些事情的语法结构。</p><p>总结来说，这两种方式的目的是有些相似的，各自有优点也有不足之处，青菜萝卜各有所爱，要选择哪一种方式就看你的选择。</p><h1 id="从一个小例子演示"><a href="#从一个小例子演示" class="headerlink" title="从一个小例子演示"></a>从一个小例子演示</h1><p>这种类型不符的情况在代码中非常容易发生，例如以下的例子:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> x + <span class="number">10</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">foo(<span class="string">'Hello!'</span>)</div></pre></td></tr></table></figure></p><p>x这个传参，我们在函数声明时希望它是个数字类型，但最后使用调用函数时则用了字符串类型。最后的结果会是什么吗？ “Hello!10”，这是因为加号(+)在JavaScript语言中，除了作为数字的加运算外，也可以当作字符串的连接运算。想当然这并不是我们想要的结果。</p><p>聪明如你应该会想要用类型来当传参的识别名，容易一眼看出传参要的是什么类型，像下面这样:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">number</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> number + <span class="number">10</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>但如果在复合类型的情况，例如这个传参的类型可以是数字类型也可以是布尔类型，你又要如何写得清楚？更不用说如果是个复杂的对象类型时，结构又该如何先确定好？另外还有函数的返回类型又该如何来写？</p><p>利用Flow类型的定义方式，来解决这个小案例的问题，可以改写为像下面的代码:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// @flow</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x: number</span>): <span class="title">number</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> x + <span class="number">10</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">foo(<span class="string">'hi'</span>)</div></pre></td></tr></table></figure></p><p>你有看到在函数的传参，以及函数的圆括号(())后面的两个地方，加了: number标记，这代表这个传参会限定为数字类型，而返回值也只允许是数字类型。</p><p>当使用非数字类型的值作为传入值时，就会出现由Flow工具发出的警告消息，像下面这样:</p><blockquote><p>message: ‘[flow] string (This type is incompatible with number See also: function call)’</p></blockquote><p>这消息是说，你这函数的传参是string(字符串)类型，与你声明的number(数字)不相符合。</p><p>如果是要允许多种类型也是很容易可以加标记的，假使这个函数可以使用布尔与数字类型，但返回可以是数字或字符串，就像下面这样修改过:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// @flow</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x: number | boolean</span>): <span class="title">number</span> | <span class="title">string</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">'number'</span>) &#123;</div><div class="line">    <span class="keyword">return</span> x + <span class="number">10</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="string">'x is boolean'</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">foo(<span class="number">1</span>)</div><div class="line">foo(<span class="literal">true</span>)</div><div class="line">foo(<span class="literal">null</span>)  <span class="comment">// 这一行有类型错误消息</span></div></pre></td></tr></table></figure></p><p>由上面这个小例子你可以想见，如果在多人协同开发某个有规模的JavaScript应用时，这种类型的输出输入问题就会很常遇见。如果利用Flow工具的检查，可以避免掉许多不必要的类型问题。</p><h1 id="真实案例"><a href="#真实案例" class="headerlink" title="真实案例"></a>真实案例</h1><p>可能你会认为Flow工具只能运用在小型代码中，但实际上Facebook会创造出Flow工具，有很大的原因是为了React与React Native。</p><p>举一个我最近正在研究的的函数库代码中<a href="https://github.com/facebook/react-native/blob/9ee815f6b52e0c2417c04e5a05e1e31df26daed2/Libraries/NavigationExperimental/NavigationTypeDefinition.js" target="_blank" rel="external">NavigationExperimental</a>(这网址位置有可能会变，因为是直接连到源码里)，这里面就预先声明了所有的对象结构，像下面这样的代码:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> type NavigationGestureDirection = <span class="string">'horizontal'</span> | <span class="string">'vertical'</span>;</div><div class="line"></div><div class="line"><span class="keyword">export</span> type NavigationRoute = &#123;</div><div class="line">  key: string,</div><div class="line">  title?: string</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">export</span> type NavigationState = &#123;</div><div class="line">  index: number,</div><div class="line">  routes: <span class="built_in">Array</span>&lt;NavigationRoute&gt;,</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// ...</span></div></pre></td></tr></table></figure></p><p>Flow具备有像TypeScript语言中，预先定义对象类型的作用。上面代码的都是这个组件中预先定义的类型，这些类型可以再套用到不同的代码文档之中。</p><pre><code>export type NavigationGestureDirection = &apos;horizontal&apos; | &apos;vertical&apos;;</code></pre><p>上面这行类似于列举(enum)的类型，意思是说要不就是’horizontal’(水平的)，要不然就’vertical’(垂直的)，就这两种字符串值可使用。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> type NavigationRoute = &#123;</div><div class="line">  key: string,</div><div class="line">  title?: string</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>这行里面用了一个问号(?)定义在title属性的后面，这代表这属性是可选的(Optional)，不过你可能会有点搞混，因为问号(?)可以放在两个位置，见下面的例子:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> type Test = &#123;</div><div class="line">  titleOne?: string,</div><div class="line">  titleTwo: ?string</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>titleOne代表的是属性为可自定义的(可有可无)，但一定是字符串类型。titleTwo代表的是类型可自定义，也就是值的部份除了定义的类型，也可以是null或undefined，不过这属性是需要的，而且你一定要给它一个值。好的，这有些太细部了，如果有用到再查手册文档就可以。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">export type NavigationState = &#123;</div><div class="line">  index: number,</div><div class="line">  routes: Array&lt;NavigationRoute&gt;,</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>上面的代码可以看到，只要是声明过的类型(type)，同样可以拿来拿在其他类型中套用，像这里的<code>Array&lt;NavigationRoute&gt;</code>，就是使用了上面已声明的NavigationRoute类型。它是一个数组，里面放的成员是NavigationRoute类型，是个对象的结构。</p><p>刚已经有说过Flow工具有很大的原因是为了React与React Native所设计，因为Flow本身就内建对PropTypes的检查功能，也可以正确检查JSX语法，在这篇官方文档中有说明，而这在之后介绍React的文档的例子中就可以看到。</p><h1 id="安装与使用"><a href="#安装与使用" class="headerlink" title="安装与使用"></a>安装与使用</h1><p>Flow目前可以支持macOS、Linux(64位元)、Windows(64位元)，你可以从以下的四种安装方式选择其中一种:</p><p>直接从Flow的发布页面下载可运行档案，加到计算机中的PATH(路径)，让flow指令可以在命令列窗口访问即可。<br>透过npm安装即可，可以安装在全局(global)或是各别项目中。下面为安装在项目中的指令:</p><pre><code>npm install --save-dev flow-bin</code></pre><p>macOS中可以使用homebrew安装:</p><pre><code>brew updatebrew install flow</code></pre><p>透过OCaml OPAM套装管理程序打包与安装，请见<a href="https://github.com/facebook/flow" target="_blank" rel="external">Flow的Github页面</a>。</p><h1 id="Flow简单使用三步骤"><a href="#Flow简单使用三步骤" class="headerlink" title="Flow简单使用三步骤"></a>Flow简单使用三步骤</h1><h2 id="第1步-初始化项目"><a href="#第1步-初始化项目" class="headerlink" title="第1步: 初始化项目"></a>第1步: 初始化项目</h2><p>在你的项目根目录的用命令列工具输入下面的指令，这将会创建一个<code>.flowconfig</code>文档，如果这文档已经存在就不需要再进行初始化，这个设置档一样是可以加入自定义的设置值，请参考<a href="https://flowtype.org/docs/advanced-configuration.html" target="_blank" rel="external">Advanced Configuration</a>这里的说明，目前有很多项目里面都已经内附这个设置档，例如一些React的项目:</p><pre><code>flow init</code></pre><h2 id="第2步-在代码文档中加入要作类型检查的注释"><a href="#第2步-在代码文档中加入要作类型检查的注释" class="headerlink" title="第2步: 在代码文档中加入要作类型检查的注释"></a>第2步: 在代码文档中加入要作类型检查的注释</h2><p>一般都在代码档案的最上面一行加入，没加Flow工具是不会进行检查的，有两种格式都可以:</p><pre><code>// @flow</code></pre><p>或</p><pre><code>/* @flow */</code></pre><h2 id="第3步-进行检查"><a href="#第3步-进行检查" class="headerlink" title="第3步: 进行检查"></a>第3步: 进行检查</h2><p>目前支持Flow工具插件的代码编辑工具很多，常见的Atom, Visual Studio Code(VSC), Sublime与WebStorm都有，当有安装搭配代码编辑工具的插件时，编辑工具会辅助显示检查的讯息。不过有时候会有点卡顿的要等一下，因为检查速度还不是那么快。</p><p>或是直接用下面的命令列指令来进行检查:</p><pre><code>flow check</code></pre><p>在Visual Studio Code中因为它内建TypeScript与JavaScript的检查功能，如果要使用Flow工具来作类型检查，需要在用户设置中，加上下面这行设置值以免冲突:</p><pre><code>&quot;javascript.validate.enable&quot;: false</code></pre><h1 id="转换-编译-有Flow标记的代码"><a href="#转换-编译-有Flow标记的代码" class="headerlink" title="转换(编译)有Flow标记的代码"></a>转换(编译)有Flow标记的代码</h1><blockquote><p>注: 有些脚手架就已经装好与设置好这个babel拓展插件，你不用再多安装了。</p></blockquote><p>在开发的最后阶段要将原本有使用Flow标记，或是有类型注释的代码，进行清除或转换。转换的工作要使用babel编译器，这也是目前较推荐的方式。</p><p>使用babel编译器如果以命令列工具为主，可以使用下面的指令来安装在全局中:</p><pre><code>npm install -g babel-cli</code></pre><p>再来加装额外移除Flow标记的npm套件<code>babel-plugin-transform-flow-strip-types</code>在你的项目中:</p><pre><code>npm install --save-dev babel-plugin-transform-flow-strip-types</code></pre><p>然后创建一个<code>.babelrc</code>设置档案，档案内容如下:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="string">"plugins"</span>: [</div><div class="line">    <span class="string">"transform-flow-strip-types"</span></div><div class="line">  ]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>完成设置后，之后babel在编译时就会一并转换Flow标记。</p><p>下面的指令则是直接把src目录的档案编译到dist目录中:</p><pre><code>babel src -d dist</code></pre><p>当然，babel的使用方式不是只有上面说的这种命令列指令，你可以视项目的使用情况来进行设置。</p><h1 id="Flow支持的数据类型"><a href="#Flow支持的数据类型" class="headerlink" title="Flow支持的数据类型"></a>Flow支持的数据类型</h1><p>Flow用起来是的确是简单，但里面的内容很多，主要原因是是要看实际不同的使用情况作搭配。JavaScript里面的原始数据类型都有支持，而在函数、对象与一些新的ES6中的类，在搭配使用时就会比较复杂，详细的情况就请到官网文档中观看，以下只能提供一些简单的介绍说明。</p><h2 id="原始数据类型"><a href="#原始数据类型" class="headerlink" title="原始数据类型"></a>原始数据类型</h2><p>Flow支持原始数据类型，如下面的列表:</p><ul><li>boolean</li><li>number</li><li>string</li><li>null</li><li>void</li></ul><p>其中的void类型，它就是JS中的<code>undefined</code>类型。</p><p>这里可能要注意的是，在JS中<code>undefined</code>与<code>null</code>的值会相等但类型不同，意思是作值相等比较时，像(<code>undefined == null</code>)时会为<code>true</code>，有时候在一些运行期间的检查时，可能会用值相等比较而不是严格的相等比较，来检查这两个类型的值。</p><p>所有的类型都可以使用垂直线符号(|)作为联合使用(也就是 OR 的意思)，例如<code>string | number</code>指的是两种类型其中一种都可使用，这是一种联合的类型，称为”联合(Union)类型”。</p><p>最特别的是可选的(Optional)类型的设计，可选类型代表这个变量或常量的值有可能不存在，也就是允许它除了是某个类型的值外，也可以是<code>null</code>或<code>undefined</code>值。要使用可选类型，就是在类型名称定义前加上问号(?)，例如?string这样，下面是一个简单的例子:</p><pre><code>let bar: ?string = null</code></pre><h2 id="字面文字-literal-类型"><a href="#字面文字-literal-类型" class="headerlink" title="字面文字(literal)类型"></a>字面文字(literal)类型</h2><p>字面文字类型指的是以真实值作为数据类型，可用的值有三种，即数字、字符串或布尔值。字面文字类型搭配联合的类型可以作为列举(enums)来使用，例如以下的一个扑克牌的类型例子:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">type Suit =</div><div class="line">  | <span class="string">"Diamonds"</span></div><div class="line">  | <span class="string">"Clubs"</span></div><div class="line">  | <span class="string">"Hearts"</span></div><div class="line">  | <span class="string">"Spades"</span>;</div><div class="line"></div><div class="line">type Rank =</div><div class="line">  | <span class="number">2</span> | <span class="number">3</span> | <span class="number">4</span> | <span class="number">5</span> | <span class="number">6</span> | <span class="number">7</span> | <span class="number">8</span> | <span class="number">9</span> | <span class="number">10</span></div><div class="line">  | <span class="string">"Jack"</span></div><div class="line">  | <span class="string">"Queen"</span></div><div class="line">  | <span class="string">"King"</span></div><div class="line">  | <span class="string">"Ace"</span>;</div><div class="line"></div><div class="line">type Card = &#123;</div><div class="line">  suit: Suit,</div><div class="line">  rank: Rank,</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><blockquote><p>注: type是Flow中定义类型别名(Type Alias)的关键字，是一种预先声明的类型，这些声明的标记一样只会在开发阶段中使用，最后编译去除。</p></blockquote><h2 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h2><p>类型别名(Type Alias)提供了可以预先定义与集中代码中所需要的类型，一个简单的例子如下:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">type T = <span class="built_in">Array</span>&lt;string&gt;</div><div class="line"><span class="keyword">var</span> x: T = []</div><div class="line">x[<span class="string">"Hi"</span>] = <span class="number">2</span> <span class="comment">//有Flow警告</span></div></pre></td></tr></table></figure></p><p>类型别名(Type Alias)也可以用于复杂的应用情况，详见Flow官网提供的<a href="https://flowtype.org/docs/type-aliases.html" target="_blank" rel="external">Type Aliases</a>内容。</p><h2 id="任何的数据类型"><a href="#任何的数据类型" class="headerlink" title="任何的数据类型"></a>任何的数据类型</h2><p>在某一些情况可能不需要定义的太过于严格，或是还在开发中正在调试时，有一种作为渐进的改善代码的类型。</p><p>Flow提供了两种特殊的类型可以作为松散的数据类型定义:</p><ul><li>any: 相当于不检查。既是所有类型的超集(supertype)，也是所有类型的子集(subtype)</li><li>mixed: 类似于any是所有类型的超集(supertype)，但不同于any的是，它不是所有类型的子集(subtype)</li></ul><p><code>mixed</code>是一个特别的类型，中文是混合的意思，<code>mixed</code>算是any的”啰嗦”进化类型。mixed用在函数的输入(传参)与输出(返回)时，会有不一样的状态，例如以下的例子会出现警告:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x: mixed</span>): <span class="title">string</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> x + <span class="string">'10'</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">foo(<span class="string">'Hello!'</span>)</div><div class="line">foo(<span class="number">1</span>)</div></pre></td></tr></table></figure></p><blockquote><p>会出现警告消息如下:<br>[flow] mixed (Cannot be added to string)</p></blockquote><p>这原因是虽然输入时可以用<code>mixed</code>，但Flow会认为函数中x的值不见得可以与string类型作相加，所以会请求你要在函数中的代码，要加入检查对传入类型在运行期间的类型检查代码，例如像下面修改过才能过关:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x: mixed</span>): <span class="title">string</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">'number'</span> || <span class="keyword">typeof</span> x === <span class="string">'string'</span>) &#123;</div><div class="line">    <span class="keyword">return</span> x + <span class="string">'10'</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Invalid x type'</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line">foo(<span class="string">'Hello!'</span>)</div><div class="line">foo(<span class="number">1</span>)</div></pre></td></tr></table></figure></p><p><code>mixed</code>虽然”啰嗦”，但它是用来渐进替换any使用的，有时候往往开发者健忘或偷懒没作传入值在运行期间的类型检查，结果后面要花更多的时间才能找出错误点，这个类型的设计大概是为了提早预防这样的情况。</p><blockquote><p>注: 从上面的例子可以看到Flow除了对类型会作检查外，它也会请求对某些类型需要有动态的检查。在官方的文件可以参考<a href="https://flowtype.org/docs/dynamic-type-tests.html#_" target="_blank" rel="external">Dynamic Type Tests</a>这个章节。</p></blockquote><h2 id="复合式的数据类型"><a href="#复合式的数据类型" class="headerlink" title="复合式的数据类型"></a>复合式的数据类型</h2><p>数组(Array)</p><p>数组类型使用的是<code>Array&lt;T&gt;</code>，例如<code>Array&lt;number&gt;</code>，会限定数组中的值只能使用数字的数据类型。当然你也可以加入埀直线(|)来定义允许多种类型，例如<code>Array&lt;number|string&gt;</code>。</p><p>对象(Object)</p><p>对象类型会比较麻烦，主要原因是在JavaScript中所有的数据类型大概都可以算是对象，就算是基础数据类型也有对应的包装对象，再加上有个异常的null类型的typeof返回值也是对象。</p><p>对象类型在Flow中的使用，基本上要分作两大部份来说明。</p><p>第一种是单指Object这个类型，Flow会判断所有的基础数据类<strong>不是</strong>属于这个类型的，以下的例子全部都会有警告:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 以下都有Flow警告</span></div><div class="line"></div><div class="line">(<span class="number">0</span>: <span class="built_in">Object</span>);</div><div class="line">(<span class="string">""</span>: <span class="built_in">Object</span>);</div><div class="line">(<span class="literal">true</span>: <span class="built_in">Object</span>);</div><div class="line">(<span class="literal">null</span>: <span class="built_in">Object</span>);</div><div class="line">(<span class="literal">undefined</span>: <span class="built_in">Object</span>);</div></pre></td></tr></table></figure></p><p>其他的复合式数据类型，除了数组之外，都会认为是对象类型。如下面的例子:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">(&#123;<span class="attr">foo</span>: <span class="string">"foo"</span>&#125;: <span class="built_in">Object</span>);</div><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;: <span class="built_in">Object</span>);</div><div class="line">(<span class="class"><span class="keyword">class</span> </span>&#123;&#125;: <span class="built_in">Object</span>);</div><div class="line">([]: <span class="built_in">Object</span>); <span class="comment">// Flow不认为数组是属于对象</span></div></pre></td></tr></table></figure></p><blockquote><p>注意: 上面有两个特例，<code>typeof null</code>typeof与<code>typeof []</code>都是返回’object’。也就是说在JS的标准定义中，<code>null</code>与<code>数组</code>用``检测都会返回对象类型。所以，Flow工具的检查会与JS预设并不相同，这一点要注意。</p><p>注: typeof在Flow中有一些另外的用途，详见Typeof的说明。</p></blockquote><p>第二种方式是要定义出完整的对象的字面文字结构，像<code>{ x1: T1; x2: T2; x3: T3;}</code>的语法，用这个结构来检查，以下为例子:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> object: &#123;<span class="attr">foo</span>: string, <span class="attr">bar</span>: number&#125; = &#123;<span class="attr">foo</span>: <span class="string">"foo"</span>, <span class="attr">bar</span>: <span class="number">0</span>&#125;;</div><div class="line"></div><div class="line">object.foo = <span class="number">111</span>; <span class="comment">//Flow警告</span></div><div class="line">object.bar = <span class="string">'111'</span>; <span class="comment">//Flow警告</span></div></pre></td></tr></table></figure></p><p>函数(Function)</p><p>上面已经有看到，函数也属于对象(Object)类型，当然也有自己的<code>Function</code>类型，函数的类型也可以从两大部份来看。</p><p>第一是单指<code>Function</code>这个类型，可以用来定义变量或常量的类型。如下面的代码例子:</p><pre><code>var anyFunction: Function = () =&gt; {};</code></pre><p>第二指的是函数中的用法，上面已经有看到函数的输出(返回值)与输入(传参)的用法例子。例如以下的例子:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x: number</span>): <span class="title">number</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> x + <span class="number">10</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>因为函数有很多种不同的使用情况，实际上可能会复杂很多，Flow工具可以支持目前最新的arrow functions、async functions与generator functions，详见<a href="https://flowtype.org/docs/functions.html" target="_blank" rel="external">官方的这篇Functions</a>的说明。</p><p>类(Class)</p><p>类是ES6(ES2015)中新式的特性，类目前仍然只是原型的语法糖，类本身也属于一种对象(Object)类型。类的使用情况也可能会复杂，尤其是涉及多型与实例的情况，详见Flow网站提供的<a href="https://flowtype.org/docs/classes.html" target="_blank" rel="external">Classes</a>内容。</p><h1 id="Flow的现在与未来的发展"><a href="#Flow的现在与未来的发展" class="headerlink" title="Flow的现在与未来的发展"></a>Flow的现在与未来的发展</h1><p>Flow在<a href="https://flowtype.org/blog/2016/10/13/Flow-Typed.html" target="_blank" rel="external">最近的博客</a>中说明引入了<code>flow-typed</code>的函数库定义档(“libdefs”)，在这个Github存储库中将统一存放所有来自社群提供的函数库定义档案。这是一种可以让现有的函数库与框架，预先写出里面使用的类型定义。让项目里面有使用Flow工具与这些函数库，就可以直接使用这些定义档，以此结合现有的函数库与框架来使用。这个作法是参考TypeScript的DefinitelyTyped方式。因为这还是很新的消息(2016.10)，目前加入的函数库还没有太多，不过React周边的一些函数库或组件都已经开始加入，其他常用的像underscore、backbone或lodash也已经有人在提交或维护。</p><p>Flow另一个发展会是在开发工具的自动完成功能的改进，因为如果已经能在撰写代码时，就知道变量或常量的类型(静态类型)，那么在自动完成功能中就可以更准确地给出可用的属性或方法。这一个功能在Facebook自家的Nuclide开发工具的Flow说明页中就有看到。Nuclide是基于Atom开发工具之上的工具，计算机硬件如果不够力是跑不动的，而且它稳定性与运行速度都还需要再努力。这大概是未来可见到的一些新趋向。</p><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>本文简单的说明了Flow工具的功能介绍，以及其中的一些简要的内容等等。相信看过后你已经对这个Flow工具有一些认识，相较于T<strong>ypeScript的学习曲线**</strong>，Flow大概是等于不用学**。Flow虽然是一个很新的工具，但相当的有用，建议每个JavaScript开发者都可以试试，一开始不用学太多，大概这篇文档看完就可以开始用了。复杂的地方就再查找官方的文件即可。</p><p>对于每个正在使用JS开发稍具规模化的应用，或是开发开源码的函数库或框架的团队来说，让JS具有静态类型特性，是一个很重要而且必要的决定。以我的观察，在网络上一直有很多的超集语言(例如TypeScript)的爱好者，会提出要全面改用TypeScript(或其他超集语言)的声音，例如Vue.js在很早之前就有讨论是不是要全面采用TypeScript的声音。后来Vue.js只有提交TypeScript的<a href="https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/vue" target="_blank" rel="external">DefinitelyTyped</a>文档，但在2.0中则采行了Flow工具。在这篇Vue作者于知乎上发表的: <a href="https://www.zhihu.com/question/46397274" target="_blank" rel="external">Vue 2.0 为什么选用 Flow 进行静态代码检查而不是直接使用 TypeScript？</a>的内容中，你可以看到为何选择Flow的理由，这可能也是整个开发团队所认同的最后结果。作者回答的文中可以总结下面这句话:</p><blockquote><p>全部换 TS(TypeScript) 成本过高，短期内并不现实。 相比之下 Flow 对于已有的 ES2015 代码的迁入/迁出成本都非常低 … 万一哪天不想用 Flow 了，转一下，就得到符合规范的 ES。<br>总之，Flow提供了另一个选择，要用什么工具就看聪明的你如何选择了。</p></blockquote><p><a href="https://segmentfault.com/a/1190000008088489?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="external">参考文章地址 https://segmentfault.com/a/1190000008088489?utm_source=tuicool&amp;utm_medium=referral</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;纸上得来终觉浅，绝知此事要躬行&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近学习vue源码看到下面代码&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/iNBVV3k.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;心里不由WTF,查了下原来是flow代码,就立马去&lt;a href=&quot;https://flow.org/en/docs/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;官网把flow文档&lt;/a&gt;撸了一遍，网上又找了几遍文章，做下总结&lt;br&gt;
    
    </summary>
    
      <category term="tools" scheme="https://dsb123dsb.github.io/categories/tools/"/>
    
    
      <category term="js" scheme="https://dsb123dsb.github.io/tags/js/"/>
    
      <category term="flow" scheme="https://dsb123dsb.github.io/tags/flow/"/>
    
  </entry>
  
  <entry>
    <title>浅谈JS实现私有成员</title>
    <link href="https://dsb123dsb.github.io/2017/06/20/%E6%B5%85%E8%B0%88JS%E5%AE%9E%E7%8E%B0%E7%A7%81%E6%9C%89%E6%88%90%E5%91%98/"/>
    <id>https://dsb123dsb.github.io/2017/06/20/浅谈JS实现私有成员/</id>
    <published>2017-06-20T11:44:38.000Z</published>
    <updated>2017-10-03T13:53:51.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>纸上得来终觉浅，绝知此事要躬行</p></blockquote><h1 id="name形式私有"><a href="#name形式私有" class="headerlink" title="_name形式私有"></a>_name形式私有</h1><p>ES6 中有类语法，定义类变得简单了<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(name) &#123;</div><div class="line">        <span class="keyword">this</span>._name = name;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    get name() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._name;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>然而，并没有提供私有属性。比如上面的 Person 其实是希望在构造的时候传入 name，之后不允许修改了。不过，由于没有私有属性，所以难免有人会这样干：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Person james = <span class="keyword">new</span> Person(<span class="string">"James"</span>);</div><div class="line">james._name = <span class="string">"Tom"</span>;        <span class="comment">// God Save Me</span></div></pre></td></tr></table></figure></p><a id="more"></a><h1 id="symbol大法"><a href="#symbol大法" class="headerlink" title="symbol大法"></a>symbol大法</h1><p>不过，如果想定义私有成员，也有变通的方式，比如广为留传的 Symbol 大法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Person = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> _name = <span class="built_in">Symbol</span>();</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</div><div class="line">        <span class="keyword">constructor</span>(name) &#123;</div><div class="line">            <span class="keyword">this</span>[_name] = name;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        get name() &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>[_name];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> Person;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure></p><p>其实质在于匿名函数中的 Symbol 实例 _name 是局部变量，在外部不可访问。而 Symbol 由于自身的唯一性特点，也没法再造一个相同的出来，所以就模拟出来一个私有成员了。</p><h1 id="ES5模拟symbol"><a href="#ES5模拟symbol" class="headerlink" title="ES5模拟symbol"></a>ES5模拟symbol</h1><p>按照此思路，在 ES5 中其实也很容易模拟私有成员。局部变量是很容易做到的，在函数范围内 let 和 var 是一样的效果。问题在于模拟 Symbol 的唯一性。</p><p>ES5 没有 Sybmol，属性名称只可能是一个字符串，如果我们能做到这个字符串不可预料，那么就基本达到目标。要达到不可预期，一个随机数基本上就解决了。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Person = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> _name = <span class="string">"00"</span> + <span class="built_in">Math</span>.random();</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">        <span class="keyword">this</span>[_name] = name;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="built_in">Object</span>.defineProperty(Person.prototype, <span class="string">"name"</span>, &#123;</div><div class="line">        get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>[_name];</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> Person;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure></p><p>如果这个程序在 Web 页面中加载，那么每次刷新页面 _name 的值都会不同，但并不会影响程序的逻辑，外部程序不会出现任何不适。</p><h1 id="新提案"><a href="#新提案" class="headerlink" title="新提案"></a>新提案</h1><p>与私有方法一样，ES6 不支持私有属性。目前，<a href="https://github.com/tc39/proposal-class-fields#private-fields" target="_blank" rel="external">有一个提案</a>，为class加了私有属性。方法是在属性名之前，使用#表示。<br><figure class="highlight hs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="type">Point</span> &#123;</span></div><div class="line"><span class="class">  #x;</span></div><div class="line"><span class="class"></span></div><div class="line"><span class="class">  constructor(<span class="title">x</span> = 0) &#123;</span></div><div class="line"><span class="class">    #x = +x; // 写成 this.#x 亦可</span></div><div class="line"><span class="class">  &#125;</span></div><div class="line"><span class="class"></span></div><div class="line"><span class="class">  get x() &#123; return #x &#125;</span></div><div class="line"><span class="class">  set x(<span class="title">value</span>) &#123; #x = +value &#125;</span></div><div class="line"><span class="class">&#125;</span></div></pre></td></tr></table></figure></p><p>上面代码中，#x就表示私有属性x，在Point类之外是读取不到这个属性的。还可以看到，私有属性与实例的属性是可以同名的（比如，#x与get x()）。</p><p>私有属性可以指定初始值，在构造函数执行时进行初始化。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</div><div class="line">  #x = 0;</div><div class="line">  <span class="keyword">constructor</span>() &#123;</div><div class="line">    #x; // 0</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>之所以要引入一个新的前缀#表示私有属性，而没有采用private关键字，是因为 JavaScript 是一门动态语言，使用独立的符号似乎是唯一的可靠方法，能够准确地区分一种属性是否为私有属性。另外，Ruby 语言使用@表示私有属性，ES6 没有用这个符号而使用#，是因为@已经被留给了 <code>Decorator</code>。</p><p>该提案只规定了私有属性的写法。但是，很自然地，它也可以用来写私有方法。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</div><div class="line">  #a;</div><div class="line">  #b;</div><div class="line">  #sum() &#123; return #a + #b; &#125;</div><div class="line">  printSum() &#123; console.log(#sum()); &#125;</div><div class="line">  constructor(a, b) &#123; #a = a; #b = b; &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>与 Symbol 方案相比，ES5模拟Symbol的问题在于这个 _name 的值不会像 Symbol 一样会隐藏起来，在控制台可以用很多种办法把它找出来——当然在调试阶段这样做也没什么不可以。在开发阶段这个值仍然是不可预料的。</p><p>对于单个私有属性的情况，有人会找到私有 Key 的规律，比如上面的私有 Key 就是以 “000.” 开始的，遍历对象属性很容易找出来。在多个私有 Key 的情况下，也可以通过一些技术手段来找，比如<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPersonNameKey</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> v = <span class="string">""</span> + <span class="built_in">Math</span>.random();</div><div class="line">    <span class="keyword">var</span> p = <span class="keyword">new</span> Person(v);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> k <span class="keyword">in</span> p) &#123;</div><div class="line">        <span class="keyword">if</span> (p[k] === v) &#123;</div><div class="line">            <span class="keyword">return</span> k;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>但这些都是后话，做起来太费劲，一般人不会这么干。何况 Symbol 也是可以遍历的（通过 <code>Object.getOwnPropertySymbols()）</code>，完全可以以同样的方法来获取私有 Key。</p><p>参考<a href="https://segmentfault.com/a/1190000003488631" target="_blank" rel="external">https://segmentfault.com/a/1190000003488631</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;纸上得来终觉浅，绝知此事要躬行&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;name形式私有&quot;&gt;&lt;a href=&quot;#name形式私有&quot; class=&quot;headerlink&quot; title=&quot;_name形式私有&quot;&gt;&lt;/a&gt;_name形式私有&lt;/h1&gt;&lt;p&gt;ES6 中有类语法，定义类变得简单了&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Person&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;constructor&lt;/span&gt;(name) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;._name = name;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    get name() &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;._name;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;然而，并没有提供私有属性。比如上面的 Person 其实是希望在构造的时候传入 name，之后不允许修改了。不过，由于没有私有属性，所以难免有人会这样干：&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;Person james = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Person(&lt;span class=&quot;string&quot;&gt;&quot;James&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;james._name = &lt;span class=&quot;string&quot;&gt;&quot;Tom&quot;&lt;/span&gt;;        &lt;span class=&quot;comment&quot;&gt;// God Save Me&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="基础杂谈" scheme="https://dsb123dsb.github.io/categories/%E5%9F%BA%E7%A1%80%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="ES6" scheme="https://dsb123dsb.github.io/tags/ES6/"/>
    
      <category term="symbol" scheme="https://dsb123dsb.github.io/tags/symbol/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 内存泄漏教程</title>
    <link href="https://dsb123dsb.github.io/2017/06/07/JavaScript-%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%95%99%E7%A8%8B/"/>
    <id>https://dsb123dsb.github.io/2017/06/07/JavaScript-内存泄漏教程/</id>
    <published>2017-06-07T12:19:40.000Z</published>
    <updated>2017-10-03T13:53:51.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>纸上得来终觉浅，绝知此事要躬行</p></blockquote><p>看到阮一峰一篇关于内存泄漏的文章，发现很全，ES6、node相关也都有,个人收益较大部分是weakmap，weakset部分——————<a href="http://www.ruanyifeng.com/blog/2017/04/memory-leak.html" target="_blank" rel="external">原文猛搓</a></p><h1 id="什么是内存泄漏？"><a href="#什么是内存泄漏？" class="headerlink" title="什么是内存泄漏？"></a>什么是内存泄漏？</h1><p>程序的运行需要内存。只要程序提出要求，操作系统或者运行时（runtime）就必须供给内存。</p><p>对于持续运行的服务进程（daemon），必须及时释放不再用到的内存。否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2017/bg2017041701-1.png" alt=""></p><p>不再用到的内存，没有及时释放，就叫做内存泄漏（memory leak）。<br>有些语言（比如 C 语言）必须手动释放内存，程序员负责内存管理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span> * buffer;</div><div class="line">buffer = (<span class="keyword">char</span>*) <span class="built_in">malloc</span>(<span class="number">42</span>);</div><div class="line"></div><div class="line"><span class="comment">// Do something with buffer</span></div><div class="line"></div><div class="line"><span class="built_in">free</span>(buffer);</div></pre></td></tr></table></figure><p>上面是 C 语言代码，<code>malloc</code>方法用来申请内存，使用完毕之后，必须自己用<code>free</code>方法释放内存。<br><a id="more"></a><br>这很麻烦，所以大多数语言提供自动内存管理，减轻程序员的负担，这被称为”垃圾回收机制”（garbage collector）。</p><h1 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h1><p>垃圾回收机制怎么知道，哪些内存不再需要呢？</p><p>最常使用的方法叫做”<a href="https://en.wikipedia.org/wiki/Reference_counting" target="_blank" rel="external">引用计数</a>“（reference counting）：语言引擎有一张”引用表”，保存了内存里面所有的资源（通常是各种值）的引用次数。如果一个值的引用次数是0，就表示这个值不再用到了，因此可以将这块内存释放。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2017/bg2017041703.png" alt=""></p><p>上图中，左下角的两个值，没有任何引用，所以可以释放。</p><p>如果一个值不再需要了，引用数却不为0，垃圾回收机制无法释放这块内存，从而导致内存泄漏。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'hello world'</span>);</div></pre></td></tr></table></figure><p>上面代码中，数组<code>[1, 2, 3, 4]</code>是一个值，会占用内存。变量arr是仅有的对这个值的引用，因此引用次数为1。尽管后面的代码没有用到arr，它还是会持续占用内存。</p><p>如果增加一行代码，解除arr对<code>[1, 2, 3, 4]</code>引用，这块内存就可以被垃圾回收机制释放了。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'hello world'</span>);</div><div class="line">arr = <span class="literal">null</span>;</div></pre></td></tr></table></figure></p><p>上面代码中，arr重置为<code>null</code>，就解除了对<code>[1, 2, 3, 4]</code>的引用，引用次数变成了0，内存就可以释放出来了。</p><p>因此，并不是说有了垃圾回收机制，程序员就轻松了。你还是需要关注内存占用：那些很占空间的值，一旦不再用到，你必须检查是否还存在对它们的引用。如果是的话，就必须手动解除引用。</p><h1 id="内存泄漏的识别方法"><a href="#内存泄漏的识别方法" class="headerlink" title="内存泄漏的识别方法"></a>内存泄漏的识别方法</h1><p>怎样可以观察到内存泄漏呢？<br><a href="https://www.toptal.com/nodejs/debugging-memory-leaks-node-js-applications" target="_blank" rel="external">经验法则是</a>，如果连续五次垃圾回收之后，内存占用一次比一次大，就有内存泄漏。这就要求实时查看内存占用。</p><h2 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h2><p>Chrome 浏览器查看内存占用，按照以下步骤操作。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2017/bg2017041704.png" alt=""></p><ol><li>打开开发者工具，选择 Timeline 面板</li><li>在顶部的Capture字段里面勾选 Memory</li><li>点击左上角的录制按钮。</li><li>在页面上进行各种操作，模拟用户的使用情况。</li></ol><p>一段时间后，点击对话框的 stop 按钮，面板上就会显示这段时间的内存占用情况。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2017/bg2017041705.png" alt=""></p><p>反之，就是内存泄漏了。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2017/bg2017041706.png" alt=""></p><h1 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h1><p>命令行可以使用 <code>Node</code> 提供的<a href="https://nodejs.org/api/process.html#process_process_memoryusage" target="_blank" rel="external">process.memoryUsage</a>方法。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(process.memoryUsage());</div><div class="line"><span class="comment">// &#123; rss: 27709440,</span></div><div class="line"><span class="comment">//  heapTotal: 5685248,</span></div><div class="line"><span class="comment">//  heapUsed: 3449392,</span></div><div class="line"><span class="comment">//  external: 8772 &#125;</span></div></pre></td></tr></table></figure></p><p>process.memoryUsage返回一个对象，包含了 Node 进程的内存占用信息。该对象包含四个字段，单位是字节，<a href="http://stackoverflow.com/questions/12023359/what-do-the-return-values-of-node-js-process-memoryusage-stand-for" target="_blank" rel="external">含义如</a>下。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2017/bg2017041702-1.png" alt=""></p><ul><li>rss（resident set size）：所有内存占用，包括指令区和堆栈。</li><li>heapTotal：”堆”占用的内存，包括用到的和没用到的。</li><li>heapUsed：用到的堆的部分。</li><li>external： V8 引擎内部的 C++ 对象占用的内存。</li></ul><p>判断内存泄漏，以<code>heapUsed</code>字段为准</p><h1 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h1><p>前面说过，及时清除引用非常重要。但是，你不可能记得那么多，有时候一疏忽就忘了，所以才有那么多内存泄漏。</p><p>最好能有一种方法，在新建引用的时候就声明，哪些引用必须手动清除，哪些引用可以忽略不计，当其他引用消失以后，垃圾回收机制就可以释放内存。这样就能大大减轻程序员的负担，你只要清除主要引用就可以了。</p><p>ES6 考虑到了这一点，推出了两种新的数据结构：<a href="http://es6.ruanyifeng.com/#docs/set-map#WeakSet" target="_blank" rel="external">WeakSet</a> 和 <a href="http://es6.ruanyifeng.com/#docs/set-map#WeakMap" target="_blank" rel="external">WeakMap</a>。它们对于值的引用都是不计入垃圾回收机制的，所以名字里面才会有一个”Weak”，表示这是弱引用。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2017/bg2017041707.jpg" alt=""></p><p>下面以 WeakMap 为例，看看它是怎么解决内存泄漏的。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</div><div class="line"></div><div class="line"><span class="keyword">const</span> element = <span class="built_in">document</span>.getElementById(<span class="string">'example'</span>);</div><div class="line"></div><div class="line">wm.set(element, <span class="string">'some information'</span>);</div><div class="line">wm.get(element) <span class="comment">// "some information"</span></div></pre></td></tr></table></figure></p><p>上面代码中，先新建一个 <code>Weakmap</code> 实例。然后，将一个 DOM 节点作为键名存入该实例，并将一些附加信息作为键值，一起存放在 WeakMap 里面。这时，WeakMap 里面对<code>element</code>的引用就是弱引用，不会被计入垃圾回收机制。</p><p>也就是说，DOM 节点对象的引用计数是1，而不是2。这时，一旦消除对该节点的引用，它占用的内存就会被垃圾回收机制释放。Weakmap 保存的这个键值对，也会自动消失。</p><p>基本上，如果你要往对象上添加数据，又不想干扰垃圾回收机制，就可以使用 WeakMap。</p><h1 id="WeakMap-示例"><a href="#WeakMap-示例" class="headerlink" title="WeakMap 示例"></a>WeakMap 示例</h1><p>WeakMap 的例子很难演示，因为无法观察它里面的引用会自动消失。此时，其他引用都解除了，已经没有引用指向 WeakMap 的键名了，导致无法证实那个键名是不是存在。</p><p>我一直想不出办法，直到有一天贺师俊老师<a href="https://github.com/ruanyf/es6tutorial/issues/362#issuecomment-292109104" target="_blank" rel="external">提示</a>，如果引用所指向的值占用特别多的内存，就可以通过<code>process.memoryUsage</code>方法看出来。</p><p>根据这个思路，网友 <a href="https://github.com/ruanyf/es6tutorial/issues/362#issuecomment-292451925" target="_blank" rel="external">vtxf </a>补充了下面的例子。</p><p>首先，打开 Node 命令行。</p><pre><code>$ node --expose-gc</code></pre><p>上面代码中，<code>--expose-gc</code>参数表示允许手动执行垃圾回收机制。</p><p>然后，执行下面的代码。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 手动执行一次垃圾回收，保证获取的内存使用状态准确</span></div><div class="line">&gt; global.gc(); </div><div class="line"><span class="literal">undefined</span></div><div class="line"></div><div class="line"><span class="comment">// 查看内存占用的初始状态，heapUsed 为 4M 左右</span></div><div class="line">&gt; process.memoryUsage(); </div><div class="line">&#123; <span class="attr">rss</span>: <span class="number">21106688</span>,</div><div class="line">  heapTotal: <span class="number">7376896</span>,</div><div class="line">  heapUsed: <span class="number">4153936</span>,</div><div class="line">  external: <span class="number">9059</span> &#125;</div><div class="line"></div><div class="line">&gt; <span class="keyword">let</span> wm = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</div><div class="line"><span class="literal">undefined</span></div><div class="line"></div><div class="line">&gt; <span class="keyword">let</span> b = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line"><span class="literal">undefined</span></div><div class="line"></div><div class="line">&gt; global.gc();</div><div class="line"><span class="literal">undefined</span></div><div class="line"></div><div class="line"><span class="comment">// 此时，heapUsed 仍然为 4M 左右</span></div><div class="line">&gt; process.memoryUsage(); </div><div class="line">&#123; <span class="attr">rss</span>: <span class="number">20537344</span>,</div><div class="line">  heapTotal: <span class="number">9474048</span>,</div><div class="line">  heapUsed: <span class="number">3967272</span>,</div><div class="line">  external: <span class="number">8993</span> &#125;</div><div class="line"></div><div class="line"><span class="comment">// 在 WeakMap 中添加一个键值对，</span></div><div class="line"><span class="comment">// 键名为对象 b，键值为一个 5*1024*1024 的数组  </span></div><div class="line">&gt; wm.set(b, <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">5</span>*<span class="number">1024</span>*<span class="number">1024</span>));</div><div class="line"><span class="built_in">WeakMap</span> &#123;&#125;</div><div class="line"></div><div class="line"><span class="comment">// 手动执行一次垃圾回收</span></div><div class="line">&gt; global.gc();</div><div class="line"><span class="literal">undefined</span></div><div class="line"></div><div class="line"><span class="comment">// 此时，heapUsed 为 45M 左右</span></div><div class="line">&gt; process.memoryUsage(); </div><div class="line">&#123; <span class="attr">rss</span>: <span class="number">62652416</span>,</div><div class="line">  heapTotal: <span class="number">51437568</span>,</div><div class="line">  heapUsed: <span class="number">45911664</span>,</div><div class="line">  external: <span class="number">8951</span> &#125;</div><div class="line"></div><div class="line"><span class="comment">// 解除对象 b 的引用  </span></div><div class="line">&gt; b = <span class="literal">null</span>;</div><div class="line"><span class="literal">null</span></div><div class="line"></div><div class="line"><span class="comment">// 再次执行垃圾回收</span></div><div class="line">&gt; global.gc();</div><div class="line"><span class="literal">undefined</span></div><div class="line"></div><div class="line"><span class="comment">// 解除 b 的引用以后，heapUsed 变回 4M 左右</span></div><div class="line"><span class="comment">// 说明 WeakMap 中的那个长度为 5*1024*1024 的数组被销毁了</span></div><div class="line">&gt; process.memoryUsage(); </div><div class="line">&#123; <span class="attr">rss</span>: <span class="number">20639744</span>,</div><div class="line">  heapTotal: <span class="number">8425472</span>,</div><div class="line">  heapUsed: <span class="number">3979792</span>,</div><div class="line">  external: <span class="number">8956</span> &#125;</div></pre></td></tr></table></figure></p><p>上面代码中，只要外部的引用消失，<code>WeakMap</code> 内部的引用，就会自动被垃圾回收清除。由此可见，有了它的帮助，解决内存泄漏就会简单很多。</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul><li><a href="https://www.alexkras.com/simple-guide-to-finding-a-javascript-memory-leak-in-node-js/" target="_blank" rel="external">Simple Guide to Finding a JavaScript Memory Leak in Node.js</a></li><li><a href="https://www.dynatrace.com/blog/understanding-garbage-collection-and-hunting-memory-leaks-in-node-js/" target="_blank" rel="external">Understanding Garbage Collection and hunting Memory Leaks in Node.js</a></li><li><a href="https://www.toptal.com/nodejs/debugging-memory-leaks-node-js-applications" target="_blank" rel="external">Debugging Memory Leaks in Node.js Applications</a></li></ul><p>(完)</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;纸上得来终觉浅，绝知此事要躬行&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;看到阮一峰一篇关于内存泄漏的文章，发现很全，ES6、node相关也都有,个人收益较大部分是weakmap，weakset部分——————&lt;a href=&quot;http://www.ruanyifeng.com/blog/2017/04/memory-leak.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;原文猛搓&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;什么是内存泄漏？&quot;&gt;&lt;a href=&quot;#什么是内存泄漏？&quot; class=&quot;headerlink&quot; title=&quot;什么是内存泄漏？&quot;&gt;&lt;/a&gt;什么是内存泄漏？&lt;/h1&gt;&lt;p&gt;程序的运行需要内存。只要程序提出要求，操作系统或者运行时（runtime）就必须供给内存。&lt;/p&gt;
&lt;p&gt;对于持续运行的服务进程（daemon），必须及时释放不再用到的内存。否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.ruanyifeng.com/blogimg/asset/2017/bg2017041701-1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;不再用到的内存，没有及时释放，就叫做内存泄漏（memory leak）。&lt;br&gt;有些语言（比如 C 语言）必须手动释放内存，程序员负责内存管理。&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; * buffer;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;buffer = (&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt;*) &lt;span class=&quot;built_in&quot;&gt;malloc&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;42&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Do something with buffer&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;free&lt;/span&gt;(buffer);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面是 C 语言代码，&lt;code&gt;malloc&lt;/code&gt;方法用来申请内存，使用完毕之后，必须自己用&lt;code&gt;free&lt;/code&gt;方法释放内存。&lt;br&gt;
    
    </summary>
    
      <category term="基础杂谈" scheme="https://dsb123dsb.github.io/categories/%E5%9F%BA%E7%A1%80%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="js" scheme="https://dsb123dsb.github.io/tags/js/"/>
    
      <category term="内存泄漏" scheme="https://dsb123dsb.github.io/tags/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Vue2.17源码学习</title>
    <link href="https://dsb123dsb.github.io/2017/05/25/Vue2-17%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    <id>https://dsb123dsb.github.io/2017/05/25/Vue2-17源码学习/</id>
    <published>2017-05-25T14:00:39.000Z</published>
    <updated>2017-10-03T13:53:51.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>纸上得来终觉浅，绝知此事要躬</p></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前段时间看到尤雨溪推荐了一篇vue源码的文章，自己一直也想研究下源码，这几天抽空看了，<a href="http://hcysun.me/2017/03/03/Vue%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/" target="_blank" rel="external">原文猛戳</a></p><p>原本文章的名字叫做《源码解析》，不过后来想想，还是用“源码学习”来的合适一点，在没有彻底掌握源码中的每一个字母之前，“解析”就有点标题党了。建议在看这篇文章之前，最好打开<code>2.1.7</code>的源码对照着看，这样可能更容易理解。另外本人水平有限，文中有错误或不妥的地方望大家多多指正共同成长。</p><p>补充：<code>Vue 2.2</code> 刚刚发布，作为一个系列文章的第一篇，本篇文章主要从Vue代码的组织，Vue构造函数的还原，原型的设计，以及参数选项的处理和已经被写烂了的数据绑定与如何使用 Virtual DOM 更新视图入手。从整体的大方向观察框架，这么看来 <code>V2.1.7</code> 对于理解 <code>V2.2</code>的代码不会有太大的影响。该系列文章的后续文章，都会从最新的源码入手，并对改动的地方做相应的提示。</p><p>很久之前写过一篇文章：<a href="http://hcysun.me/2016/04/28/JavaScript%E5%AE%9E%E7%8E%B0MVVM%E4%B9%8B%E6%88%91%E5%B0%B1%E6%98%AF%E6%83%B3%E7%9B%91%E6%B5%8B%E4%B8%80%E4%B8%AA%E6%99%AE%E9%80%9A%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8F%98%E5%8C%96/" target="_blank" rel="external">JavaScript实现MVVM之我就是想监测一个普通对象的变化</a>，文章开头提到了我写博客的风格，还是那句话，只写努力让小白，甚至是小学生都能看明白的文章。这不免会导致对于某些同学来说这篇文章有些墨迹，所以大家根据自己的喜好，可以详细的看，也可以跳跃着看。<br><a id="more"></a></p><h1 id="从了解一个开源项目入手"><a href="#从了解一个开源项目入手" class="headerlink" title="从了解一个开源项目入手"></a>从了解一个开源项目入手</h1><p>要看一个项目的源码，不要一上来就看，先去了解一下项目本身的元数据和依赖，除此之外最好也了解一下 PR 规则，Issue Reporting 规则等等。特别是“前端”开源项目，我们在看源码之前第一个想到的应该是：<code>package.json</code>文件。</p><p>在 <code>package.json</code> 文件中，我们最应该关注的就是 <code>scripts</code> 字段和 <code>devDependencies</code> 以及 <code>dependencies</code> 字段，通过 <code>scripts</code> 字段我们可以知道项目中定义的脚本命令，通过 <code>devDependencies</code>和 <code>dependencies</code> 字段我们可以了解项目的依赖情况。</p><p>了解了这些之后，如果有依赖我们就 <code>npm install</code> 安装依赖就ok了。</p><p>除了 <code>package.json</code> 之外，我们还要阅读项目的贡献规则文档，了解如何开始，一个好的开源项目肯定会包含这部分内容的，Vue也不例外：<a href="https://github.com/vuejs/vue/blob/dev/.github/CONTRIBUTING.md" target="_blank" rel="external">https://github.com/vuejs/vue/blob/dev/.github/CONTRIBUTING.md</a>，在这个文档里说明了一些行为准则，PR指南，Issue Reporting 指南，Development Setup 以及 项目结构。通过阅读这些内容，我们可以了解项目如何开始，如何开发以及目录的说明，下面是对重要目录和文件的简单介绍，这些内容你都可以去自己阅读获取：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">├── build --------------------------------- 构建相关的文件，一般情况下我们不需要动</div><div class="line">├── dist ---------------------------------- 构建后文件的输出目录</div><div class="line">├── examples ------------------------------ 存放一些使用Vue开发的应用案例</div><div class="line">├── flow ---------------------------------- 类型声明，使用开源项目 [Flow](https://flowtype.org/)</div><div class="line">├── package.json -------------------------- 不解释</div><div class="line">├── test ---------------------------------- 包含所有测试文件</div><div class="line">├── src ----------------------------------- 这个是我们最应该关注的目录，包含了源码</div><div class="line">│   ├── entries --------------------------- 包含了不同的构建或包的入口文件</div><div class="line">│   │   ├── web-runtime.js ---------------- 运行时构建的入口，输出 dist/vue.common.js 文件，不包含模板(template)到render函数的编译器，所以不支持 `template` 选项，我们使用vue默认导出的就是这个运行时的版本。大家使用的时候要注意</div><div class="line">│   │   ├── web-runtime-with-compiler.js -- 独立构建版本的入口，输出 dist/vue.js，它包含模板(template)到render函数的编译器</div><div class="line">│   │   ├── web-compiler.js --------------- vue-template-compiler 包的入口文件</div><div class="line">│   │   ├── web-server-renderer.js -------- vue-server-renderer 包的入口文件</div><div class="line">│   ├── compiler -------------------------- 编译器代码的存放目录，将 template 编译为 render 函数</div><div class="line">│   │   ├── parser ------------------------ 存放将模板字符串转换成元素抽象语法树的代码</div><div class="line">│   │   ├── codegen ----------------------- 存放从抽象语法树(AST)生成render函数的代码</div><div class="line">│   │   ├── optimizer.js ------------------ 分析静态树，优化vdom渲染</div><div class="line">│   ├── core ------------------------------ 存放通用的，平台无关的代码</div><div class="line">│   │   ├── observer ---------------------- 反应系统，包含数据观测的核心代码</div><div class="line">│   │   ├── vdom -------------------------- 包含虚拟DOM创建(creation)和打补丁(patching)的代码</div><div class="line">│   │   ├── instance ---------------------- 包含Vue构造函数设计相关的代码</div><div class="line">│   │   ├── global-api -------------------- 包含给Vue构造函数挂载全局方法(静态方法)或属性的代码</div><div class="line">│   │   ├── components -------------------- 包含抽象出来的通用组件</div><div class="line">│   ├── server ---------------------------- 包含服务端渲染(server-side rendering)的相关代码</div><div class="line">│   ├── platforms ------------------------- 包含平台特有的相关代码</div><div class="line">│   ├── sfc ------------------------------- 包含单文件组件(.vue文件)的解析逻辑，用于vue-template-compiler包</div><div class="line">│   ├── shared ---------------------------- 包含整个代码库通用的代码</div></pre></td></tr></table></figure><p>大概了解了重要目录和文件之后，我们就可以查看 <a href="https://github.com/vuejs/vue/blob/dev/.github/CONTRIBUTING.md#development-setup" target="_blank" rel="external">Development Setup</a> 中的常用命令部分，来了解如何开始这个项目了，我们可以看到这样的介绍：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"># watch and auto re-build dist/vue.js</div><div class="line">$ npm run dev</div><div class="line"></div><div class="line"># watch and auto re-run unit tests in Chrome</div><div class="line">$ npm run dev:test</div></pre></td></tr></table></figure></p><p>现在，我们只需要运行 <code>npm run dev</code> 即可监测文件变化并自动重新构建输出 <code>dist/vue.js</code>，然后运行 <code>npm run dev:test</code> 来测试。不过为了方便，我会在 <code>examples</code> 目录新建一个例子，然后引用 <code>dist/vue.js</code> 这样，我们可以直接拿这个例子一边改Vue源码一边看自己写的代码想怎么玩怎么玩。</p><h1 id="看源码的小提示"><a href="#看源码的小提示" class="headerlink" title="看源码的小提示"></a>看源码的小提示</h1><p>在真正步入源码世界之前，我想简单说一说看源码的技巧：<br><em>注重大体框架，从宏观到微观</em></p><p>当你看一个项目代码的时候，最好是能找到一条主线，先把大体流程结构摸清楚，再深入到细节，逐项击破，拿Vue举个栗子：假如你已经知道Vue中数据状态改变后会采用virtual DOM的方式更新DOM，这个时候，如果你不了解virtual DOM，那么听我一句“暂且不要去研究内部具体实现，因为这会是你丧失主线”，而你仅仅需要知道virtual DOM分为三个步骤：</p><ol><li>createElement(): 用 JavaScript对象(虚拟树) 描述 真实DOM对象(真实树)</li><li>diff(oldNode, newNode) : 对比新旧两个虚拟树的区别，收集差异</li><li>patch() : 将差异应用到真实DOM树</li></ol><p>有的时候 第二步 可能与 第三步 合并成一步(Vue 中的patch就是这样)，除此之外，还比如 <code>src/compiler/codegen</code> 内的代码，可能你不知道他写了什么，直接去看它会让你很痛苦，但是你只需要知道 codegen 是用来将抽象语法树(AST)生成render函数的就OK了，也就是生成类似下面这样的代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">anonymous</span>(<span class="params"></span>) </span>&#123;</div><div class="line"><span class="keyword">with</span>(<span class="keyword">this</span>)&#123;<span class="keyword">return</span> _c(<span class="string">'p'</span>,&#123;<span class="attr">attrs</span>:&#123;<span class="string">"id"</span>:<span class="string">"app"</span>&#125;&#125;,[_v(<span class="string">"\n      "</span>+_s(a)+<span class="string">"\n      "</span>),_c(<span class="string">'my-com'</span>)])&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>当我们知道了一个东西存在，且知道它存在的目的，那么我们就很容易抓住这条主线，这个系列的第一篇文章就是围绕大体主线展开的。了解大体之后，我们就知道了每部分内容都是做什么的，比如 codegen 是生成类似上面贴出的代码所示的函数的，那么再去看codegen下的代码时，目的性就会更强，就更容易理解。</p><h1 id="Vue-的构造函数是什么样的"><a href="#Vue-的构造函数是什么样的" class="headerlink" title="Vue 的构造函数是什么样的"></a>Vue 的构造函数是什么样的</h1><p>balabala一大堆，开始来干货吧。我们要做的第一件事就是搞清楚 Vue 构造函数到底是什么样子的。<br>我们知道，我们要使用 <code>new</code> 操作符来调用 <code>Vue</code>，那么也就是说 <code>Vue</code> 应该是一个构造函数，所以我们第一件要做的事儿就是把构造函数先扒的一清二楚，如何寻找 <code>Vue</code> 构造函数呢？当然是从 <code>entry</code> 开始啦，还记的我们运行 <code>npm run dev</code> 命令后，会输出 <code>dist/vue.js</code> 吗，那么我们就去看看 <code>npm run dev</code> 干了什么：</p><pre><code>&quot;dev&quot;: &quot;TARGET=web-full-dev rollup -w -c build/config.js&quot;,</code></pre><p>首先将 TARGET 得值设置为 ‘web-full-dev’，然后，然后，然后如果你不了解 rollup 就应该简单去看一下啦……，简单的说就是一个JavaScript模块打包器，你可以把它简单的理解为和 webpack 一样，只不过它有他的优势，比如 Tree-shaking (webpack2也有)，但同样，在某些场景它也有他的劣势。。。废话不多说，其中 <code>-w</code> 就是watch，<code>-c</code> 就是指定配置文件为 <code>build/config.js</code> ，我们打开这个配置文件看一看：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">// 引入依赖，定义 banner</span></div><div class="line">...</div><div class="line"></div><div class="line"><span class="comment">// builds 对象</span></div><div class="line"><span class="keyword">const</span> builds = &#123;</div><div class="line">...</div><div class="line"><span class="comment">// Runtime+compiler development build (Browser)</span></div><div class="line"><span class="string">'web-full-dev'</span>: &#123;</div><div class="line">    entry: path.resolve(__dirname, <span class="string">'../src/entries/web-runtime-with-compiler.js'</span>),</div><div class="line">    dest: path.resolve(__dirname, <span class="string">'../dist/vue.js'</span>),</div><div class="line">    format: <span class="string">'umd'</span>,</div><div class="line">    env: <span class="string">'development'</span>,</div><div class="line">    alias: &#123; <span class="attr">he</span>: <span class="string">'./entity-decoder'</span> &#125;,</div><div class="line">    banner</div><div class="line">&#125;,</div><div class="line">...</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 生成配置的方法</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">genConfig</span>(<span class="params">opts</span>)</span>&#123;</div><div class="line">...</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (process.env.TARGET) &#123;</div><div class="line">  <span class="built_in">module</span>.exports = genConfig(builds[process.env.TARGET])</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">  exports.getBuild = <span class="function"><span class="params">name</span> =&gt;</span> genConfig(builds[name])</div><div class="line">  exports.getAllBuilds = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">Object</span>.keys(builds).map(<span class="function"><span class="params">name</span> =&gt;</span> genConfig(builds[name]))</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>上面的代码是简化过的，当我们运行<code>npm run dev</code> 的时候 <code>process.env.TARGET</code> 的值等于 ‘web-full-dev’，所以</p><pre><code>module.exports = genConfig(builds[process.env.TARGET])</code></pre><p>这句代码相当于：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = genConfig(&#123;</div><div class="line">    entry: path.resolve(__dirname, <span class="string">'../src/entries/web-runtime-with-compiler.js'</span>),</div><div class="line">    dest: path.resolve(__dirname, <span class="string">'../dist/vue.js'</span>),</div><div class="line">    format: <span class="string">'umd'</span>,</div><div class="line">    env: <span class="string">'development'</span>,</div><div class="line">    alias: &#123; <span class="attr">he</span>: <span class="string">'./entity-decoder'</span> &#125;,</div><div class="line">    banner</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p><p>最终，genConfig 函数返回一个 config 对象，这个config对象就是Rollup的配置对象。那么我们就不难看到，入口文件是：</p><pre><code>src/entries/web-runtime-with-compiler.js</code></pre><p>我们打开这个文件，不要忘了我们的主题，我们在寻找Vue构造函数，所以当我们看到这个文件的第一行代码是：</p><pre><code>import Vue from &apos;./web-runtime&apos;</code></pre><p>这个时候，你就应该知道，这个文件暂时与你无缘，你应该打开 <code>web-runtime.js</code>文件，不过当你打开这个文件时，你发现第一行是这样的：</p><pre><code>import Vue from &apos;core/index&apos;</code></pre><p>依照此思路，最终我们寻找到Vue构造函数的位置应该是在 <code>src/core/instance/index.js</code> 文件中，其实我们猜也猜得到，上面介绍目录的时候说过：instance 是存放Vue构造函数设计相关代码的目录。总结一下，我们寻找的过程是这样的：</p><p><img src="http://7xlolm.com1.z0.glb.clouddn.com/vueimg2BD0DCC6-D689-4809-93D3-2F979E8F8C0C.png" alt=""></p><p>我们回头看一看 <code>src/core/instance/index.js</code> 文件，很简单：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">import</span> &#123; initMixin &#125; <span class="keyword">from</span> <span class="string">'./init'</span></div><div class="line"><span class="keyword">import</span> &#123; stateMixin &#125; <span class="keyword">from</span> <span class="string">'./state'</span></div><div class="line"><span class="keyword">import</span> &#123; renderMixin &#125; <span class="keyword">from</span> <span class="string">'./render'</span></div><div class="line"><span class="keyword">import</span> &#123; eventsMixin &#125; <span class="keyword">from</span> <span class="string">'./events'</span></div><div class="line"><span class="keyword">import</span> &#123; lifecycleMixin &#125; <span class="keyword">from</span> <span class="string">'./lifecycle'</span></div><div class="line"><span class="keyword">import</span> &#123; warn &#125; <span class="keyword">from</span> <span class="string">'../util/index'</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Vue</span> (<span class="params">options</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp;</div><div class="line">    !(<span class="keyword">this</span> <span class="keyword">instanceof</span> Vue)) &#123;</div><div class="line">    warn(<span class="string">'Vue is a constructor and should be called with the `new` keyword'</span>)</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">this</span>._init(options)</div><div class="line">&#125;</div><div class="line"></div><div class="line">initMixin(Vue)</div><div class="line">stateMixin(Vue)</div><div class="line">eventsMixin(Vue)</div><div class="line">lifecycleMixin(Vue)</div><div class="line">renderMixin(Vue)</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> Vue</div></pre></td></tr></table></figure></p><p>引入依赖，定义 Vue 构造函数，然后以Vue构造函数为参数，调用了五个方法，最后导出 Vue。这五个方法分别来自五个文件：<code>init.js state.js render.js events.js</code> 以及 <code>lifecycle.js</code>。<br>打开这五个文件，找到相应的方法，你会发现，这些方法的作用，就是在 Vue 的原型 prototype 上挂载方法或属性，经历了这五个方法后的Vue会变成这样：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">// initMixin(Vue)src/core/instance/init.js **************************************************</span></div><div class="line">Vue.prototype._init = <span class="function"><span class="keyword">function</span> (<span class="params">options?: Object</span>) </span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="comment">// stateMixin(Vue)src/core/instance/state.js **************************************************</span></div><div class="line">Vue.prototype.$data</div><div class="line">Vue.prototype.$set = set</div><div class="line">Vue.prototype.$<span class="keyword">delete</span> = del</div><div class="line">Vue.prototype.$watch = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="comment">// renderMixin(Vue)src/core/instance/render.js **************************************************</span></div><div class="line">Vue.prototype.$nextTick = <span class="function"><span class="keyword">function</span> (<span class="params">fn: Function</span>) </span>&#123;&#125;</div><div class="line">Vue.prototype._render = <span class="function"><span class="keyword">function</span> (<span class="params"></span>): <span class="title">VNode</span> </span>&#123;&#125;</div><div class="line">Vue.prototype._s = _toString</div><div class="line">Vue.prototype._v = createTextVNode</div><div class="line">Vue.prototype._n = toNumber</div><div class="line">Vue.prototype._e = createEmptyVNode</div><div class="line">Vue.prototype._q = looseEqual</div><div class="line">Vue.prototype._i = looseIndexOf</div><div class="line">Vue.prototype._m = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line">Vue.prototype._o = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line">Vue.prototype._f = <span class="function"><span class="keyword">function</span> <span class="title">resolveFilter</span> (<span class="params">id</span>) </span>&#123;&#125;</div><div class="line">Vue.prototype._l = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line">Vue.prototype._t = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line">Vue.prototype._b = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line">Vue.prototype._k = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="comment">// eventsMixin(Vue)src/core/instance/events.js **************************************************</span></div><div class="line">Vue.prototype.$on = <span class="function"><span class="keyword">function</span> (<span class="params">event: string, fn: Function</span>): <span class="title">Component</span> </span>&#123;&#125;</div><div class="line">Vue.prototype.$once = <span class="function"><span class="keyword">function</span> (<span class="params">event: string, fn: Function</span>): <span class="title">Component</span> </span>&#123;&#125;</div><div class="line">Vue.prototype.$off = <span class="function"><span class="keyword">function</span> (<span class="params">event?: string, fn?: Function</span>): <span class="title">Component</span> </span>&#123;&#125;</div><div class="line">Vue.prototype.$emit = <span class="function"><span class="keyword">function</span> (<span class="params">event: string</span>): <span class="title">Component</span> </span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="comment">// lifecycleMixin(Vue)src/core/instance/lifecycle.js **************************************************</span></div><div class="line">Vue.prototype._mount = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line">Vue.prototype._update = <span class="function"><span class="keyword">function</span> (<span class="params">vnode: VNode, hydrating?: boolean</span>) </span>&#123;&#125;</div><div class="line">Vue.prototype._updateFromParent = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line">Vue.prototype.$forceUpdate = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</div><div class="line">Vue.prototype.$destroy = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</div></pre></td></tr></table></figure></p><p>这样就结束了吗？并没有，根据我们之前寻找 Vue 的路线，这只是刚刚开始，我们追溯路线往回走，那么下一个处理 Vue 构造函数的应该是 <code>src/core/index.js</code> 文件，我们打开它：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'./instance/index'</span></div><div class="line"><span class="keyword">import</span> &#123; initGlobalAPI &#125; <span class="keyword">from</span> <span class="string">'./global-api/index'</span></div><div class="line"><span class="keyword">import</span> &#123; isServerRendering &#125; <span class="keyword">from</span> <span class="string">'core/util/env'</span></div><div class="line"></div><div class="line">initGlobalAPI(Vue)</div><div class="line"></div><div class="line"><span class="built_in">Object</span>.defineProperty(Vue.prototype, <span class="string">'$isServer'</span>, &#123;</div><div class="line">  get: isServerRendering</div><div class="line">&#125;)</div><div class="line"></div><div class="line">Vue.version = <span class="string">'__VERSION__'</span></div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> Vue</div></pre></td></tr></table></figure></p><p>这个文件也很简单，从 <code>instance/index</code> 中导入已经在原型上挂载了方法和属性后的 Vue，然后导入 <code>initGlobalAPI</code> 和 <code>isServerRendering</code>，之后将Vue作为参数传给 initGlobalAPI ，最后又在 <code>Vue.prototype</code> 上挂载了 <code>$isServer</code> ，在 <code>Vue</code>上挂载了 <code>version</code> 属性。<br><code>initGlobalAPI</code> 的作用是在 <code>Vue</code> 构造函数上挂载静态属性和方法，<code>Vue</code> 在经过 <code>initGlobalAPI</code> 之后，会变成这样：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">// src/core/index.js / src/core/global-api/index.js</span></div><div class="line">Vue.config</div><div class="line">Vue.util = util</div><div class="line">Vue.set = set</div><div class="line">Vue.delete = del</div><div class="line">Vue.nextTick = util.nextTick</div><div class="line">Vue.options = &#123;</div><div class="line">    components: &#123;</div><div class="line">        KeepAlive</div><div class="line">    &#125;,</div><div class="line">    directives: &#123;&#125;,</div><div class="line">    filters: &#123;&#125;,</div><div class="line">    _base: Vue</div><div class="line">&#125;</div><div class="line">Vue.use</div><div class="line">Vue.mixin</div><div class="line">Vue.cid = <span class="number">0</span></div><div class="line">Vue.extend</div><div class="line">Vue.component = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line">Vue.directive = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line">Vue.filter = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line"></div><div class="line">Vue.prototype.$isServer</div><div class="line">Vue.version = <span class="string">'__VERSION__'</span></div></pre></td></tr></table></figure></p><p>其中，稍微复杂一点的就是 <code>Vue.options</code>，大家稍微分析分析就会知道他的确长成那个样子。下一个就是 <code>web-runtime.js</code> 文件了，<code>web-runtime.js</code> 文件主要做了三件事儿：</p><ol><li>覆盖 <code>Vue.config</code> 的属性，将其设置为平台特有的一些方法</li><li><code>Vue.options.directives</code> 和 <code>Vue.options.components</code> 安装平台特有的指令和组件</li><li>在 <code>Vue.prototype</code> 上定义 <code>__patch__</code> 和 <code>$mount</code></li></ol><p>经过 <code>web-runtime.js</code> 文件之后，<code>Vue</code> 变成下面这个样子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">// 安装平台特定的utils</span></div><div class="line">Vue.config.isUnknownElement = isUnknownElement</div><div class="line">Vue.config.isReservedTag = isReservedTag</div><div class="line">Vue.config.getTagNamespace = getTagNamespace</div><div class="line">Vue.config.mustUseProp = mustUseProp</div><div class="line"><span class="comment">// 安装平台特定的 指令 和 组件</span></div><div class="line">Vue.options = &#123;</div><div class="line">    components: &#123;</div><div class="line">        KeepAlive,</div><div class="line">        Transition,</div><div class="line">        TransitionGroup</div><div class="line">    &#125;,</div><div class="line">    directives: &#123;</div><div class="line">        model,</div><div class="line">        show</div><div class="line">    &#125;,</div><div class="line">    filters: &#123;&#125;,</div><div class="line">    _base: Vue</div><div class="line">&#125;</div><div class="line">Vue.prototype.__patch__</div><div class="line">Vue.prototype.$mount</div></pre></td></tr></table></figure></p><p>这里大家要注意的是 <code>Vue.options</code> 的变化。另外这里的 <code>$mount</code> 方法很简单：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">Vue.prototype.$mount = <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></div><div class="line"><span class="function"><span class="params">  el?: string | Element,</span></span></div><div class="line"><span class="function"><span class="params">  hydrating?: boolean</span></span></div><div class="line"><span class="function"><span class="params"></span>): <span class="title">Component</span> </span>&#123;</div><div class="line">  el = el &amp;&amp; inBrowser ? query(el) : <span class="literal">undefined</span></div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>._mount(el, hydrating)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>首先根据是否是浏览器环境决定要不要 <code>query(el)</code> 获取元素，然后将 <code>el</code> 作为参数传递给 <code>this._mount()</code>。<br>最后一个处理 <code>Vue</code> 的文件就是入口文件 <code>web-runtime-with-compiler.js</code> 了，该文件做了两件事：</p><ol><li>缓存来自 <code>web-runtime.js</code> 文件的 <code>$mount</code> 函数 <code>const mount = Vue.prototype.$mount</code> 然后覆盖覆盖了 Vue.prototype.$mount</li><li>在 <code>Vue</code> 上挂载 <code>compile</code>   <code>Vue.compile = compileToFunctions</code> ,  <code>compileToFunctions</code> 函数的作用，就是将模板 <code>template</code> 编译为<code>render</code>函数。</li></ol><p>至此，我们算是还原了 Vue 构造函数，总结一下：</p><ol><li><code>Vue.prototype</code> 下的属性和方法的挂载主要是在 <code>src/core/instance</code> 目录中的代码处理的</li><li><code>Vue</code> 下的静态属性和方法的挂载主要是在 <code>src/core/global-api</code> 目录下的代码处理的</li><li><code>web-runtime.js</code> 主要是添加web平台特有的配置、组件和指令，<code>web-runtime-with-compiler.js</code> 给<code>Vue</code>的 <code>$mount</code> 方法添加 <code>compiler</code> 编译器，支持 <code>template</code>。</li></ol><h1 id="一个贯穿始终的例子"><a href="#一个贯穿始终的例子" class="headerlink" title="一个贯穿始终的例子"></a>一个贯穿始终的例子</h1><p>在了解了 <code>Vue</code> 构造函数的设计之后，接下来，我们一个贯穿始终的例子就要登场了，掌声有请：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">let</span> v = <span class="keyword">new</span> Vue(&#123;</div><div class="line">el: <span class="string">'#app'</span>,</div><div class="line">data: &#123;</div><div class="line">a: <span class="number">1</span>,</div><div class="line">b: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div><div class="line">&#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p><p>好吧，我承认这段代码你家没满月的孩子都会写了。这段代码就是我们贯穿始终的例子，它就是这篇文章的主线，在后续的讲解中，都会以这段代码为例，当讲到必要的地方，会为其添加选项，比如讲计算属性的时候当然要加上一个 <code>computed</code> 属性了。不过在最开始，我只传递了两个选项 <code>el</code> 以及 <code>data</code>，“我们看看接下来会发生什么，让我们拭目以待“ —- NBA球星在接受采访时最喜欢说这句话。<br><em>当我们按照例子那样编码使用Vue的时候，Vue都做了什么？</em><br>想要知道Vue都干了什么，我们就要找到 Vue 初始化程序，查看 Vue 构造函数：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Vue</span> (<span class="params">options</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp;</div><div class="line">    !(<span class="keyword">this</span> <span class="keyword">instanceof</span> Vue)) &#123;</div><div class="line">    warn(<span class="string">'Vue is a constructor and should be called with the `new` keyword'</span>)</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">this</span>._init(options)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>我们发现，<code>_init()</code> 方法就是<code>Vue</code>调用的第一个方法，然后将我们的参数 <code>options</code> 透传了过去。在调用 <code>_init()</code> 之前，还做了一个安全模式的处理，告诉开发者必须使用 <code>new</code> 操作符调用 <code>Vue</code>。根据之前我们的整理，<code>_init()</code> 方法应该是在 <code>src/core/instance/init.js</code> 文件中定义的，我们打开这个文件查看 <code>_init()</code> 方法：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">Vue.prototype._init = <span class="function"><span class="keyword">function</span> (<span class="params">options?: Object</span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> vm: Component = <span class="keyword">this</span></div><div class="line">  <span class="comment">// a uid</span></div><div class="line">  vm._uid = uid++</div><div class="line">  <span class="comment">// a flag to avoid this being observed</span></div><div class="line">  vm._isVue = <span class="literal">true</span></div><div class="line">  <span class="comment">// merge options</span></div><div class="line">  <span class="keyword">if</span> (options &amp;&amp; options._isComponent) &#123;</div><div class="line">    <span class="comment">// optimize internal component instantiation</span></div><div class="line">    <span class="comment">// since dynamic options merging is pretty slow, and none of the</span></div><div class="line">    <span class="comment">// internal component options needs special treatment.</span></div><div class="line">    initInternalComponent(vm, options)</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    vm.$options = mergeOptions(</div><div class="line">      resolveConstructorOptions(vm.constructor),</div><div class="line">      options || &#123;&#125;,</div><div class="line">      vm</div><div class="line">    )</div><div class="line">  &#125;</div><div class="line">  <span class="comment">/* istanbul ignore else */</span></div><div class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</div><div class="line">    initProxy(vm)</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    vm._renderProxy = vm</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// expose real self</span></div><div class="line">  vm._self = vm</div><div class="line">  initLifecycle(vm)</div><div class="line">  initEvents(vm)</div><div class="line">  callHook(vm, <span class="string">'beforeCreate'</span>)</div><div class="line">  initState(vm)</div><div class="line">  callHook(vm, <span class="string">'created'</span>)</div><div class="line">  initRender(vm)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><code>_init()</code> 方法在一开始的时候，在 <code>this</code> 对象上定义了两个属性：<code>_uid</code> 和 <code>_isVue</code>，然后判断有没有定义 <code>options._isComponent</code>，在使用 V<code>ue</code> 开发项目的时候，我们是不会使用 <code>_isComponent</code> 选项的，这个选项是 <code>Vue</code> 内部使用的，按照本节开头的例子，这里会走 <code>else</code> 分支，也就是这段代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">vm.$options = mergeOptions(</div><div class="line">  resolveConstructorOptions(vm.constructor),</div><div class="line">  options || &#123;&#125;,</div><div class="line">  vm</div><div class="line">)</div></pre></td></tr></table></figure></p><p>这样 <code>Vue</code> 第一步所做的事情就来了：<em><span style="color: red">使用策略对象合并参数选项</span></em><br>可以发现，<code>Vue</code>使用 <code>mergeOptions</code> 来处理我们调用Vue时传入的参数选项(options)，然后将返回值赋值给 <code>this.$options (vm === this)</code>，传给 <code>mergeOptions</code> 方法三个参数，我们分别来看一看，首先是：<code>resolveConstructorOptions(vm.constructor)</code>，我们查看一下这个方法：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">resolveConstructorOptions</span> (<span class="params">Ctor: Class&lt;Component&gt;</span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> options = Ctor.options</div><div class="line">  <span class="keyword">if</span> (Ctor.super) &#123;</div><div class="line">    <span class="keyword">const</span> superOptions = Ctor.super.options</div><div class="line">    <span class="keyword">const</span> cachedSuperOptions = Ctor.superOptions</div><div class="line">    <span class="keyword">const</span> extendOptions = Ctor.extendOptions</div><div class="line">    <span class="keyword">if</span> (superOptions !== cachedSuperOptions) &#123;</div><div class="line">      <span class="comment">// super option changed</span></div><div class="line">      Ctor.superOptions = superOptions</div><div class="line">      extendOptions.render = options.render</div><div class="line">      extendOptions.staticRenderFns = options.staticRenderFns</div><div class="line">      extendOptions._scopeId = options._scopeId</div><div class="line">      options = Ctor.options = mergeOptions(superOptions, extendOptions)</div><div class="line">      <span class="keyword">if</span> (options.name) &#123;</div><div class="line">        options.components[options.name] = Ctor</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> options</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这个方法接收一个参数 <code>Ctor</code>，通过传入的 <code>vm.constructor</code> 我们可以知道，其实就是 <code>Vue</code> 构造函数本身。所以下面这句代码：<code>let options = Ctor.options</code>, 相当于：<code>let options = Vue.options</code></p><p>大家还记得 <code>Vue.options</code> 吗？在寻找Vue构造函数一节里，我们整理了 <code>Vue.options</code> 应该长成下面这个样子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Vue.options = &#123;</div><div class="line">    components: &#123;</div><div class="line">        KeepAlive,</div><div class="line">        Transition,</div><div class="line">        TransitionGroup</div><div class="line">    &#125;,</div><div class="line">    directives: &#123;</div><div class="line">        model,</div><div class="line">        show</div><div class="line">    &#125;,</div><div class="line">    filters: &#123;&#125;,</div><div class="line">    _base: Vue</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>之后判断是否定义了 <code>Vue.super</code> ，这个是用来处理继承的，我们后续再讲，在本例中，<code>resolveConstructorOption</code>s 方法直接返回了 <code>Vue.options</code>。也就是说，传递给 <code>mergeOptions</code> 方法的第一个参数就是 <code>Vue.options</code>。<br>传给 <code>mergeOptions</code> 方法的第二个参数是我们调用<code>Vue</code>构造函数时的参数选项，第三个参数是 <code>vm</code> 也就是 <code>this</code> 对象，按照本节开头的例子那样使用 <code>Vue</code>，最终运行的代码应该如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">vm.$options = mergeOptions(</div><div class="line"> <span class="comment">// Vue.options</span></div><div class="line">   &#123;</div><div class="line">    components: &#123;</div><div class="line">        KeepAlive,</div><div class="line">        Transition,</div><div class="line">        TransitionGroup</div><div class="line">    &#125;,</div><div class="line">    directives: &#123;</div><div class="line">        model,</div><div class="line">        show</div><div class="line">    &#125;,</div><div class="line">    filters: &#123;&#125;,</div><div class="line">    _base: Vue</div><div class="line">&#125;,</div><div class="line"><span class="comment">// 调用Vue构造函数时传入的参数选项 options</span></div><div class="line">   &#123;</div><div class="line">   el: <span class="string">'#app'</span>,</div><div class="line">data: &#123;</div><div class="line">a: <span class="number">1</span>,</div><div class="line">b: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div><div class="line">&#125;</div><div class="line">   &#125;,</div><div class="line">   <span class="comment">// this</span></div><div class="line">   vm</div><div class="line"> )</div></pre></td></tr></table></figure></p><p>了解了这些，我们就可以看看 <code>mergeOptions</code> 到底做了些什么了，根据引用寻找到 <code>mergeOptions</code> 应该是在 <code>src/core/util/options.js</code> 文件中定义的。这个文件第一次看可能会头大，下面是我处理后的简略展示，大家看上去应该更容易理解了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">// 1、引用依赖</div><div class="line">import Vue from &apos;../instance/index&apos;</div><div class="line">其他引用...</div><div class="line"></div><div class="line">// 2、合并父子选项值为最终值的策略对象，此时 strats 是一个空对象，因为 config.optionMergeStrategies = Object.create(null)</div><div class="line">const strats = config.optionMergeStrategies</div><div class="line">// 3、在 strats 对象上定义与参数选项名称相同的方法</div><div class="line">strats.el = </div><div class="line">strats.propsData = function (parent, child, vm, key)&#123;&#125;</div><div class="line">strats.data = function (parentVal, childVal, vm)</div><div class="line"></div><div class="line">config._lifecycleHooks.forEach(hook =&gt; &#123;</div><div class="line">  strats[hook] = mergeHook</div><div class="line">&#125;)</div><div class="line"></div><div class="line">config._assetTypes.forEach(function (type) &#123;</div><div class="line">  strats[type + &apos;s&apos;] = mergeAssets</div><div class="line">&#125;)</div><div class="line"></div><div class="line">strats.watch = function (parentVal, childVal)</div><div class="line"></div><div class="line">strats.props =</div><div class="line">strats.methods =</div><div class="line">strats.computed = function (parentVal: ?Object, childVal: ?Object)</div><div class="line">// 默认的合并策略，如果有 `childVal` 则返回 `childVal` 没有则返回 `parentVal`</div><div class="line">const defaultStrat = function (parentVal: any, childVal: any): any &#123;</div><div class="line">  return childVal === undefined</div><div class="line">    ? parentVal</div><div class="line">    : childVal</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 4、mergeOptions 中根据参数选项调用同名的策略方法进行合并处理</div><div class="line">export function mergeOptions (</div><div class="line">  parent: Object,</div><div class="line">  child: Object,</div><div class="line">  vm?: Component</div><div class="line">): Object &#123;</div><div class="line"></div><div class="line">  // 其他代码</div><div class="line">  ...</div><div class="line"></div><div class="line">  const options = &#123;&#125;</div><div class="line">  let key</div><div class="line">  for (key in parent) &#123;</div><div class="line">    mergeField(key)</div><div class="line">  &#125;</div><div class="line">  for (key in child) &#123;</div><div class="line">    if (!hasOwn(parent, key)) &#123;</div><div class="line">      mergeField(key)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  function mergeField (key) &#123;</div><div class="line">    const strat = strats[key] || defaultStrat</div><div class="line">    options[key] = strat(parent[key], child[key], vm, key)</div><div class="line">  &#125;</div><div class="line">  return options</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>上面的代码中，我省略了一些工具函数，例如 <code>mergeHook</code> 和 <code>mergeAssets</code> 等等，唯一需要注意的是这段代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">config._lifecycleHooks.forEach(<span class="function"><span class="params">hook</span> =&gt;</span> &#123;</div><div class="line">  strats[hook] = mergeHook</div><div class="line">&#125;)</div><div class="line"></div><div class="line">config._assetTypes.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">type</span>) </span>&#123;</div><div class="line">  strats[type + <span class="string">'s'</span>] = mergeAssets</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p><p><code>config</code> 对象引用自<code>src/core/config.js</code> 文件，最终的结果就是在 <code>strats</code> 下添加了相应的生命周期选项的合并策略函数为 <code>mergeHook</code>，添加指令(<code>directives</code>)、组件(<code>components</code>)、过滤器(<code>filters</code>)等选项的合并策略函数为 <code>mergeAssets</code>。<br>这样看来就清晰多了，拿我们贯穿本文的例子来说：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">let v = new Vue(&#123;</div><div class="line">el: &apos;#app&apos;,</div><div class="line">data: &#123;</div><div class="line">a: 1,</div><div class="line">b: [1, 2, 3]</div><div class="line">&#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p><p>其中 <code>el</code> 选项会使用 <code>defaultStrat</code> 默认策略函数处理，<code>data</code> 选项则会使用 <code>strats.data</code> 策略函数处理，并且根据 <code>strats.data</code> 中的逻辑，<code>strats.data</code> 方法最终会返回一个函数：<code>mergedInstanceDataFn</code>。<br>这里就不详细的讲解每一个策略函数的内容了，后续都会讲到，这里我们还是抓住主线理清思路为主，只需要知道Vue在处理选项的时候，使用了一个策略对象对父子选项进行合并。并将最终的值赋值给实例下的 <code>$options</code> 属性即：<code>this.$options</code>，那么我们继续查看 <code>_init()</code> 方法在合并完选项之后，又做了什么：<br>合并完选项之后，<code>Vue</code> 第二部做的事情就来了：初始化工作与<code>Vue</code>实例对象的设计<br>前面讲了 <code>Vue</code> 构造函数的设计，并且整理了 Vue原型属性与方法 和 Vue静态属性与方法，而 Vue 实例对象就是通过构造函数创造出来的，让我们来看一看 Vue 实例对象是如何设计的，下面的代码是 <code>_init()</code> 方法合并完选项之后的代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/* istanbul ignore else */</span></div><div class="line">   <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</div><div class="line">     initProxy(vm)</div><div class="line">   &#125; <span class="keyword">else</span> &#123;</div><div class="line">     vm._renderProxy = vm</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="comment">// expose real self</span></div><div class="line">vm._self = vm</div><div class="line">   initLifecycle(vm)</div><div class="line">   initEvents(vm)</div><div class="line">   callHook(vm, <span class="string">'beforeCreate'</span>)</div><div class="line">   initState(vm)</div><div class="line">   callHook(vm, <span class="string">'created'</span>)</div><div class="line">   initRender(vm)</div></pre></td></tr></table></figure></p><p>根据上面的代码，在生产环境下会为实例添加两个属性，并且属性值都为实例本身：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">vm._renderProxy = vm</div><div class="line">vm._self = vm</div></pre></td></tr></table></figure></p><p>然后，调用了四个 <code>init*</code> 方法分别为：<code>initLifecycle</code>、<code>initEvents</code>、<code>initState</code>、<code>initRender</code>，且在 <code>initState</code> 前后分别回调了生命周期钩子 <code>beforeCreate</code> 和 <code>created</code>，而 <code>initRender</code> 是在 <code>created</code> 钩子执行之后执行的，看到这里，也就明白了为什么 <code>created</code> 的时候不能操作DOM了。因为这个时候还没有渲染真正的DOM元素到文档中。<code>created</code> 仅仅代表数据状态的初始化完成。<br>根据四个 <code>init*</code> 方法的引用关系打开对应的文件查看对应的方法，我们发现，这些方法是在处理Vue实例对象，以及做一些初始化的工作，类似整理Vue构造函数一样，我同样针对Vue实例做了属性和方法的整理，如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">// 在 Vue.prototype._init 中添加的属性 **********************************************************</span></div><div class="line"><span class="keyword">this</span>._uid = uid++</div><div class="line"><span class="keyword">this</span>._isVue = <span class="literal">true</span></div><div class="line"><span class="keyword">this</span>.$options = &#123;</div><div class="line">    components,</div><div class="line">    directives,</div><div class="line">    filters,</div><div class="line">    _base,</div><div class="line">    el,</div><div class="line">    data: mergedInstanceDataFn()</div><div class="line">&#125;</div><div class="line"><span class="keyword">this</span>._renderProxy = <span class="keyword">this</span></div><div class="line"><span class="keyword">this</span>._self = <span class="keyword">this</span></div><div class="line"></div><div class="line"><span class="comment">// 在 initLifecycle 中添加的属性**********************************************************</span></div><div class="line"><span class="keyword">this</span>.$parent = parent</div><div class="line"><span class="keyword">this</span>.$root = parent ? parent.$root : <span class="keyword">this</span></div><div class="line"> </div><div class="line"><span class="keyword">this</span>.$children = []</div><div class="line"><span class="keyword">this</span>.$refs = &#123;&#125;</div><div class="line"></div><div class="line"><span class="keyword">this</span>._watcher = <span class="literal">null</span></div><div class="line"><span class="keyword">this</span>._inactive = <span class="literal">false</span></div><div class="line"><span class="keyword">this</span>._isMounted = <span class="literal">false</span></div><div class="line"><span class="keyword">this</span>._isDestroyed = <span class="literal">false</span></div><div class="line"><span class="keyword">this</span>._isBeingDestroyed = <span class="literal">false</span></div><div class="line"></div><div class="line"><span class="comment">// 在 initEvents 中添加的属性 **********************************************************</span></div><div class="line"><span class="keyword">this</span>._events = &#123;&#125;</div><div class="line"><span class="keyword">this</span>._updateListeners = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="comment">// 在 initState 中添加的属性**********************************************************</span></div><div class="line"><span class="keyword">this</span>._watchers = []</div><div class="line">    <span class="comment">// initData</span></div><div class="line">    <span class="keyword">this</span>._data</div><div class="line"></div><div class="line"><span class="comment">// 在 initRender 中添加的属性 **********************************************************</span></div><div class="line"><span class="keyword">this</span>.$vnode = <span class="literal">null</span> <span class="comment">// the placeholder node in parent tree</span></div><div class="line"><span class="keyword">this</span>._vnode = <span class="literal">null</span> <span class="comment">// the root of the child tree</span></div><div class="line"><span class="keyword">this</span>._staticTrees = <span class="literal">null</span></div><div class="line"><span class="keyword">this</span>.$slots</div><div class="line"><span class="keyword">this</span>.$scopedSlots</div><div class="line"><span class="keyword">this</span>._c</div><div class="line"><span class="keyword">this</span>.$createElement</div></pre></td></tr></table></figure></p><p>以上就是一个Vue实例所包含的属性和方法，除此之外要注意的是，在 <code>initEvents</code> 中除了添加属性之外，如果有 <code>vm.$options._parentListeners</code> 还要调用 <code>vm._updateListeners()</code> 方法，在 <code>initState</code> 中又调用了一些其他<code>init</code>方法，如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initState</span> (<span class="params">vm: Component</span>) </span>&#123;</div><div class="line">  vm._watchers = []</div><div class="line">  initProps(vm)</div><div class="line">  initMethods(vm)</div><div class="line">  initData(vm)</div><div class="line">  initComputed(vm)</div><div class="line">  initWatch(vm)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>最后在 <code>initRender</code> 中如果有 <code>vm.$options.el</code> 还要调用 <code>vm.$mount(vm.$options.el)</code>，如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (vm.$options.el) &#123;</div><div class="line">  vm.$mount(vm.$options.el)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这就是为什么如果不传递 <code>el</code> 选项就需要手动 <code>mount</code> 的原因了。<br>那么我们依照我们本节开头的的例子，以及初始化的先后顺序来逐一看一看都发生了什么。我们将 <code>initState</code> 中的 <code>init*</code> 方法展开来看，执行顺序应该是这样的（从上到下的顺序执行）：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">initLifecycle(vm)</div><div class="line">initEvents(vm)</div><div class="line">callHook(vm, <span class="string">'beforeCreate'</span>)</div><div class="line">initProps(vm)</div><div class="line">initMethods(vm)</div><div class="line">initData(vm)</div><div class="line">initComputed(vm)</div><div class="line">initWatch(vm)</div><div class="line">callHook(vm, <span class="string">'created'</span>)</div><div class="line">initRender(vm)</div></pre></td></tr></table></figure></p><p>首先是 <code>initLifecycle</code>，这个函数的作用就是在实例上添加一些属性，然后是 <code>initEvents</code>，由于 <code>vm.$options._parentListeners</code> 的值为 <code>undefined</code> 所以也仅仅是在实例上添加属性， <code>vm._updateListeners(listeners)</code> 并不会执行，由于我们只传递了 <code>el</code> 和 <code>data</code>，所以 <code>initProps</code>、<code>initMethods</code>、<code>initComputed</code>、<code>initWatch</code> 这四个方法什么都不会做，只有 <code>initData</code> 会执行。最后是 <code>initRender</code>，除了在实例上添加一些属性外，由于我们传递了 <code>el</code> 选项，所以会执行 <code>vm.$mount(vm.$options.el)</code>。<br>综上所述：按照我们的例子那样写，初始化工作只包含两个主要内容即：<code>initData</code> 和 <code>initRender</code>。</p><h1 id="通过initData看Vue的数据响应系统"><a href="#通过initData看Vue的数据响应系统" class="headerlink" title="通过initData看Vue的数据响应系统"></a>通过initData看Vue的数据响应系统</h1><p>Vue的数据响应系统包含三个部分：<code>Observer</code>、<code>Dep</code>、<code>Watcher</code>。关于数据响应系统的内容真的已经被文章讲烂了，所以我就简单的说一下，力求大家能理解就ok，我们还是先看一下 <code>initData</code> 中的代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">initData</span> (<span class="params">vm: Component</span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> data = vm.$options.data</div><div class="line">  data = vm._data = <span class="keyword">typeof</span> data === <span class="string">'function'</span></div><div class="line">    ? data.call(vm)</div><div class="line">    : data || &#123;&#125;</div><div class="line">  <span class="keyword">if</span> (!isPlainObject(data)) &#123;</div><div class="line">    data = &#123;&#125;</div><div class="line">    process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; warn(</div><div class="line">      <span class="string">'data functions should return an object:\n'</span> +</div><div class="line">      <span class="string">'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function'</span>,</div><div class="line">      vm</div><div class="line">    )</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// proxy data on instance</span></div><div class="line">  <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(data)</div><div class="line">  <span class="keyword">const</span> props = vm.$options.props</div><div class="line">  <span class="keyword">let</span> i = keys.length</div><div class="line">  <span class="keyword">while</span> (i--) &#123;</div><div class="line">    <span class="keyword">if</span> (props &amp;&amp; hasOwn(props, keys[i])) &#123;</div><div class="line">      process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; warn(</div><div class="line">        <span class="string">`The data property "<span class="subst">$&#123;keys[i]&#125;</span>" is already declared as a prop. `</span> +</div><div class="line">        <span class="string">`Use prop default value instead.`</span>,</div><div class="line">        vm</div><div class="line">      )</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      proxy(vm, keys[i])</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// observe data</span></div><div class="line">  observe(data)</div><div class="line">  data.__ob__ &amp;&amp; data.__ob__.vmCount++</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>首先，先拿到 <code>data</code> 数据：<code>let data = vm.$options.data</code>，大家还记得此时<code>vm.$options.data</code> 的值应该是通过 <code>mergeOptions</code> 合并处理后的 <code>mergedInstanceDataFn</code> 函数吗？所以在得到 <code>data</code> 后，它又判断了 <code>data</code> 的数据类型是不是 ‘function’，最终的结果是：<code>data</code> 还是我们传入的数据选项的 <code>data</code>，即：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">data: &#123;</div><div class="line">a: <span class="number">1</span>,</div><div class="line">b: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>然后在实例对象上定义 <code>_data</code> 属性，该属性与 <code>data</code> 是相同的引用。<br>然后是一个 <code>while</code> 循环，循环的目的是在实例对象上对数据进行代理，这样我们就能通过 <code>this.a</code> 来访问 <code>data.a</code> 了，代码的处理是在 <code>proxy</code> 函数中，该函数非常简单，仅仅是在实例对象上设置与 <code>data</code> 属性同名的访问器属性，然后使用 <code>_data</code> 做数据劫持，如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">proxy</span> (<span class="params">vm: Component, key: string</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (!isReserved(key)) &#123;</div><div class="line">    <span class="built_in">Object</span>.defineProperty(vm, key, &#123;</div><div class="line">      configurable: <span class="literal">true</span>,</div><div class="line">      enumerable: <span class="literal">true</span>,</div><div class="line">      get: <span class="function"><span class="keyword">function</span> <span class="title">proxyGetter</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> vm._data[key]</div><div class="line">      &#125;,</div><div class="line">      set: <span class="function"><span class="keyword">function</span> <span class="title">proxySetter</span> (<span class="params">val</span>) </span>&#123;</div><div class="line">        vm._data[key] = val</div><div class="line">      &#125;</div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>做完数据的代理，就正式进入响应系统，<code>**observe(data)**</code></p><p>我们说过，数据响应系统主要包含三部分：<code>Observer</code>、<code>Dep</code>、<code>Watcher</code>，代码分别存放在：<code>observer/index.js</code>、<code>observer/dep.js</code> 以及 <code>observer/watcher.js</code> 文件中，这回我们换一种方式，我们先不看其源码，大家先跟着我的思路来思考，最后回头再去看代码，你会有一种：”奥，不过如此“的感觉。<br>假如，我们有如下代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> data = &#123;</div><div class="line">    a: <span class="number">1</span>,</div><div class="line">    b: &#123;</div><div class="line">        c: <span class="number">2</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">observer(data)</div><div class="line"></div><div class="line"><span class="keyword">new</span> Watch(<span class="string">'a'</span>, () =&gt; &#123;</div><div class="line">    alert(<span class="number">9</span>)</div><div class="line">&#125;)</div><div class="line"><span class="keyword">new</span> Watch(<span class="string">'a'</span>, () =&gt; &#123;</div><div class="line">    alert(<span class="number">90</span>)</div><div class="line">&#125;)</div><div class="line"><span class="keyword">new</span> Watch(<span class="string">'b.c'</span>, () =&gt; &#123;</div><div class="line">    alert(<span class="number">80</span>)</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p><p>这段代码目的是，首先定义一个数据对象 <code>data</code>，然后通过 <code>observer</code> 对其进行观测，之后定义了三个观察者，当数据有变化时，执行相应的方法，这个功能使用Vue的实现原来要如何去实现？其实就是在问 <code>observer</code> 怎么写？<code>Watch</code> 构造函数又怎么写？接下来我们逐一实现。<br>首先，<code>observer</code> 的作用是：将数据对象<code>data</code>的属性转换为访问器属性：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span> (data) &#123;</div><div class="line">        <span class="keyword">this</span>.walk(data)</div><div class="line">    &#125;</div><div class="line">    walk (data) &#123;</div><div class="line">        <span class="comment">// 遍历 data 对象属性，调用 defineReactive 方法</span></div><div class="line">        <span class="keyword">let</span> keys = <span class="built_in">Object</span>.keys(data)</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keys.length; i++)&#123;</div><div class="line">            defineReactive(data, keys[i], data[keys[i]])</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// defineReactive方法仅仅将data的属性转换为访问器属性</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span> (<span class="params">data, key, val</span>) </span>&#123;</div><div class="line"><span class="comment">// 递归观测子属性</span></div><div class="line">    observer(val)</div><div class="line"></div><div class="line">    <span class="built_in">Object</span>.defineProperty(data, key, &#123;</div><div class="line">        enumerable: <span class="literal">true</span>,</div><div class="line">        configurable: <span class="literal">true</span>,</div><div class="line">        get: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> val</div><div class="line">        &#125;,</div><div class="line">        set: <span class="function"><span class="keyword">function</span> (<span class="params">newVal</span>) </span>&#123;</div><div class="line">            <span class="keyword">if</span>(val === newVal)&#123;</div><div class="line">                <span class="keyword">return</span></div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 对新值进行观测</span></div><div class="line">            observer(newVal)</div><div class="line">        &#125;</div><div class="line">    &#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// observer 方法首先判断data是不是纯JavaScript对象，如果是，调用 Observer 类进行观测</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">observer</span> (<span class="params">data</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="built_in">Object</span>.prototype.toString.call(data) !== <span class="string">'[object Object]'</span>) &#123;</div><div class="line">        <span class="keyword">return</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">new</span> Observer(data)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>上面的代码中，我们定义了 <code>observer</code> 方法，该方法检测了数据<code>data</code>是不是纯<code>JavaScript</code>对象，如果是就调用 <code>Observer</code> 类，并将 <code>data</code> 作为参数透传。在 <code>Observer</code> 类中，我们使用 <code>walk</code> 方法对数据<code>data</code>的属性循环调用 <code>defineReactive</code> 方法，<code>defineReactive</code> 方法很简单，仅仅是将数据<code>data</code>的属性转为访问器属性，并对数据进行递归观测，否则只能观测数据data的直属子属性。这样我们的第一步工作就完成了，当我们修改或者获取data属性值的时候，通过 <code>get</code> 和 <code>set</code> 即能获取到通知。<br>我们继续往下看，来看一下 <code>Watch</code>：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> Watch(<span class="string">'a'</span>, () =&gt; &#123;</div><div class="line">    alert(<span class="number">9</span>)</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p><p>现在的问题是，<code>Watch</code> 要怎么和 <code>observer</code> 关联？？？？？？？我们看看 <code>Watch</code> 它知道些什么，通过上面调用 <code>Watch</code> 的方式，传递给 <code>Watch</code> 两个参数，一个是 ‘a’ 我们可以称其为表达式，另外一个是回调函数。所以我们目前只能写出这样的代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watch</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span> (exp, fn) &#123;</div><div class="line">        <span class="keyword">this</span>.exp = exp</div><div class="line">        <span class="keyword">this</span>.fn = fn</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>那么要怎么关联呢，大家看下面的代码会发生什么：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watch</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span> (exp, fn) &#123;</div><div class="line">        <span class="keyword">this</span>.exp = exp</div><div class="line">        <span class="keyword">this</span>.fn = fn</div><div class="line">        data[exp]</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>多了一句 <code>data[exp]</code>，这句话是在干什么？是不是在获取 <code>data</code> 下某个属性的值，比如 <code>exp</code> 为 ‘a’ 的话，那么 <code>data[exp]</code> 就相当于在获取 <code>data.a</code>的值，那这会放生什么？大家不要忘了，此时数据 <code>data</code> 下的属性已经是访问器属性了，所以这么做的结果会直接触发对应属性的 <code>get</code> 函数，这样我们就成功的和 <code>observer</code> 产生了关联，但这样还不够，我们还是没有达到目的，不过我们已经无限接近了，我们继续思考看一下可不可以这样：</p><blockquote><p>既然在 <code>Watch</code> 中对表达式求值，能够触发 <code>observer</code> 的 <code>get</code>，那么可不可以在 <code>get</code> 中收集 <code>Watch</code> 中函数呢？<br>答案是可以的，不过这个时候我们就需要 <code>Dep</code> 出场了，它是一个依赖收集器。我们的思路是：<code>data</code> 下的每一个属性都有一个唯一的 <code>Dep</code> 对象，在 <code>get</code> 中收集仅针对该属性的依赖，然后在 <code>set</code> 方法中触发所有收集的依赖，这样就搞定了，看如下代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span> () &#123;</div><div class="line">        <span class="keyword">this</span>.subs = []</div><div class="line">    &#125;</div><div class="line">    addSub () &#123;</div><div class="line">        <span class="keyword">this</span>.subs.push(Dep.target)</div><div class="line">    &#125;</div><div class="line">    notify () &#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.subs.length; i++)&#123;</div><div class="line">            <span class="keyword">this</span>.subs[i].fn()</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">Dep.target = <span class="literal">null</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">pushTarget</span>(<span class="params">watch</span>)</span>&#123;</div><div class="line">    Dep.target = watch</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watch</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span> (exp, fn) &#123;</div><div class="line">        <span class="keyword">this</span>.exp = exp</div><div class="line">        <span class="keyword">this</span>.fn = fn</div><div class="line">        pushTarget(<span class="keyword">this</span>)</div><div class="line">        data[exp]</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p></blockquote><p>上面的代码中，我们在 <code>Watch</code> 中增加了<code>pushTarget(this)</code>，可以发现，这句代码的作用是将 <code>Dep.target</code> 的值设置为该<code>Watch</code>对象。在 <code>pushTarget</code> 之后我们才对表达式进行求值，接着，我们修改 <code>defineReactive</code> 代码如下<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span> (<span class="params">data, key, val</span>) </span>&#123;</div><div class="line">    observer(val)</div><div class="line">    <span class="keyword">let</span> dep = <span class="keyword">new</span> Dep()<span class="comment">// 新增</span></div><div class="line">    <span class="built_in">Object</span>.defineProperty(data, key, &#123;</div><div class="line">        enumerable: <span class="literal">true</span>,</div><div class="line">        configurable: <span class="literal">true</span>,</div><div class="line">        get: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            dep.addSub()<span class="comment">// 新增</span></div><div class="line">            <span class="keyword">return</span> val</div><div class="line">        &#125;,</div><div class="line">        set: <span class="function"><span class="keyword">function</span> (<span class="params">newVal</span>) </span>&#123;</div><div class="line">            <span class="keyword">if</span>(val === newVal)&#123;</div><div class="line">                <span class="keyword">return</span></div><div class="line">            &#125;</div><div class="line">            observer(newVal)</div><div class="line">            dep.notify()<span class="comment">// 新增</span></div><div class="line">        &#125;</div><div class="line">    &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>如标注，新增了三句代码，我们知道，<code>Watch</code> 中对表达式求值会触发 <code>get</code> 方法，我们在 <code>get</code> 方法中调用了 <code>dep.addSub</code>，也就执行了这句代码：<code>this.subs.push(Dep.target)</code>，由于在这句代码执行之前，<code>Dep.target</code>的值已经被设置为一个 <code>Watch</code> 对象了，所以最终结果就是收集了一个 <code>Watch</code> 对象，然后在 <code>set</code> 方法中我们调用了 <code>dep.notify</code>，所以当<code>data</code>属性值变化的时候，就会通过 <code>dep.notify</code>循环调用所有收集的<code>Watch</code>对象中的回调函数：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">notify () &#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.subs.length; i++)&#123;</div><div class="line">        <span class="keyword">this</span>.subs[i].fn()</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这样 <code>observer</code>、<code>Dep</code>、<code>Watch</code> 三者就联系成为一个有机的整体，实现了我们最初的目标，完整的代码可以戳这里：<code>observer-dep-watch</code>。这里还给大家挖了个坑，因为我们没有处理对数组的观测，由于比较复杂并且这又不是我们讨论的重点，如果大家想了解可以戳我的这篇文章：J<code>avaScript</code>实现MVVM之我就是想监测一个普通对象的变化，另外，在 <code>Watch</code> 中对表达式求值的时候也只做了直接子属性的求值，所以如果 <code>exp</code> 的值为 ‘a.b’ 的时候，就不可以用了，Vue的做法是使用 <code>.</code> 分割表达式字符串为数组，然后遍历一下对其进行求值，大家可以查看其源码。如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Parse simple path.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">const</span> bailRE = <span class="regexp">/[^\w.$]/</span></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">parsePath</span> (<span class="params">path: string</span>): <span class="title">any</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (bailRE.test(path)) &#123;</div><div class="line">    <span class="keyword">return</span></div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">const</span> segments = path.split(<span class="string">'.'</span>)</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</div><div class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; segments.length; i++) &#123;</div><div class="line">        <span class="keyword">if</span> (!obj) <span class="keyword">return</span></div><div class="line">        obj = obj[segments[i]]</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">return</span> obj</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><code>Vue</code> 的求值代码是在 <code>src/core/util/lang.js</code> 文件中 <code>parsePath</code> 函数中实现的。总结一下Vue的依赖收集过程应该是这样的：</p><p><img src="http://7xlolm.com1.z0.glb.clouddn.com/vueimgdep.png" alt=""></p><p>实际上，<code>Vue</code>并没有直接在 <code>get</code> 中调用 <code>addSub</code>，而是调用的 <code>dep.depend</code>，目的是将当前的 <code>dep</code> 对象收集到 <code>watch</code> 对象中，如果要完整的流程，应该是这样的：（大家注意数据的每一个字段都拥有自己的 <code>dep</code> 对象和 <code>get</code> 方法。）</p><p><img src="http://7xlolm.com1.z0.glb.clouddn.com/all.png" alt=""></p><p>这样 <code>Vue</code> 就建立了一套数据响应系统，之前我们说过，按照我们的例子那样写，初始化工作只包含两个主要内容即：<code>initData</code> 和 <code>initRender</code>。现在 <code>initData</code> 我们分析完了，接下来看一看 <code>initRender</code></p><h1 id="通过initRender看Vue的-render-渲染-与-re-render-重新渲染"><a href="#通过initRender看Vue的-render-渲染-与-re-render-重新渲染" class="headerlink" title="通过initRender看Vue的 render(渲染) 与 re-render(重新渲染)"></a>通过initRender看Vue的 render(渲染) 与 re-render(重新渲染)</h1><p>在 <code>initRender</code> 方法中，因为我们的例子中传递了 <code>el</code> 选项，所以下面的代码会执行：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (vm.$options.el) &#123;</div><div class="line">  vm.$mount(vm.$options.el)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这里，调用了 <code>$mount</code> 方法，在还原Vue构造函数的时候，我们整理过所有的方法，其中 <code>$mount</code> 方法在两个地方出现过：</p><ol><li>在 <code>web-runtime.js</code> 文件中：<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Vue.prototype.$mount = <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></div><div class="line"><span class="function"><span class="params">  el?: string | Element,</span></span></div><div class="line"><span class="function"><span class="params">  hydrating?: boolean</span></span></div><div class="line"><span class="function"><span class="params"></span>): <span class="title">Component</span> </span>&#123;</div><div class="line">  el = el &amp;&amp; inBrowser ? query(el) : <span class="literal">undefined</span></div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>._mount(el, hydrating)</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ol><p>它的作用是通过 <code>el</code> 获取相应的DOM元素，然后调用<code>lifecycle.js</code> 文件中的 <code>_mount</code> 方法。</p><ol><li>在 <code>web-runtime-with-compiler.js</code> 文件中：<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">// 缓存了来自 web-runtime.js 的 $mount 方法</span></div><div class="line"><span class="keyword">const</span> mount = Vue.prototype.$mount</div><div class="line"><span class="comment">// 重写 $mount 方法</span></div><div class="line">Vue.prototype.$mount = <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></div><div class="line"><span class="function"><span class="params">  el?: string | Element,</span></span></div><div class="line"><span class="function"><span class="params">  hydrating?: boolean</span></span></div><div class="line"><span class="function"><span class="params"></span>): <span class="title">Component</span> </span>&#123;</div><div class="line">  <span class="comment">// 根据 el 获取相应的DOM元素</span></div><div class="line">  el = el &amp;&amp; query(el)</div><div class="line">  <span class="comment">// 不允许你将 el 挂载到 html 标签或者 body 标签</span></div><div class="line">  <span class="keyword">if</span> (el === <span class="built_in">document</span>.body || el === <span class="built_in">document</span>.documentElement) &#123;</div><div class="line">    process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; warn(</div><div class="line">      <span class="string">`Do not mount Vue to &lt;html&gt; or &lt;body&gt; - mount to normal elements instead.`</span></div><div class="line">    )</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> options = <span class="keyword">this</span>.$options</div><div class="line">  <span class="comment">// 如果我们没有写 render 选项，那么就尝试将 template 或者 el 转化为 render 函数</span></div><div class="line">  <span class="keyword">if</span> (!options.render) &#123;</div><div class="line">    <span class="keyword">let</span> template = options.template</div><div class="line">    <span class="keyword">if</span> (template) &#123;</div><div class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> template === <span class="string">'string'</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (template.charAt(<span class="number">0</span>) === <span class="string">'#'</span>) &#123;</div><div class="line">          template = idToTemplate(template)</div><div class="line">          <span class="comment">/* istanbul ignore if */</span></div><div class="line">          <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; !template) &#123;</div><div class="line">            warn(</div><div class="line">              <span class="string">`Template element not found or is empty: <span class="subst">$&#123;options.template&#125;</span>`</span>,</div><div class="line">              <span class="keyword">this</span></div><div class="line">            )</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (template.nodeType) &#123;</div><div class="line">        template = template.innerHTML</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</div><div class="line">          warn(<span class="string">'invalid template option:'</span> + template, <span class="keyword">this</span>)</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span></div><div class="line">      &#125;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (el) &#123;</div><div class="line">      template = getOuterHTML(el)</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (template) &#123;</div><div class="line">      <span class="keyword">const</span> &#123; render, staticRenderFns &#125; = compileToFunctions(template, &#123;</div><div class="line">        warn,</div><div class="line">        shouldDecodeNewlines,</div><div class="line">        delimiters: options.delimiters</div><div class="line">      &#125;, <span class="keyword">this</span>)</div><div class="line">      options.render = render</div><div class="line">      options.staticRenderFns = staticRenderFns</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 调用已经缓存下来的 web-runtime.js 文件中的 $mount 方法</span></div><div class="line">  <span class="keyword">return</span> mount.call(<span class="keyword">this</span>, el, hydrating)</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ol><p>分析一下可知 <code>web-runtime-with-compiler.js</code> 的逻辑如下：</p><ol><li>缓存来自 <code>web-runtime.js</code> 文件的 <code>$mount</code> 方法</li><li>判断有没有传递 <code>render</code> 选项，如果有直接调用来自 <code>web-runtime.js</code> 文件的 <code>$mount</code> 方法</li><li>如果没有传递 <code>render</code> 选项，那么查看有没有 <code>template</code> 选项，如果有就使用 <code>compileToFunctions</code> 函数根据其内容编译成 <code>render</code> 函数</li><li>如果没有 <code>template</code> 选项，那么查看有没有 <code>el</code> 选项，如果有就使用 <code>compileToFunctions</code> 函数将其内容(<code>template = getOuterHTML(el)</code>)编译成 <code>render</code> 函数</li><li>将编译成的 <code>render</code> 函数挂载到 <code>this.$options</code> 属性下，并调用缓存下来的<code>web-runtime.js</code> 文件中的 <code>$mount</code> 方法<br>简单的用一张图表示 <code>mount</code> 方法的调用关系，从上至下调用：</li></ol><p><img src="http://7xlolm.com1.z0.glb.clouddn.com/vueimgmount.png" alt=""></p><p>不过不管怎样，我们发现这些步骤的最终目的是生成 render 函数，然后再调用 <code>lifecycle.js</code> 文件中的 <code>_mount</code> 方法，我们看看这个方法做了什么事情，查看 <code>_mount</code> 方法的代码，这是简化过得：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">Vue.prototype._mount = <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></div><div class="line"><span class="function"><span class="params">  el?: Element | void,</span></span></div><div class="line"><span class="function"><span class="params">  hydrating?: boolean</span></span></div><div class="line"><span class="function"><span class="params"></span>): <span class="title">Component</span> </span>&#123;</div><div class="line">  <span class="keyword">const</span> vm: Component = <span class="keyword">this</span></div><div class="line"></div><div class="line">  <span class="comment">// 在Vue实例对象上添加 $el 属性，指向挂载点元素</span></div><div class="line">  vm.$el = el</div><div class="line"></div><div class="line">  <span class="comment">// 触发 beforeMount 生命周期钩子</span></div><div class="line">  callHook(vm, <span class="string">'beforeMount'</span>)</div><div class="line"></div><div class="line">  vm._watcher = <span class="keyword">new</span> Watcher(vm, () =&gt; &#123;</div><div class="line">    vm._update(vm._render(), hydrating)</div><div class="line">  &#125;, noop)</div><div class="line"></div><div class="line">  <span class="comment">// 如果是第一次mount则触发 mounted 生命周期钩子</span></div><div class="line">  <span class="keyword">if</span> (vm.$vnode == <span class="literal">null</span>) &#123;</div><div class="line">    vm._isMounted = <span class="literal">true</span></div><div class="line">    callHook(vm, <span class="string">'mounted'</span>)</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> vm</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>上面的代码很简单，该注释的都注释了，唯一需要看的就是这段代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">vm._watcher = <span class="keyword">new</span> Watcher(vm, () =&gt; &#123;</div><div class="line">  vm._update(vm._render(), hydrating)</div><div class="line">&#125;, noop)</div></pre></td></tr></table></figure></p><p>看上去很眼熟有没有？我们平时使用Vue都是这样使用 <code>watch</code>的：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.$watch(<span class="string">'a'</span>, (newVal, oldVal) =&gt; &#123;</div><div class="line"></div><div class="line">&#125;)</div><div class="line"><span class="comment">// 或者</span></div><div class="line"><span class="keyword">this</span>.$watch(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line"><span class="keyword">return</span> <span class="keyword">this</span>.a + <span class="keyword">this</span>.b</div><div class="line">&#125;, (newVal, oldVal) =&gt; &#123;</div><div class="line"></div><div class="line">&#125;)</div></pre></td></tr></table></figure></p><p>第一个参数是 表达式或者函数，第二个参数是回调函数，第三个参数是可选的选项。原理是 <code>Watch</code> 内部对表达式求值或者对函数求值从而触发数据的 <code>get</code> 方法收集依赖。可是<code>_mount</code> 方法中使用 <code>Watcher</code> 的时候第一个参数 <code>vm</code> 是什么鬼。我们不妨去看看源码中 <code>$watch</code> 函数是如何实现的，根据之前还原Vue构造函数中所整理的内容可知：<code>$warch</code> 方法是在 <code>src/core/instance/state.js</code>文件中的 <code>stateMixin</code> 方法中定义的，源码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">Vue.prototype.$watch = <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></div><div class="line"><span class="function"><span class="params">  expOrFn: string | Function,</span></span></div><div class="line"><span class="function"><span class="params">  cb: Function,</span></span></div><div class="line"><span class="function"><span class="params">  options?: Object</span></span></div><div class="line"><span class="function"><span class="params"></span>): <span class="title">Function</span> </span>&#123;</div><div class="line">  <span class="keyword">const</span> vm: Component = <span class="keyword">this</span></div><div class="line">  options = options || &#123;&#125;</div><div class="line">  options.user = <span class="literal">true</span></div><div class="line">  <span class="keyword">const</span> watcher = <span class="keyword">new</span> Watcher(vm, expOrFn, cb, options)</div><div class="line">  <span class="keyword">if</span> (options.immediate) &#123;</div><div class="line">    cb.call(vm, watcher.value)</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">unwatchFn</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    watcher.teardown()</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>我们可以发现，<code>$warch</code> 其实是对 <code>Watcher</code> 的一个封装，内部的 <code>Watcher</code> 的第一个参数实际上也是 <code>vm</code> 即：<code>Vue</code>实例对象，这一点我们可以在<code>Watcher</code> 的源码中得到验证，代开 <code>observer/watcher.js</code> 文件查看：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">constructor</span> (</div><div class="line">    vm: Component,</div><div class="line">    expOrFn: string | Function,</div><div class="line">    cb: Function,</div><div class="line">    options?: Object = &#123;&#125;</div><div class="line">  ) &#123;</div><div class="line">    </div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>可以发现真正的 <code>Watcher</code> 第一个参数实际上就是 <code>vm</code>。第二个参数是表达式或者函数，然后以此类推，所以现在再来看 <code>_mount</code> 中的这段代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">vm._watcher = <span class="keyword">new</span> Watcher(vm, () =&gt; &#123;</div><div class="line">  vm._update(vm._render(), hydrating)</div><div class="line">&#125;, noop)</div></pre></td></tr></table></figure></p><p>忽略第一个参数 <code>vm</code>，也就说，<code>Watcher</code> 内部应该对第二个参数求值，也就是运行这个函数：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">() =&gt; &#123;</div><div class="line">  vm._update(vm._render(), hydrating)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>所以 <code>vm._render()</code> 函数被第一个执行，该函数在 <code>src/core/instance/render.js</code> 中，该方法中的代码很多，下面是简化过的：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">Vue.prototype._render = <span class="function"><span class="keyword">function</span> (<span class="params"></span>): <span class="title">VNode</span> </span>&#123;</div><div class="line">  <span class="keyword">const</span> vm: Component = <span class="keyword">this</span></div><div class="line">  <span class="comment">// 解构出 $options 中的 render 函数</span></div><div class="line">  <span class="keyword">const</span> &#123;</div><div class="line">    render,</div><div class="line">    staticRenderFns,</div><div class="line">    _parentVnode</div><div class="line">  &#125; = vm.$options</div><div class="line">  ...</div><div class="line"></div><div class="line">  <span class="keyword">let</span> vnode</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    <span class="comment">// 运行 render 函数</span></div><div class="line">    vnode = render.call(vm._renderProxy, vm.$createElement)</div><div class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</div><div class="line">    ...</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="comment">// set parent</span></div><div class="line">  vnode.parent = _parentVnode</div><div class="line">  <span class="keyword">return</span> vnode</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><code>_render</code> 方法首先从 <code>vm.$options</code> 中解构出 <code>render</code> 函数，大家应该记得：<code>vm</code>.<code>$options.render</code> 方法是在<code>web-runtime-with-compiler.js</code> 文件中通过 <code>compileToFunctions</code> 方法将 <code>template</code> 或 <code>el</code> 编译而来的。解构出 <code>render</code> 函数后，接下来便执行了该方法：</p><pre><code>vnode = render.call(vm._renderProxy, vm.$createElement)</code></pre><p>其中使用 <code>call</code> 指定了 <code>render</code> 函数的作用域环境为 <code>vm._renderProxy</code>，这个属性在我们整理实例对象的时候知道，他是在 <code>Vue.prototype._init</code> 方法中被添加的，即：<code>vm._renderProxy = vm</code>，其实就是Vue实例对象本身，然后传递了一个参数：<code>vm.$createElement</code>。那么 <code>render</code> 函数到底是干什么的呢？让我们根据上面那句代码猜一猜，我们已经知道 render 函数是从 <code>template</code> 或 <code>el</code> 编译而来的，如果没错的话应该是返回一个虚拟DOM对象。我们不妨使用 <code>console.log</code> 打印一下 <code>render</code> 函数，当我们的模板这样编写时：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;&#123;a&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div></pre></td></tr></table></figure></p><p>打印的 <code>render</code> 函数如下：</p><p><img src="http://7xlolm.com1.z0.glb.clouddn.com/vueimgr2.png" alt=""></p><p>其实了解Vue2.x版本的同学都知道，Vue提供了 <code>render</code> 选项，作为 <code>template</code> 的代替方案，同时为JavaScript提供了完全编程的能力，下面两种编写模板的方式实际是等价的：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 方案一：</span></div><div class="line"><span class="keyword">new</span> Vue(&#123;</div><div class="line">el: <span class="string">'#app'</span>,</div><div class="line">data: &#123;</div><div class="line">a: <span class="number">1</span></div><div class="line">&#125;,</div><div class="line">template: <span class="string">'&lt;ul&gt;&lt;li&gt;&#123;&#123;a&#125;&#125;&lt;/li&gt;&lt;li&gt;&#123;&#123;a&#125;&#125;&lt;/li&gt;&lt;/ul&gt;'</span></div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">// 方案二：</span></div><div class="line"><span class="keyword">new</span> Vue(&#123;</div><div class="line">el: <span class="string">'#app'</span>,</div><div class="line">render: <span class="function"><span class="keyword">function</span> (<span class="params">createElement</span>) </span>&#123;</div><div class="line">createElement(<span class="string">'ul'</span>, [</div><div class="line">createElement(<span class="string">'li'</span>, <span class="keyword">this</span>.a),</div><div class="line">createElement(<span class="string">'li'</span>, <span class="keyword">this</span>.a)</div><div class="line">])</div><div class="line">&#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p><p>现在我们再来看我们打印的 <code>render</code> 函数：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">anonymous</span>(<span class="params"></span>) </span>&#123;</div><div class="line"><span class="keyword">with</span>(<span class="keyword">this</span>)&#123;</div><div class="line"><span class="keyword">return</span> _c(<span class="string">'ul'</span>, &#123; </div><div class="line">attrs: &#123;<span class="string">"id"</span>: <span class="string">"app"</span>&#125;</div><div class="line">&#125;,[</div><div class="line">_c(<span class="string">'li'</span>, [_v(_s(a))])</div><div class="line">])</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>是不是与我们自己写 <code>render</code> 函数很像？因为 <code>render</code> 函数的作用域被绑定到了Vue实例，即：<code>render.call(vm._renderProxy</code>, v<code>m.$createElement)</code>，所以上面代码中 <code>_c</code>、<code>_v</code>、<code>_s</code> 以及变量 <code>a</code>相当于Vue实例下的方法和变量。大家还记得诸如 <code>_c</code>、<code>_v</code>、<code>_s</code> 这样的方法在哪里定义的吗？我们在整理Vue构造函数的时候知道，他们在 <code>src/core/instance/render.js</code> 文件中的 <code>renderMixin</code> 方法中定义，除了这些之外还有诸如：<code>_l</code>、 <code>_m</code>、 <code>_o</code> 等等。其中 <code>_l</code> 就在我们使用 <code>v-for</code> 指令的时候出现了。所以现在大家知道为什么这些方法都被定义在 <code>render.js</code> 文件中了吧，因为他们就是为了构造出 <code>render</code> 函数而存在的。<br>现在我们已经知道了 <code>render</code> 函数的长相，也知道了 <code>render</code> 函数的作用域是Vue实例本身即：<code>this</code>(或<code>vm</code>)。那么当我们执行 render 函数时，其中的变量如：<code>a</code>，就相当于：<code>this.a</code>，我们知道这是在求值，所以 <code>_mount</code> 中的这段代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">vm._watcher = <span class="keyword">new</span> Watcher(vm, () =&gt; &#123;</div><div class="line">  vm._update(vm._render(), hydrating)</div><div class="line">&#125;, noop)</div></pre></td></tr></table></figure></p><p>当 <code>vm._render</code> 执行的时候，所依赖的变量就会被求值，并被收集为依赖。按照Vue中<code>watcher.js</code> 的逻辑，当依赖的变量有变化时不仅仅回调函数被执行，实际上还要重新求值，即还要执行一遍：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">() =&gt; &#123;</div><div class="line">  vm._update(vm._render(), hydrating)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这实际上就做到了 <code>re-render</code>，因为 <code>vm._update</code> 就是文章开头所说的虚拟DOM中的最后一步：<code>patch</code><br><code>vm_render</code> 方法最终返回一个 <code>vnode</code> 对象，即虚拟DOM，然后作为 <code>vm_update</code>的第一个参数传递了过去，我们看一下 <code>vm_update</code> 的逻辑，在 <code>src/core/instance/lifecycle.js</code> 文件中有这么一段代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (!prevVnode) &#123;</div><div class="line">  <span class="comment">// initial render</span></div><div class="line">  vm.$el = vm.__patch__(</div><div class="line">    vm.$el, vnode, hydrating, <span class="literal">false</span> <span class="comment">/* removeOnly */</span>,</div><div class="line">    vm.$options._parentElm,</div><div class="line">    vm.$options._refElm</div><div class="line">  )</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">  <span class="comment">// updates</span></div><div class="line">  vm.$el = vm.__patch__(prevVnode, vnode)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>如果还没有 <code>prevVnode</code> 说明是首次渲染，直接创建真实DOM。如果已经有了 <code>prevVnode</code> 说明不是首次渲染，那么就采用 <code>patch</code> 算法进行必要的DOM操作。这就是Vue更新DOM的逻辑。只不过我们没有将 virtual DOM 内部的实现。<br>现在我们来好好理理思路，当我们写如下代码时：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> Vue(&#123;</div><div class="line">el: <span class="string">'#app'</span>,</div><div class="line">data: &#123;</div><div class="line">a: <span class="number">1</span>,</div><div class="line">b: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div><div class="line">&#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p><p>Vue 所做的事：</p><blockquote><ol><li>构建数据响应系统，使用 <code>Observer</code> 将数据data转换为访问器属性；将 <code>el</code> 编译为 <code>render</code> 函数，<code>render</code> 函数返回值为虚拟DOM</li><li>在 <code>_mount</code> 中对 <code>_update</code>求值，而 <code>_update</code> 又会对 <code>render</code> 求值，<code>render</code> 内部又会对依赖的变量求值，收集为被求值的变量的依赖，当变量改变时，<code>_update</code> 又会重新执行一遍，从而做到 <code>re-render</code></li></ol></blockquote><p>用一张详细一点的图表示就是这样的：</p><p><img src="http://7xlolm.com1.z0.glb.clouddn.com/vueimgdetail.png" alt=""></p><p>到此，我们从大体流程，挑着重点的走了一遍Vue，但是还有很多细节我们没有提及，比如：</p><ol><li>将模板转为 <code>render</code> 函数的时候，实际是先生成的抽象语法树（AST），再将抽象语法树转成的 <code>render</code> 函数，而且这一整套的代码我们也没有提及，因为他在复杂了，其实这部分内容就是在完正则。</li><li>我们也没有详细的讲 Virtual DOM 的实现原理，网上已经有文章讲了，大家可以搜一搜</li><li>我们的例子中仅仅传递了 <code>el</code> ，<code>data</code> 选项，大家知道 <code>Vue</code> 支持的选项很多，比如我们都没有讲到，但都是触类旁通的，比如你搞清楚了 <code>data</code> 选项再去看 <code>computed</code> 选项或者 <code>props</code> 选项就会很容易，比如你知道了 <code>Watcher</code> 的工作机制再去看 <code>watch</code> 选项就会很容易。<br>本篇文章作为Vue源码的启蒙文章，也许还有很多缺陷，全当抛砖引玉了。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;纸上得来终觉浅，绝知此事要躬&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;前段时间看到尤雨溪推荐了一篇vue源码的文章，自己一直也想研究下源码，这几天抽空看了，&lt;a href=&quot;http://hcysun.me/2017/03/03/Vue%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;原文猛戳&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;原本文章的名字叫做《源码解析》，不过后来想想，还是用“源码学习”来的合适一点，在没有彻底掌握源码中的每一个字母之前，“解析”就有点标题党了。建议在看这篇文章之前，最好打开&lt;code&gt;2.1.7&lt;/code&gt;的源码对照着看，这样可能更容易理解。另外本人水平有限，文中有错误或不妥的地方望大家多多指正共同成长。&lt;/p&gt;
&lt;p&gt;补充：&lt;code&gt;Vue 2.2&lt;/code&gt; 刚刚发布，作为一个系列文章的第一篇，本篇文章主要从Vue代码的组织，Vue构造函数的还原，原型的设计，以及参数选项的处理和已经被写烂了的数据绑定与如何使用 Virtual DOM 更新视图入手。从整体的大方向观察框架，这么看来 &lt;code&gt;V2.1.7&lt;/code&gt; 对于理解 &lt;code&gt;V2.2&lt;/code&gt;的代码不会有太大的影响。该系列文章的后续文章，都会从最新的源码入手，并对改动的地方做相应的提示。&lt;/p&gt;
&lt;p&gt;很久之前写过一篇文章：&lt;a href=&quot;http://hcysun.me/2016/04/28/JavaScript%E5%AE%9E%E7%8E%B0MVVM%E4%B9%8B%E6%88%91%E5%B0%B1%E6%98%AF%E6%83%B3%E7%9B%91%E6%B5%8B%E4%B8%80%E4%B8%AA%E6%99%AE%E9%80%9A%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8F%98%E5%8C%96/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;JavaScript实现MVVM之我就是想监测一个普通对象的变化&lt;/a&gt;，文章开头提到了我写博客的风格，还是那句话，只写努力让小白，甚至是小学生都能看明白的文章。这不免会导致对于某些同学来说这篇文章有些墨迹，所以大家根据自己的喜好，可以详细的看，也可以跳跃着看。&lt;br&gt;
    
    </summary>
    
      <category term="基础杂谈" scheme="https://dsb123dsb.github.io/categories/%E5%9F%BA%E7%A1%80%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="vue.js" scheme="https://dsb123dsb.github.io/tags/vue-js/"/>
    
      <category term="源码" scheme="https://dsb123dsb.github.io/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>CSS Grid布局浅谈</title>
    <link href="https://dsb123dsb.github.io/2017/05/04/CSS-Grid%E5%B8%83%E5%B1%80%E6%B5%85%E8%B0%88/"/>
    <id>https://dsb123dsb.github.io/2017/05/04/CSS-Grid布局浅谈/</id>
    <published>2017-05-04T08:13:29.000Z</published>
    <updated>2017-10-03T13:53:51.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>纸上得来终觉浅，绝知此事要躬行</p></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>中文原文（“大漠”，W3CPlus创始人，目前就职于手淘。）猛搓<a href="http://www.w3cplus.com/css3/playing-with-css-grid-layout.html著作权归作者所有。" target="_blank" rel="external">http://www.w3cplus.com/css3/playing-with-css-grid-layout.html</a>（原文很多概念并未涉及，个人建议将作者建议的一些中文外文链接参考也阅读了，以期全面了解和掌握）</p><p>自从去年下半年开始，CSS Grid布局的相关教程在互联网上就铺天盖地，可谓是声势浩大。就针对于Web布局而言，个人认为Grid布局将是Web布局的神器，它改变了以往任何一种布局方式或者方法。不管以前的采用什么布局方法都可以说是一维的布局方式，而Grid最大的特色，采用了二维布局。@Rachel Andrew也一直致力于完善Grid的规范。</p><p>就我个人而言，我也一直在不断的关注这个布局利器的相关更新，自从最初规范的出来，到目前规范的完善。在站上也不断的在更新<a href="https://www.w3cplus.com/blog/tags/356.html" target="_blank" rel="external">CSS Grid布局</a>的使用。虽然这方向的教程已经很多了，但各有千秋，我追求以最简单，最直接的方式来阐述它的使用方式方法。让初学者能尽快的掌握其使用规则。</p><p>前段时间@Mirza Joldic<a href="https://medium.com/@purplecones/playing-with-css-grid-layout-a75836098370" target="_blank" rel="external">在Medium上发布了一篇文章</a>，通过几个Gif动态非常形象的阐述了CSS Grid的几个核心概念以及使用方法，今天我就借花献佛，用这几张图让初学者快速掌握CSS Grid的核心概念和使用技巧。</p><h1 id="Web布局的历史演变"><a href="#Web布局的历史演变" class="headerlink" title="Web布局的历史演变"></a>Web布局的历史演变</h1><p>自从Web出来至今，Web的布局也经过了几个演变，下图可以一目了然：</p><p><img src="https://www.w3cplus.com/sites/default/files/blogs/2017/1704/learning-grid-gif-1.png" alt=""><br><a id="more"></a><br>有关于Web布局的演变史，去年也整理过一篇相关的文章简单的阐述了这方面的故事，如果你感兴趣的话，<a href="https://www.w3cplus.com/css/css-layout-model.html" target="_blank" rel="external">可以点击这里进行了解</a>。在Web的学习过程中，<a href="https://www.w3cplus.com/css/learn-css-layout.html" target="_blank" rel="external">学习Web布局</a>是一个不可避免的过程，而随着前端技术的日新月异的变化，布局方式也在不断的更新，早在2013年@Peter Gasston就对<a href="https://www.w3cplus.com/css3/future-css-layouts.html" target="_blank" rel="external">CSS布局的未来趋势</a>就做过预判断，文章中就提供了CSS Grid的布局。如果今天来看，这种趋势的预判是正确的，特别是今年3月份之后，各大主流浏览器都发布了对CSS Grid的支持。既然如此，学习CSS Grid相关的知识就很有必要。</p><p>既然掌握CSS Grid很有必要，那用什么样的方式能最快的掌握CSS Grid相关的知识呢？这很重要。 特别是@Mirza Joldic在Medium上发布的文章，里面的动图让我耳目一新，通过简单的几张图，就把CSS Grid的几个核心介绍的非常清楚，我觉得很有必要拿出来与大家分享。</p><p>在继续下面的内容之前，再次感谢@Mirza Joldic的付出。那咱们就不说废话了，开始今天的学习之旅。</p><h1 id="CSS-Grid布局的介绍"><a href="#CSS-Grid布局的介绍" class="headerlink" title="CSS Grid布局的介绍"></a>CSS Grid布局的介绍</h1><p>学习CSS Grid布局更多的相关知识，我觉得通过一些工具会对大家的理解更有帮助，到目前为止，这方面的在线工具已经有很多种，比如：</p><ul><li><a href="https://cssgridgarden.com/" target="_blank" rel="external">GRID GARDEN</a>：通过一个小游戏的方式，让你快速掌握CSS Grid的相关知识，这个有点类似于<a href="https://flexboxfroggy.com/" target="_blank" rel="external">FLEXBOX FROGGY</a></li><li><a href="https://griddy.io/" target="_blank" rel="external">Griddy</a> by @drewisthe</li><li><a href="https://alialaa.github.io/css-grid-cheat-sheet/" target="_blank" rel="external">CSS Grid Cheat Sheet</a> by @alialaa</li></ul><p>下面的动图是使用@Mirza Joldic写的<a href="https://www.cssgridplayground.com/" target="_blank" rel="external">CSS Grid Playground</a>小工具。动图来了：</p><p><img src="https://www.w3cplus.com/sites/default/files/blogs/2017/1704/learning-grid-gif-2.gif" alt=""></p><p>这里要提两个核心概念，这两个核心概念有点类似于Flexbox布局：</p><ul><li>Grid容器（对应Flexbox布局中的Flex容器）</li><li>Grid项目（对应Flexbox布局中的Flex项目）</li></ul><p>比如一个这样的HTML结构：</p><p><img src="https://www.w3cplus.com/sites/default/files/blogs/2017/1704/learning-grid-gif-3.png" alt=""></p><p>使用 CSS Grid布局首要的第一步，就是通过<code>display:grid</code>;来对容器声明一个网格容器，那么这个div元素里面对应的子元素就自动成为网格项目。</p><p><img src="https://www.w3cplus.com/sites/default/files/blogs/2017/1704/learning-grid-gif-4.gif" alt=""></p><p>虽然你在<code>div.grid-container</code>中设置了<code>display:grid</code>;，声明了这个元素为Grid容器，但在浏览器中，并看不到有任何的变化。但在在幕后中，他们还是发生了变化，<code>div.grid-container</code>是一个Grid容器，他的所有子元素就自动变成了网格项目。</p><p>接下来，使用<code>grid-template-columns: 1fr 1fr 1fr</code>;来定义三列网格：</p><p><img src="https://www.w3cplus.com/sites/default/files/blogs/2017/1704/learning-grid-gif-5.gif" alt=""></p><p>从gif图中就明显的看出来，现在有点变化了，颜色块变小了，但很难区分出有何变化，为了让效果之间有更突出的差异，再给<code>.grid-container</code>中添加<code>grid-gap:5px</code>：</p><p><img src="https://www.w3cplus.com/sites/default/files/blogs/2017/1704/learning-grid-gif-6.gif" alt=""></p><p>看到变化了吧，整个网格分了三个列，单元格之间有<code>5px</code>的间距，同时每列的列宽是整个宽度的三分之一，那是因为我们采用了<code>fr</code>单位，而且把整个网格分成了三列，每列的宽度是1fr。这里告诉我们三个知识点：</p><ul><li><code>grid-template-columns</code>用来把网格指定列的宽度</li><li><code>grid-gap</code>用来指定列（或行）的间距</li><li><code>fr</code>可以自动根据网格容器的宽度来计算列的宽度</li></ul><p>现在我们把<code>grid-template-columns</code>的值改成：<code>1fr 2fr 1fr</code>，对应的效果就会变成：</p><p><img src="https://www.w3cplus.com/sites/default/files/blogs/2017/1704/learning-grid-gif-7.gif" alt=""></p><p>现在第二列的宽度是第一列和最后一列的两倍。这也再次证明fr单位的强大之处，使用它可以让你很容易定义你的网格尺寸。</p><p>现在越来越接近我们想要的网格。但需求是不断变化的，比如我们现在想让顶部的第一行尽可能的宽，比如说跨整个网格列（比如我们网页的头部，或者说我们常见的导航）。如此一来，只需要在第一个网格上使用<code>grid-column: 1 / 4</code>：</p><p><img src="https://www.w3cplus.com/sites/default/files/blogs/2017/1704/learning-grid-gif-8.gif" alt=""></p><p>或许第一次接触<code>1 / 4</code>会令你感到神秘，其实这个涉及到了CSS Grid中的重要概念之一，那就是网格线，其中第一个数字是列的起始网格线位置，第二个数字是线束网格线的位置。对于一个CSS Grid，可以通过grid-<code>template-columns</code>创建列网格线，<code>grid-template-rows</code>创建行网格线。这种方式创建的是一种显式的网格线。当然，除了这种方式，还可以创建隐式网格线。除此之外，还可以使用<code>grid-auto-rows</code>和<code>grid-auto-columns</code>可以创建一个隐式网格。这个隐式网格对应的网格线就被称之为隐式网格线。下图简单的展示了示例中的网格线示意图：</p><p><img src="https://www.w3cplus.com/sites/default/files/blogs/2017/1704/learning-grid-gif-9.png" alt=""></p><p>接下来，我们想要有一个<code>300px</code>的侧边栏高度，并且让他的位置是垂直方向的<code>2 / 3</code>。我们可以使用<code>grid-row: 2 / 4</code>来实现，这个特性和<code>grid-column</code>非常的类似。这个时候，效果变成这样：</p><p><img src="https://www.w3cplus.com/sites/default/files/blogs/2017/1704/learning-grid-gif-10.gif" alt=""></p><p>其实CSS Grid看上去和表格非常的类似，在表格中我们有一个专业的术语，合并单元格。其实在CSS Grid布局中，我们同样有一个类似的特性，那就是在<code>grid-column</code>或者<code>grid-row</code>中引入关键词<code>span</code>，在关键词<code>span</code>后面紧跟一个数值，就是表示合并单元格的数量，先来看下图：</p><p><img src="https://www.w3cplus.com/sites/default/files/blogs/2017/1704/learning-grid-gif-11.gif" alt=""></p><p>上面的示例中，我们使用到了<code>grid-column: 2 / span 1</code>和<code>grid-row: 2 / span 2</code>。其中<code>grid-column: 2 / span 1</code>表示从列网格线2开始，跨度是1个列网格线（其实就是合并一个列单元格）。而<code>grid-row: 2 / span 2</code>表示的是从行网格线2开始，跨度是两个两个线（其实就是合并两个行单元格）。</p><p>接着我们来做页脚，在做页脚之前，我们先删除两个网格项目，因为不需要他们了。做页脚和做页头非常的类似，继续使用g<code>rid-column: 1 / 4</code>即可：</p><p><img src="https://www.w3cplus.com/sites/default/files/blogs/2017/1704/learning-grid-gif-12.gif" alt=""></p><p>通过上面的方式，我们可以轻易的控制网格，也能非常容易的实现一个Web面页的布局，比如一个三列的布局。但我们在布局中经常还需要控制对齐方式，特别是在CSS Grid的布局当中，比如下面的示例中，我们第三列并未占满整个高度，这个时候希望它能底部对齐。此时为了实现这样的效果，需要使用到CSS中的对齐模块特性，比如在这里，我们可以使用<code>align-self: end</code>来实现：</p><p><img src="https://www.w3cplus.com/sites/default/files/blogs/2017/1704/learning-grid-gif-13.gif" alt=""></p><p><code>align-self</code>是CSS中的一个新模块特性<a href="https://www.w3.org/TR/css-align-3/" target="_blank" rel="external">Box Alignment</a>中的一个属性。有关于这个模块的的功能还是非常的实用。@Rachel Andrew整理了一份<a href="https://rachelandrew.co.uk/css/cheatsheets/box-alignment" target="_blank" rel="external">Box Alignment Cheatsheet</a>，里面详细介绍了Box Alignment的使用。简单的来讲，这个规范中有三个关键部分：</p><ul><li><a href="https://drafts.csswg.org/css-align/#positional-values" target="_blank" rel="external">Positional Alignment</a>：关键词有start、end、center</li><li><a href="https://drafts.csswg.org/css-align/#baseline-values" target="_blank" rel="external">Baseline Alignment</a>：关键词有baseline、first baseline、last baseline</li><li><a href="https://drafts.csswg.org/css-align/#distribution-values" target="_blank" rel="external">Distributed Alignment</a>：关键词有space-between和space-around</li></ul><p>其实你要是对<a href="https://www.w3cplus.com/blog/tags/157.html" target="_blank" rel="external">Flexbox</a>熟悉的话，你或许感觉这个Box Alignment有点类似于Flexbox中的一些控制Flex项目对齐方式的属性。事实是这样的，如果你感兴趣想深入的了解这方面的相关知识，建议你花点时间阅读<a href="https://www.w3cplus.com/css/css-grids-flexbox-and-box-alignment-our-new-system-for-web-layout.html" target="_blank" rel="external">《Web布局新系统：CSS Grid,Flexbox和Box Alignment》</a>一文</p><p>如果你对上面的相关知识有所了解的话，你就可以很轻易的使用CSS Grid相关知识实现一个常用的Web页面布局效果。比如下面这张图，为了好完，我把主内容的容器设置了具体的宽度，并且通过Box Alignment属性，让这个区域水平垂直居中：</p><p><img src="https://www.w3cplus.com/sites/default/files/blogs/2017/1704/learning-grid-gif-14.gif" alt=""></p><p>整个题外话，虽然<a href="https://www.w3cplus.com/blog/tags/357.html" target="_blank" rel="external">实现水平垂直居中的解决方案</a>已有很多种了，但Box Alignment模块将是最佳方式。</p><p>如果你感兴趣的话，你也可以通过@Mirza Joldic写的<a href="https://www.cssgridplayground.com/" target="_blank" rel="external">CSS Grid Playground</a>小工具去尝试各式各样的网格布局效果。从而加强对CSS Grid的概念。当然，在使用它去做一些事情或者做一些创意之前，还是很有必要对CSS Grid基础要有一个简单的了解。个人建议你花点时间阅读一下下面几篇文章：</p><ul><li><a href="https://www.w3cplus.com/css3/css-grid-layout-terminology-part1.html" target="_blank" rel="external">CSS Grid布局：图解网格布局中术语之一</a></li><li><a href="https://www.w3cplus.com/css3/css-grid-layout-terminology-part2.html" target="_blank" rel="external">CSS Grid布局：图解网格布局中术语二</a></li><li><a href="https://www.w3cplus.com/css3/css-grid-layout-terminology-part3.html" target="_blank" rel="external">CSS Grid布局：图解网格布局中术语三</a></li><li><a href="https://www.w3cplus.com/css3/a-complete-guide-css-grid-layout.html" target="_blank" rel="external">CSS Grid布局指南</a></li></ul><p>当然，如果你深入的学习CSS Grid的相关知识，个人强列你仔细阅读<a href="https://www.w3cplus.com/blog/tags/356.html" target="_blank" rel="external">完这里的所有文章</a>。其实我个人也是CSS Grid的极度爱好者，我将在这里不断的更新和发布有关于CSS Grid的相关文章。希望这些文章对你学习和使用CSS Grid有所帮助。</p><p>中文原文（“大漠”，W3CPlus创始人，目前就职于手淘。）<a href="http://www.w3cplus.com/css3/playing-with-css-grid-layout.html著作权归作者所有。" target="_blank" rel="external">http://www.w3cplus.com/css3/playing-with-css-grid-layout.html</a></p><p>英文参考地址Mirza Joldic在Medium<a href="https://medium.com/@purplecones/playing-with-css-grid-layout-a75836098370" target="_blank" rel="external">https://medium.com/@purplecones/playing-with-css-grid-layout-a75836098370</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;纸上得来终觉浅，绝知此事要躬行&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;中文原文（“大漠”，W3CPlus创始人，目前就职于手淘。）猛搓&lt;a href=&quot;http://www.w3cplus.com/css3/playing-with-css-grid-layout.html著作权归作者所有。&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.w3cplus.com/css3/playing-with-css-grid-layout.html&lt;/a&gt;（原文很多概念并未涉及，个人建议将作者建议的一些中文外文链接参考也阅读了，以期全面了解和掌握）&lt;/p&gt;
&lt;p&gt;自从去年下半年开始，CSS Grid布局的相关教程在互联网上就铺天盖地，可谓是声势浩大。就针对于Web布局而言，个人认为Grid布局将是Web布局的神器，它改变了以往任何一种布局方式或者方法。不管以前的采用什么布局方法都可以说是一维的布局方式，而Grid最大的特色，采用了二维布局。@Rachel Andrew也一直致力于完善Grid的规范。&lt;/p&gt;
&lt;p&gt;就我个人而言，我也一直在不断的关注这个布局利器的相关更新，自从最初规范的出来，到目前规范的完善。在站上也不断的在更新&lt;a href=&quot;https://www.w3cplus.com/blog/tags/356.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CSS Grid布局&lt;/a&gt;的使用。虽然这方向的教程已经很多了，但各有千秋，我追求以最简单，最直接的方式来阐述它的使用方式方法。让初学者能尽快的掌握其使用规则。&lt;/p&gt;
&lt;p&gt;前段时间@Mirza Joldic&lt;a href=&quot;https://medium.com/@purplecones/playing-with-css-grid-layout-a75836098370&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;在Medium上发布了一篇文章&lt;/a&gt;，通过几个Gif动态非常形象的阐述了CSS Grid的几个核心概念以及使用方法，今天我就借花献佛，用这几张图让初学者快速掌握CSS Grid的核心概念和使用技巧。&lt;/p&gt;
&lt;h1 id=&quot;Web布局的历史演变&quot;&gt;&lt;a href=&quot;#Web布局的历史演变&quot; class=&quot;headerlink&quot; title=&quot;Web布局的历史演变&quot;&gt;&lt;/a&gt;Web布局的历史演变&lt;/h1&gt;&lt;p&gt;自从Web出来至今，Web的布局也经过了几个演变，下图可以一目了然：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.w3cplus.com/sites/default/files/blogs/2017/1704/learning-grid-gif-1.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="技术分享" scheme="https://dsb123dsb.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="css" scheme="https://dsb123dsb.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript监听全部Ajax请求事件的方法</title>
    <link href="https://dsb123dsb.github.io/2017/05/02/JavaScript%E7%9B%91%E5%90%AC%E5%85%A8%E9%83%A8Ajax%E8%AF%B7%E6%B1%82%E4%BA%8B%E4%BB%B6%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>https://dsb123dsb.github.io/2017/05/02/JavaScript监听全部Ajax请求事件的方法/</id>
    <published>2017-05-02T07:34:59.000Z</published>
    <updated>2017-10-03T13:53:51.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>纸上得来终觉浅，绝知此事要躬行</p></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前段时间做阿里暑期实习笔试题目，抽到的试题最后一道要求写个组件监听页面所有ajax请求，当时大概能猜到要改写XMLHttpReuqest对象，不过最后还是没写出来，回来查了下资料：</p><ol><li>若Ajax请求是由jQuery的$.ajax发起的，默认情况下可以使用 jQuery的Global Ajax Event Handlers监听到Ajax事件，</li><li>然而我遇到的却是用原生JavaScript发起的Ajax请求，所以这种方法行不通。</li><li>还有其他方法，比如说 Pub/Sub，但是这个发起请求的 js 代码我是无法改动的，也就不存在向代码里添加 publish 的问题。同理，jQuery 的 .bind 和 .trigger 也无法使用。</li></ol><p>最后的方案：实现主要是两点：<code>**override XMLHttpRequest**</code>和<strong>自定义事件</strong>（这一块红宝书有讲，也看过，并没有重视，自己没有好好钻研，怨不得别人）<br><a id="more"></a></p><h1 id="1-0实现"><a href="#1-0实现" class="headerlink" title="1.0实现"></a>1.0实现</h1><p>在 StackOverflow 上搜索，发现有个歪果仁给出了一个不靠谱的解决方法，嗯，贴出来给大家看看：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">;(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line"> <span class="keyword">var</span> open = <span class="built_in">window</span>.XMLHttpRequest.prototype.open,</div><div class="line">  send = <span class="built_in">window</span>.XMLHttpRequest.prototype.send,</div><div class="line">  onReadyStateChange;</div><div class="line">  </div><div class="line"> <span class="function"><span class="keyword">function</span> <span class="title">openReplacement</span>(<span class="params">method, url, async, user, password</span>) </span>&#123;</div><div class="line">  <span class="comment">// some code</span></div><div class="line">  </div><div class="line">  <span class="keyword">return</span> open.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</div><div class="line"> &#125;</div><div class="line">  </div><div class="line"> <span class="function"><span class="keyword">function</span> <span class="title">sendReplacement</span>(<span class="params">data</span>) </span>&#123;</div><div class="line">  <span class="comment">// some code</span></div><div class="line">  </div><div class="line">  <span class="keyword">if</span>(<span class="keyword">this</span>.onreadystatechange) <span class="keyword">this</span>._onreadystatechange = <span class="keyword">this</span>.onreadystatechange;</div><div class="line">  <span class="keyword">this</span>.onreadystatechange = onReadyStateChangeReplacement;</div><div class="line">  </div><div class="line">  <span class="keyword">return</span> send.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</div><div class="line"> &#125;</div><div class="line">  </div><div class="line"> <span class="function"><span class="keyword">function</span> <span class="title">onReadyStateChangeReplacement</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// some code</span></div><div class="line">  </div><div class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>._onreadystatechange) <span class="keyword">return</span> <span class="keyword">this</span>._onreadystatechange.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</div><div class="line"> &#125;</div><div class="line">  </div><div class="line"> <span class="built_in">window</span>.XMLHttpRequest.prototype.open = openReplacement;</div><div class="line"> <span class="built_in">window</span>.XMLHttpRequest.prototype.send = sendReplacement;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure></p><p>这个解决方案，无法监听全部的 <code>XHR Events</code> ，而且 <code>readystatechange</code> 事件是在调用 <code>send</code> 方法后才监听，也就无法监听到<code>readyState = 1</code>时的事件。同时，如果在使用 <code>send</code> 方法后再对 <code>onreadystatechange</code> 设置回调函数，会将<code>override</code> 的代码又一次 <code>override</code>，也就无法产生预想的效果。</p><h1 id="2-0实现"><a href="#2-0实现" class="headerlink" title="2.0实现"></a>2.0实现</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">;(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line"> <span class="function"><span class="keyword">function</span> <span class="title">ajaxEventTrigger</span>(<span class="params">event</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> ajaxEvent = <span class="keyword">new</span> CustomEvent(event, &#123; <span class="attr">detail</span>: <span class="keyword">this</span> &#125;);</div><div class="line">  <span class="built_in">window</span>.dispatchEvent(ajaxEvent);</div><div class="line"> &#125;</div><div class="line">   </div><div class="line"> <span class="keyword">var</span> oldXHR = <span class="built_in">window</span>.XMLHttpRequest;</div><div class="line">  </div><div class="line"> <span class="function"><span class="keyword">function</span> <span class="title">newXHR</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> realXHR = <span class="keyword">new</span> oldXHR();</div><div class="line">  <span class="comment">// this指向window</span></div><div class="line">  realXHR.addEventListener(<span class="string">'abort'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; ajaxEventTrigger.call(<span class="keyword">this</span>, <span class="string">'ajaxAbort'</span>); &#125;, <span class="literal">false</span>);</div><div class="line">  </div><div class="line">  realXHR.addEventListener(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; ajaxEventTrigger.call(<span class="keyword">this</span>, <span class="string">'ajaxError'</span>); &#125;, <span class="literal">false</span>);</div><div class="line">  </div><div class="line">  realXHR.addEventListener(<span class="string">'load'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; ajaxEventTrigger.call(<span class="keyword">this</span>, <span class="string">'ajaxLoad'</span>); &#125;, <span class="literal">false</span>);</div><div class="line">  </div><div class="line">  realXHR.addEventListener(<span class="string">'loadstart'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; ajaxEventTrigger.call(<span class="keyword">this</span>, <span class="string">'ajaxLoadStart'</span>); &#125;, <span class="literal">false</span>);</div><div class="line">  </div><div class="line">  realXHR.addEventListener(<span class="string">'progress'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; ajaxEventTrigger.call(<span class="keyword">this</span>, <span class="string">'ajaxProgress'</span>); &#125;, <span class="literal">false</span>);</div><div class="line">  </div><div class="line">  realXHR.addEventListener(<span class="string">'timeout'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; ajaxEventTrigger.call(<span class="keyword">this</span>, <span class="string">'ajaxTimeout'</span>); &#125;, <span class="literal">false</span>);</div><div class="line">  </div><div class="line">  realXHR.addEventListener(<span class="string">'loadend'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; ajaxEventTrigger.call(<span class="keyword">this</span>, <span class="string">'ajaxLoadEnd'</span>); &#125;, <span class="literal">false</span>);</div><div class="line">  </div><div class="line">  realXHR.addEventListener(<span class="string">'readystatechange'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; ajaxEventTrigger.call(<span class="keyword">this</span>, <span class="string">'ajaxReadyStateChange'</span>); &#125;, <span class="literal">false</span>);</div><div class="line">  </div><div class="line">  <span class="keyword">return</span> realXHR;</div><div class="line"> &#125;</div><div class="line">  </div><div class="line"> <span class="built_in">window</span>.XMLHttpRequest = newXHR;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure><p>这样，就为 <code>XHR</code> 添加了自定义事件。如何调用？<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</div><div class="line">  </div><div class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'ajaxReadyStateChange'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</div><div class="line"> <span class="built_in">console</span>.log(e.detail); <span class="comment">// XMLHttpRequest Object</span></div><div class="line">&#125;);</div><div class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'ajaxAbort'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</div><div class="line"> <span class="built_in">console</span>.log(e.detail.responseText); <span class="comment">// XHR 返回的内容</span></div><div class="line">&#125;);</div><div class="line">  </div><div class="line">xhr.open(<span class="string">'GET'</span>, <span class="string">'info.json'</span>);</div><div class="line">xhr.send();</div></pre></td></tr></table></figure></p><p>需要注意的是，正常的 <code>readystatechange</code> 等事件 <code>handler</code> 返回的 <code>e</code> 是 <code>XMLHttpRequest</code> 对象，但是自定义方法 <code>ajaxReadyStateChange</code> 等事件 <code>handler</code> 返回的 <code>e</code> 是 <code>CustomEvent</code> 对象，而 <code>e.detail</code>才是真正的 <code>XMLHttpRequest</code> 对象。而获得 <code>Ajax</code> 请求返回内容的 <code>e.responseText</code> 也需要修改为 <code>e.detail.responseText</code>。<br>同时，<code>addEventListener</code> 方法必须挂载在 <code>window</code> 对象上，而不能是 <code>XHR</code> 实例上。</p><h1 id="改进？"><a href="#改进？" class="headerlink" title="改进？"></a>改进？</h1><p>以上代码使用了 <code>CustomEvent</code> 构造函数，在现代浏览器上可以正常使用，但是在 IE 下，甚至连 IE 11 都不支持，所以需要加上 <code>Polyfill</code>，变成这样：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">;(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line"> <span class="keyword">if</span> ( <span class="keyword">typeof</span> <span class="built_in">window</span>.CustomEvent === <span class="string">"function"</span> ) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">  </div><div class="line"> <span class="function"><span class="keyword">function</span> <span class="title">CustomEvent</span> (<span class="params"> event, params </span>) </span>&#123;</div><div class="line">  params = params || &#123; <span class="attr">bubbles</span>: <span class="literal">false</span>, <span class="attr">cancelable</span>: <span class="literal">false</span>, <span class="attr">detail</span>: <span class="literal">undefined</span> &#125;;</div><div class="line">  <span class="keyword">var</span> evt = <span class="built_in">document</span>.createEvent( <span class="string">'CustomEvent'</span> );</div><div class="line">  evt.initCustomEvent( event, params.bubbles, params.cancelable, params.detail );</div><div class="line">  <span class="keyword">return</span> evt;</div><div class="line"> &#125;</div><div class="line">  </div><div class="line"> CustomEvent.prototype = <span class="built_in">window</span>.Event.prototype;</div><div class="line">  </div><div class="line"> <span class="built_in">window</span>.CustomEvent = CustomEvent;</div><div class="line">&#125;)();</div><div class="line">;(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line"> <span class="function"><span class="keyword">function</span> <span class="title">ajaxEventTrigger</span>(<span class="params">event</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> ajaxEvent = <span class="keyword">new</span> CustomEvent(event, &#123; <span class="attr">detail</span>: <span class="keyword">this</span> &#125;);</div><div class="line">  <span class="built_in">window</span>.dispatchEvent(ajaxEvent);</div><div class="line"> &#125;</div><div class="line">   </div><div class="line"> <span class="keyword">var</span> oldXHR = <span class="built_in">window</span>.XMLHttpRequest;</div><div class="line">  </div><div class="line"> <span class="function"><span class="keyword">function</span> <span class="title">newXHR</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> realXHR = <span class="keyword">new</span> oldXHR();</div><div class="line">  </div><div class="line">  realXHR.addEventListener(<span class="string">'abort'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; ajaxEventTrigger.call(<span class="keyword">this</span>, <span class="string">'ajaxAbort'</span>); &#125;, <span class="literal">false</span>);</div><div class="line">  </div><div class="line">  realXHR.addEventListener(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; ajaxEventTrigger.call(<span class="keyword">this</span>, <span class="string">'ajaxError'</span>); &#125;, <span class="literal">false</span>);</div><div class="line">  </div><div class="line">  realXHR.addEventListener(<span class="string">'load'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; ajaxEventTrigger.call(<span class="keyword">this</span>, <span class="string">'ajaxLoad'</span>); &#125;, <span class="literal">false</span>);</div><div class="line">  </div><div class="line">  realXHR.addEventListener(<span class="string">'loadstart'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; ajaxEventTrigger.call(<span class="keyword">this</span>, <span class="string">'ajaxLoadStart'</span>); &#125;, <span class="literal">false</span>);</div><div class="line">  </div><div class="line">  realXHR.addEventListener(<span class="string">'progress'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; ajaxEventTrigger.call(<span class="keyword">this</span>, <span class="string">'ajaxProgress'</span>); &#125;, <span class="literal">false</span>);</div><div class="line">  </div><div class="line">  realXHR.addEventListener(<span class="string">'timeout'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; ajaxEventTrigger.call(<span class="keyword">this</span>, <span class="string">'ajaxTimeout'</span>); &#125;, <span class="literal">false</span>);</div><div class="line">  </div><div class="line">  realXHR.addEventListener(<span class="string">'loadend'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; ajaxEventTrigger.call(<span class="keyword">this</span>, <span class="string">'ajaxLoadEnd'</span>); &#125;, <span class="literal">false</span>);</div><div class="line">  </div><div class="line">  realXHR.addEventListener(<span class="string">'readystatechange'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; ajaxEventTrigger.call(<span class="keyword">this</span>, <span class="string">'ajaxReadyStateChange'</span>); &#125;, <span class="literal">false</span>);</div><div class="line">  </div><div class="line">  <span class="keyword">return</span> realXHR;</div><div class="line"> &#125;</div><div class="line">  </div><div class="line"> <span class="built_in">window</span>.XMLHttpRequest = newXHR;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure></p><p>此时，就可以在 IE 9+、Chrome 15+、FireFox 11+、Edge、Safari 6.1+、Opera 12.1+ 上愉快地使用了，以上就是本文的全部内容，希望大家能够喜欢。</p><p>参考原文——–<a href="http://www.jb51.net/article/91419.htm" target="_blank" rel="external">http://www.jb51.net/article/91419.htm</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;纸上得来终觉浅，绝知此事要躬行&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;前段时间做阿里暑期实习笔试题目，抽到的试题最后一道要求写个组件监听页面所有ajax请求，当时大概能猜到要改写XMLHttpReuqest对象，不过最后还是没写出来，回来查了下资料：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;若Ajax请求是由jQuery的$.ajax发起的，默认情况下可以使用 jQuery的Global Ajax Event Handlers监听到Ajax事件，&lt;/li&gt;
&lt;li&gt;然而我遇到的却是用原生JavaScript发起的Ajax请求，所以这种方法行不通。&lt;/li&gt;
&lt;li&gt;还有其他方法，比如说 Pub/Sub，但是这个发起请求的 js 代码我是无法改动的，也就不存在向代码里添加 publish 的问题。同理，jQuery 的 .bind 和 .trigger 也无法使用。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;最后的方案：实现主要是两点：&lt;code&gt;**override XMLHttpRequest**&lt;/code&gt;和&lt;strong&gt;自定义事件&lt;/strong&gt;（这一块红宝书有讲，也看过，并没有重视，自己没有好好钻研，怨不得别人）&lt;br&gt;
    
    </summary>
    
      <category term="技术分享" scheme="https://dsb123dsb.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="ajax" scheme="https://dsb123dsb.github.io/tags/ajax/"/>
    
  </entry>
  
  <entry>
    <title>如何用原生 JS 实现手势解锁组件</title>
    <link href="https://dsb123dsb.github.io/2017/04/30/%E5%A6%82%E4%BD%95%E7%94%A8%E5%8E%9F%E7%94%9F-JS-%E5%AE%9E%E7%8E%B0%E6%89%8B%E5%8A%BF%E8%A7%A3%E9%94%81%E7%BB%84%E4%BB%B6/"/>
    <id>https://dsb123dsb.github.io/2017/04/30/如何用原生-JS-实现手势解锁组件/</id>
    <published>2017-04-30T13:46:46.000Z</published>
    <updated>2017-10-03T13:53:51.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>纸上得来终觉浅，绝知此事要躬行</p></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>原文猛戳月影大大博客<a href="https://www.h5jun.com/post/handlock-comp.html#toc-af9" target="_blank" rel="external">—十年踪迹—-</a>,读了一遍干货很多，先转过来，后面再慢慢消化。<br>这是<a href="https://html5.360.cn/star" target="_blank" rel="external">第三届 360 前端星计划</a>的选拔<a href="https://www.h5jun.com/post/75team-star-handlock.html" target="_blank" rel="external">作业题</a>。600多名学生参与了解答，最后通过了60人。这60名同学完成的不错，思路、代码风格、功能完成度颇有可取之处，不过也有一些欠考虑的地方，比如发现很多同学能按照需求实现完整的功能，但是不知道应当如何<em>设计开放的 API</em>，或者说，如何分析和预判产品需求和未来的变化，从而决定什么应当开放，什么应当封装。这无关于答案正确与否，还是和经验有关。<br><a id="more"></a><br>在这里，我提供一个<a href="https://github.com/akira-cn/handlock" target="_blank" rel="external">参考的版本</a>，并不是说这一版就最好，而是说，通过这一版，分析当我们遇到这样的比较复杂的 UI 需求的时候，我们应该怎样思考和实现。</p><p><img src="https://p.ssl.qhimg.com/d/inn/603c0bc8/06692681-E1C6-400A-A516-D7F8B26732C7.png" alt=""></p><h1 id="组件设计的一般步骤"><a href="#组件设计的一般步骤" class="headerlink" title="组件设计的一般步骤"></a>组件设计的一般步骤</h1><p>组件设计一般来说包括如下一些过程：</p><ol><li>理解需求</li><li>技术选型</li><li>结构（UI）设计</li><li>数据和API设计</li><li>流程设计</li><li>兼容性和细节优化</li><li>工具 &amp; 工程化</li></ol><p>这些过程并不是每个组件设计的时候都会遇到，但是通常来说一个项目总会在其中一些过程里遇到问题需要解决。下面我们来简单分析一下</p><h2 id="理解需求"><a href="#理解需求" class="headerlink" title="理解需求"></a>理解需求</h2><p>作业本身只是说设计一个常见的手势密码的 UI 交互，可以通过选择验证密码和设置密码来切换两种状态，每种状态有自己的流程。因此大部分同学就照着需求把整个组件的状态切换和流程封装了起来，有的同学提供了一定的 UI 样式配置能力，但是基本上没有同学能将流程和状态切换过程中的节点给开放出来。实际上这个组件如果要给用户使用，显然需要将过程节点开放出来，也就是说，<strong>需要由使用者决定设置密码的过程里执行什么操作、验证密码的过程和密码验证成功后执行什么操作</strong>，这些是组件开发者无法代替使用者来决定的。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> password = <span class="string">'11121323'</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> locker = <span class="keyword">new</span> HandLock.Locker(&#123;</div><div class="line">  container: <span class="built_in">document</span>.querySelector(<span class="string">'#handlock'</span>),</div><div class="line">  check: &#123;</div><div class="line">    checked: <span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</div><div class="line">      <span class="keyword">if</span>(res.err)&#123;</div><div class="line">        <span class="built_in">console</span>.error(res.err); <span class="comment">//密码错误或长度太短</span></div><div class="line">        [执行操作...]</div><div class="line">      &#125;<span class="keyword">else</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">`正确，密码是：<span class="subst">$&#123;res.records&#125;</span>`</span>);</div><div class="line">        [执行操作...]</div><div class="line">      &#125;</div><div class="line">    &#125;,</div><div class="line">  &#125;,</div><div class="line">  update:&#123;</div><div class="line">    beforeRepeat: <span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</div><div class="line">      <span class="keyword">if</span>(res.err)&#123;</div><div class="line">        <span class="built_in">console</span>.error(res.err); <span class="comment">//密码长度太短</span></div><div class="line">        [执行操作...]</div><div class="line">      &#125;<span class="keyword">else</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">`密码初次输入完成，等待重复输入`</span>);</div><div class="line">        [执行操作...]</div><div class="line">      &#125;</div><div class="line">    &#125;,</div><div class="line">    afterRepeat: <span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</div><div class="line">      <span class="keyword">if</span>(res.err)&#123;</div><div class="line">        <span class="built_in">console</span>.error(res.err); <span class="comment">//密码长度太短或者两次密码输入不一致</span></div><div class="line">        [执行操作...]</div><div class="line">      &#125;<span class="keyword">else</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">`密码更新完成，新密码是：<span class="subst">$&#123;res.records&#125;</span>`</span>);</div><div class="line">        [执行操作...]</div><div class="line">      &#125;</div><div class="line">    &#125;,</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">locker.check(password);</div></pre></td></tr></table></figure></p><h2 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h2><p>这个问题的 UI 展现的核心是九宫格和选中的小圆点，从技术上来讲，我们有三种可选方案： DOM/Canvas/SVG，三者都是可以实现主体 UI 的。</p><p>如果使用 DOM，最简单的方式是使用 flex 布局，这样能够做成响应式的</p><p><a class="jsbin-embed" href="//code.h5jun.com/dago/5/embed?html,css,js,output">JS Bin on jsbin.com</a><script src="https:////code.h5jun.com/js/embed.min.js?3.40.2"></script></p><p>使用 DOM 的优点是容易实现响应式，事件处理简单，布局也不复杂（但是和 Canvas 比起来略微复杂），但是斜线（demo 里没有画）的长度和斜率需要计算。</p><p>除了使用 DOM 外，使用 Canvas 绘制也很方便：</p><p><a class="jsbin-embed" href="//code.h5jun.com/biz/1/embed?html,css,js,output">JS Bin on jsbin.com</a><script src="https:////code.h5jun.com/js/embed.min.js?3.40.2"></script></p><p>用 Canvas 实现有两个小细节，第一是要实现响应式，可以用 DOM 构造一个正方形的容器：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">#container &#123;</div><div class="line">  position: relative;</div><div class="line">  overflow: hidden;</div><div class="line">  width: <span class="number">100</span>%;</div><div class="line">  padding-top: <span class="number">100</span>%;</div><div class="line">  height: <span class="number">0</span>px;</div><div class="line">  background-color: white;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在这里我们使用 <code>padding-top:100%</code> 撑开容器高度使它等于容器宽度。</p><p>第二个细节是为了在 retina 屏上获得清晰的显示效果，我们将 Canvas 的宽高增加一倍，然后通过 <code>transform: scale(0.5)</code> 来缩小到匹配容器宽高。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#container canvas&#123;</div><div class="line">  position: absolute;</div><div class="line">  left: <span class="number">50</span>%;</div><div class="line">  top: <span class="number">50</span>%;</div><div class="line">  transform: translate(<span class="number">-50</span>%, <span class="number">-50</span>%) scale(<span class="number">0.5</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>由于 Canvas 的定位是 absolute，它本身的默认宽高并不等于容器的宽高，需要通过 JS 设置：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> width = <span class="number">2</span> * container.getBoundingClientRect().width;</div><div class="line">canvas.width = canvas.height = width;</div></pre></td></tr></table></figure></p><p>这样我们就可以通过在 Canvas 上绘制实心圆和连线来实现 UI 了。具体的方法在后续的内容里有更详细的讲解。</p><p>最后我们来看一下用 SVG 绘制：</p><p><a class="jsbin-embed" href="//code.h5jun.com/kuf/1/embed?html,css,js,output">JS Bin on jsbin.com</a><script src="https:////code.h5jun.com/js/embed.min.js?3.40.2"></script></p><p>由于 SVG 原生操作的 API 不是很方便，这里使用了 Snap.svg 库，实现起来和使用 Canvas 大同小异，这里就不赘述了。</p><p>SVG 的问题是移动端兼容性不如 DOM 和 Canvas 好。</p><p>综合上面三者的情况，最终我选择使用 Canvas 来实现。</p><h2 id="结构设计"><a href="#结构设计" class="headerlink" title="结构设计"></a>结构设计</h2><p>使用 Canvas 实现的话 DOM 结构就比较简单。为了响应式，我们需要实现一个自适应宽度的正方形容器，方法前面已经介绍过。接着在容器中创建 Canvas。这里需要注意的一点是，我们应当把 Canvas 分层。这是因为 Canvas 的渲染机制里，要更新画布的内容，需要刷新要更新的区域重新绘制。因为我们有必要把频繁变化的内容和基本不变的内容分层管理，这样能显著提升性能。</p><h3 id="分成-3-个图层"><a href="#分成-3-个图层" class="headerlink" title="分成 3 个图层"></a>分成 3 个图层</h3><p><img src="https://p4.ssl.qhimg.com/t01e8fbcac1b8d2f472.png" alt=""></p><p>在这里我把 UI 分别绘制在 3 个图层里，对应 3 个 Canvas。最上层只有随着手指头移动的那个线段，中间是九个点，最下层是已经绘制好的线。之所以这样分，是因为随手指头移动的那条线需要不断刷新，底下两层都不用频繁更新，但是把连好的线放在最底层是因为我要做出圆点把线的一部分遮挡住的效果。</p><h3 id="确定圆点的位置"><a href="#确定圆点的位置" class="headerlink" title="确定圆点的位置"></a>确定圆点的位置</h3><p><img src="https://p0.ssl.qhimg.com/t01a663c97f0dd807e3.png" alt=""></p><p>圆点的位置有两种定位法，第一种是九个九宫格，圆点在小九宫格的中心位置。如果认真的同学，已经发现在前面 DOM 方案里，我们就是采用这样的方式，圆点的直径为 11.1%。第二种方式是用横竖三条线把宽高四等分，圆点在这些线的交点处。</p><p>在 Canvas 里我们采用第二种方法来确定圆点（代码里的 n = 3）。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> range = <span class="built_in">Math</span>.round(width / (n + <span class="number">1</span>));</div><div class="line"></div><div class="line"><span class="keyword">let</span> circles = [];</div><div class="line"></div><div class="line"><span class="comment">//drawCircleCenters</span></div><div class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</div><div class="line">    <span class="keyword">let</span> y = range * i, x = range * j;</div><div class="line">    drawSolidCircle(circleCtx, fgColor, x, y, innerRadius);</div><div class="line">    <span class="keyword">let</span> circlePoint = &#123;x, y&#125;;</div><div class="line">    circlePoint.pos = [i, j];</div><div class="line">    circles.push(circlePoint);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>最后一点，严格说不属于结构设计，但是因为我们的 UI 是通过触屏操作，我们需要考虑 Touch 事件处理和坐标的转换。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCanvasPoint</span>(<span class="params">canvas, x, y</span>)</span>&#123;</div><div class="line">  <span class="keyword">let</span> rect = canvas.getBoundingClientRect();</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    x: <span class="number">2</span> * (x - rect.left), </div><div class="line">    y: <span class="number">2</span> * (y - rect.top),</div><div class="line">  &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>我们将 Touch 相对于屏幕的坐标转换为 Canvas 相对于画布的坐标。代码里的 2 倍是因为我们前面说了要让 retina 屏下清晰，我们将 Canvas 放大为原来的 2 倍。</p><h2 id="API-设计"><a href="#API-设计" class="headerlink" title="API 设计"></a>API 设计</h2><p>接下来我们需要设计给使用者使用的 API 了。在这里，我们将组件功能分解一下，独立出一个单纯记录手势的 Recorder。将组件功能分解为更加底层的组件，是一种简化组件设计的常用模式。</p><p><img src="https://p5.ssl.qhimg.com/t01cf2097cf8acb1cb7.png" alt=""></p><p>我们抽取出底层的 Recorder，让 Locker 继承 Recorder，Recorder 负责记录，Locker 管理实际的设置和验证密码的过程。</p><p>我们的 Recorder 只负责记录用户行为，由于用户操作是异步操作，我们将它设计为 Promise 规范的 API，它可以以如下方式使用：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> recorder = <span class="keyword">new</span> HandLock.Recorder(&#123;</div><div class="line">  container: <span class="built_in">document</span>.querySelector(<span class="string">'#main'</span>)</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">recorded</span>(<span class="params">res</span>)</span>&#123;</div><div class="line">  <span class="keyword">if</span>(res.err)&#123;</div><div class="line">    <span class="built_in">console</span>.error(res.err);</div><div class="line">    recorder.clearPath();</div><div class="line">    <span class="keyword">if</span>(res.err.message !== HandLock.Recorder.ERR_USER_CANCELED)&#123;</div><div class="line">      recorder.record().then(recorded);</div><div class="line">    &#125;</div><div class="line">  &#125;<span class="keyword">else</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(res.records);</div><div class="line">    recorder.record().then(recorded);</div><div class="line">  &#125;      </div><div class="line">&#125;</div><div class="line"></div><div class="line">recorder.record().then(recorded);</div></pre></td></tr></table></figure></p><p>对于输出结果，我们简单用选中圆点的行列坐标拼接起来得到一个唯一的序列。例如 “11121323” 就是如下选择图形：</p><p><img src="https://p4.ssl.qhimg.com/t012a1dd06ae9814468.png" alt=""></p><p>为了让 UI 显示具有灵活性，我们还可以将外观配置抽取出来。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> defaultOptions = &#123;</div><div class="line">  container: <span class="literal">null</span>, <span class="comment">//创建canvas的容器，如果不填，自动在 body 上创建覆盖全屏的层</span></div><div class="line">  focusColor: <span class="string">'#e06555'</span>,  <span class="comment">//当前选中的圆的颜色</span></div><div class="line">  fgColor: <span class="string">'#d6dae5'</span>,     <span class="comment">//未选中的圆的颜色</span></div><div class="line">  bgColor: <span class="string">'#fff'</span>,        <span class="comment">//canvas背景颜色</span></div><div class="line">  n: <span class="number">3</span>, <span class="comment">//圆点的数量： n x n</span></div><div class="line">  innerRadius: <span class="number">20</span>,  <span class="comment">//圆点的内半径</span></div><div class="line">  outerRadius: <span class="number">50</span>,  <span class="comment">//圆点的外半径，focus 的时候显示</span></div><div class="line">  touchRadius: <span class="number">70</span>,  <span class="comment">//判定touch事件的圆半径</span></div><div class="line">  render: <span class="literal">true</span>,     <span class="comment">//自动渲染</span></div><div class="line">  customStyle: <span class="literal">false</span>, <span class="comment">//自定义样式</span></div><div class="line">  minPoints: <span class="number">4</span>,     <span class="comment">//最小允许的点数</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>这样我们实现完整的 Recorder 对象，核心代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div></pre></td><td class="code"><pre><div class="line">[...] <span class="comment">//定义一些私有方法</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> defaultOptions = &#123;</div><div class="line">  container: <span class="literal">null</span>, <span class="comment">//创建canvas的容器，如果不填，自动在 body 上创建覆盖全屏的层</span></div><div class="line">  focusColor: <span class="string">'#e06555'</span>,  <span class="comment">//当前选中的圆的颜色</span></div><div class="line">  fgColor: <span class="string">'#d6dae5'</span>,     <span class="comment">//未选中的圆的颜色</span></div><div class="line">  bgColor: <span class="string">'#fff'</span>,        <span class="comment">//canvas背景颜色</span></div><div class="line">  n: <span class="number">3</span>, <span class="comment">//圆点的数量： n x n</span></div><div class="line">  innerRadius: <span class="number">20</span>,  <span class="comment">//圆点的内半径</span></div><div class="line">  outerRadius: <span class="number">50</span>,  <span class="comment">//圆点的外半径，focus 的时候显示</span></div><div class="line">  touchRadius: <span class="number">70</span>,  <span class="comment">//判定touch事件的圆半径</span></div><div class="line">  render: <span class="literal">true</span>,     <span class="comment">//自动渲染</span></div><div class="line">  customStyle: <span class="literal">false</span>, <span class="comment">//自定义样式</span></div><div class="line">  minPoints: <span class="number">4</span>,     <span class="comment">//最小允许的点数</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Recorder</span></span>&#123;</div><div class="line">  <span class="keyword">static</span> get ERR_NOT_ENOUGH_POINTS()&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">'not enough points'</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">static</span> get ERR_USER_CANCELED()&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">'user canceled'</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">static</span> get ERR_NO_TASK()&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">'no task'</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">constructor</span>(options)&#123;</div><div class="line">    options = <span class="built_in">Object</span>.assign(&#123;&#125;, defaultOptions, options);</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.options = options;</div><div class="line">    <span class="keyword">this</span>.path = [];</div><div class="line"></div><div class="line">    <span class="keyword">if</span>(options.render)&#123;</div><div class="line">      <span class="keyword">this</span>.render();</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  render()&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.circleCanvas) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line"></div><div class="line">    <span class="keyword">let</span> options = <span class="keyword">this</span>.options;</div><div class="line">    <span class="keyword">let</span> container = options.container || <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</div><div class="line"></div><div class="line">    <span class="keyword">if</span>(!options.container &amp;&amp; !options.customStyle)&#123;</div><div class="line">      <span class="built_in">Object</span>.assign(container.style, &#123;</div><div class="line">        position: <span class="string">'absolute'</span>,</div><div class="line">        top: <span class="number">0</span>,</div><div class="line">        left: <span class="number">0</span>,</div><div class="line">        width: <span class="string">'100%'</span>,</div><div class="line">        height: <span class="string">'100%'</span>,</div><div class="line">        lineHeight: <span class="string">'100%'</span>,</div><div class="line">        overflow: <span class="string">'hidden'</span>,</div><div class="line">        backgroundColor: options.bgColor</div><div class="line">      &#125;);</div><div class="line">      <span class="built_in">document</span>.body.appendChild(container); </div><div class="line">    &#125;</div><div class="line">    <span class="keyword">this</span>.container = container;</div><div class="line"></div><div class="line">    <span class="keyword">let</span> &#123;width, height&#125; = container.getBoundingClientRect();</div><div class="line"></div><div class="line">    <span class="comment">//画圆的 canvas，也是最外层监听事件的 canvas</span></div><div class="line">    <span class="keyword">let</span> circleCanvas = <span class="built_in">document</span>.createElement(<span class="string">'canvas'</span>); </div><div class="line"></div><div class="line">    <span class="comment">//2 倍大小，为了支持 retina 屏</span></div><div class="line">    circleCanvas.width = circleCanvas.height = <span class="number">2</span> * <span class="built_in">Math</span>.min(width, height);</div><div class="line">    <span class="keyword">if</span>(!options.customStyle)&#123;</div><div class="line">      <span class="built_in">Object</span>.assign(circleCanvas.style, &#123;</div><div class="line">        position: <span class="string">'absolute'</span>,</div><div class="line">        top: <span class="string">'50%'</span>,</div><div class="line">        left: <span class="string">'50%'</span>,</div><div class="line">        transform: <span class="string">'translate(-50%, -50%) scale(0.5)'</span>, </div><div class="line">      &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//画固定线条的 canvas</span></div><div class="line">    <span class="keyword">let</span> lineCanvas = circleCanvas.cloneNode(<span class="literal">true</span>);</div><div class="line"></div><div class="line">    <span class="comment">//画不固定线条的 canvas</span></div><div class="line">    <span class="keyword">let</span> moveCanvas = circleCanvas.cloneNode(<span class="literal">true</span>);</div><div class="line"></div><div class="line">    container.appendChild(lineCanvas);</div><div class="line">    container.appendChild(moveCanvas);</div><div class="line">    container.appendChild(circleCanvas);</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.lineCanvas = lineCanvas;</div><div class="line">    <span class="keyword">this</span>.moveCanvas = moveCanvas;</div><div class="line">    <span class="keyword">this</span>.circleCanvas = circleCanvas;</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.container.addEventListener(<span class="string">'touchmove'</span>, </div><div class="line">      evt =&gt; evt.preventDefault(), &#123;<span class="attr">passive</span>: <span class="literal">false</span>&#125;);</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.clearPath();</div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">  &#125;</div><div class="line">  clearPath()&#123;</div><div class="line">    <span class="keyword">if</span>(!<span class="keyword">this</span>.circleCanvas) <span class="keyword">this</span>.render();</div><div class="line"></div><div class="line">    <span class="keyword">let</span> &#123;circleCanvas, lineCanvas, moveCanvas&#125; = <span class="keyword">this</span>,</div><div class="line">        circleCtx = circleCanvas.getContext(<span class="string">'2d'</span>),</div><div class="line">        lineCtx = lineCanvas.getContext(<span class="string">'2d'</span>),</div><div class="line">        moveCtx = moveCanvas.getContext(<span class="string">'2d'</span>),</div><div class="line">        width = circleCanvas.width,</div><div class="line">        &#123;n, fgColor, innerRadius&#125; = <span class="keyword">this</span>.options;</div><div class="line"></div><div class="line">    circleCtx.clearRect(<span class="number">0</span>, <span class="number">0</span>, width, width);</div><div class="line">    lineCtx.clearRect(<span class="number">0</span>, <span class="number">0</span>, width, width);</div><div class="line">    moveCtx.clearRect(<span class="number">0</span>, <span class="number">0</span>, width, width);</div><div class="line"></div><div class="line">    <span class="keyword">let</span> range = <span class="built_in">Math</span>.round(width / (n + <span class="number">1</span>));</div><div class="line"></div><div class="line">    <span class="keyword">let</span> circles = [];</div><div class="line"></div><div class="line">    <span class="comment">//drawCircleCenters</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</div><div class="line">      <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</div><div class="line">        <span class="keyword">let</span> y = range * i, x = range * j;</div><div class="line">        drawSolidCircle(circleCtx, fgColor, x, y, innerRadius);</div><div class="line">        <span class="keyword">let</span> circlePoint = &#123;x, y&#125;;</div><div class="line">        circlePoint.pos = [i, j];</div><div class="line">        circles.push(circlePoint);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.circles = circles;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">async</span> cancel()&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.recordingTask)&#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.recordingTask.cancel();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(&#123;<span class="attr">err</span>: <span class="keyword">new</span> <span class="built_in">Error</span>(Recorder.ERR_NO_TASK)&#125;);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">async</span> record()&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.recordingTask) <span class="keyword">return</span> <span class="keyword">this</span>.recordingTask.promise;</div><div class="line"></div><div class="line">    <span class="keyword">let</span> &#123;circleCanvas, lineCanvas, moveCanvas, options&#125; = <span class="keyword">this</span>,</div><div class="line">        circleCtx = circleCanvas.getContext(<span class="string">'2d'</span>),</div><div class="line">        lineCtx = lineCanvas.getContext(<span class="string">'2d'</span>),</div><div class="line">        moveCtx = moveCanvas.getContext(<span class="string">'2d'</span>);</div><div class="line"></div><div class="line">    circleCanvas.addEventListener(<span class="string">'touchstart'</span>, ()=&gt;&#123;</div><div class="line">      <span class="keyword">this</span>.clearPath();</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    <span class="keyword">let</span> records = [];</div><div class="line"></div><div class="line">    <span class="keyword">let</span> handler = <span class="function"><span class="params">evt</span> =&gt;</span> &#123;</div><div class="line">      <span class="keyword">let</span> &#123;clientX, clientY&#125; = evt.changedTouches[<span class="number">0</span>],</div><div class="line">          &#123;bgColor, focusColor, innerRadius, outerRadius, touchRadius&#125; = options,</div><div class="line">          touchPoint = getCanvasPoint(moveCanvas, clientX, clientY);</div><div class="line"></div><div class="line">      <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.circles.length; i++)&#123;</div><div class="line">        <span class="keyword">let</span> point = <span class="keyword">this</span>.circles[i],</div><div class="line">            x0 = point.x,</div><div class="line">            y0 = point.y;</div><div class="line"></div><div class="line">        <span class="keyword">if</span>(distance(point, touchPoint) &lt; touchRadius)&#123;</div><div class="line">          drawSolidCircle(circleCtx, bgColor, x0, y0, outerRadius);</div><div class="line">          drawSolidCircle(circleCtx, focusColor, x0, y0, innerRadius);</div><div class="line">          drawHollowCircle(circleCtx, focusColor, x0, y0, outerRadius);</div><div class="line"></div><div class="line">          <span class="keyword">if</span>(records.length)&#123;</div><div class="line">            <span class="keyword">let</span> p2 = records[records.length - <span class="number">1</span>],</div><div class="line">                x1 = p2.x,</div><div class="line">                y1 = p2.y;</div><div class="line"></div><div class="line">            drawLine(lineCtx, focusColor, x0, y0, x1, y1);</div><div class="line">          &#125;</div><div class="line"></div><div class="line">          <span class="keyword">let</span> circle = <span class="keyword">this</span>.circles.splice(i, <span class="number">1</span>);</div><div class="line">          records.push(circle[<span class="number">0</span>]);</div><div class="line">          <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="keyword">if</span>(records.length)&#123;</div><div class="line">        <span class="keyword">let</span> point = records[records.length - <span class="number">1</span>],</div><div class="line">            x0 = point.x,</div><div class="line">            y0 = point.y,</div><div class="line">            x1 = touchPoint.x,</div><div class="line">            y1 = touchPoint.y;</div><div class="line"></div><div class="line">        moveCtx.clearRect(<span class="number">0</span>, <span class="number">0</span>, moveCanvas.width, moveCanvas.height);</div><div class="line">        drawLine(moveCtx, focusColor, x0, y0, x1, y1);        </div><div class="line">      &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line"></div><div class="line">    circleCanvas.addEventListener(<span class="string">'touchstart'</span>, handler);</div><div class="line">    circleCanvas.addEventListener(<span class="string">'touchmove'</span>, handler);</div><div class="line"></div><div class="line">    <span class="keyword">let</span> recordingTask = &#123;&#125;;</div><div class="line">    <span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</div><div class="line">      recordingTask.cancel = <span class="function">(<span class="params">res = &#123;&#125;</span>) =&gt;</span> &#123;</div><div class="line">        <span class="keyword">let</span> promise = <span class="keyword">this</span>.recordingTask.promise;</div><div class="line"></div><div class="line">        res.err = res.err || <span class="keyword">new</span> <span class="built_in">Error</span>(Recorder.ERR_USER_CANCELED);</div><div class="line">        circleCanvas.removeEventListener(<span class="string">'touchstart'</span>, handler);</div><div class="line">        circleCanvas.removeEventListener(<span class="string">'touchmove'</span>, handler);</div><div class="line">        <span class="built_in">document</span>.removeEventListener(<span class="string">'touchend'</span>, done);</div><div class="line">        resolve(res);</div><div class="line">        <span class="keyword">this</span>.recordingTask = <span class="literal">null</span>;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> promise;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="keyword">let</span> done = <span class="function"><span class="params">evt</span> =&gt;</span> &#123;</div><div class="line">        moveCtx.clearRect(<span class="number">0</span>, <span class="number">0</span>, moveCanvas.width, moveCanvas.height);</div><div class="line">        <span class="keyword">if</span>(!records.length) <span class="keyword">return</span>;</div><div class="line"></div><div class="line">        circleCanvas.removeEventListener(<span class="string">'touchstart'</span>, handler);</div><div class="line">        circleCanvas.removeEventListener(<span class="string">'touchmove'</span>, handler);</div><div class="line">        <span class="built_in">document</span>.removeEventListener(<span class="string">'touchend'</span>, done);</div><div class="line"></div><div class="line">        <span class="keyword">let</span> err = <span class="literal">null</span>;</div><div class="line"></div><div class="line">        <span class="keyword">if</span>(records.length &lt; options.minPoints)&#123;</div><div class="line">          err = <span class="keyword">new</span> <span class="built_in">Error</span>(Recorder.ERR_NOT_ENOUGH_POINTS);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//这里可以选择一些复杂的编码方式，本例子用最简单的直接把坐标转成字符串</span></div><div class="line">        <span class="keyword">let</span> res = &#123;err, <span class="attr">records</span>: records.map(<span class="function"><span class="params">o</span> =&gt;</span> o.pos.join(<span class="string">''</span>)).join(<span class="string">''</span>)&#125;;</div><div class="line"></div><div class="line">        resolve(res);</div><div class="line">        <span class="keyword">this</span>.recordingTask = <span class="literal">null</span>;</div><div class="line">      &#125;;</div><div class="line">      <span class="built_in">document</span>.addEventListener(<span class="string">'touchend'</span>, done);</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    recordingTask.promise = promise;</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.recordingTask = recordingTask;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> promise;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>它的几个公开的方法，recorder 负责记录绘制结果， clearPath 负责在画布上清除上一次记录的结果，cancel 负责终止记录过程，这是为后续流程准备的。</p><h2 id="流程设计"><a href="#流程设计" class="headerlink" title="流程设计"></a>流程设计</h2><p>接下来我们基于 Recorder 来设计设置和验证密码的流程：</p><h3 id="验证密码"><a href="#验证密码" class="headerlink" title="验证密码"></a>验证密码</h3><p><img src="https://p5.ssl.qhimg.com/t01c6fccad2c6c01576.png" alt=""></p><h3 id="设置密码"><a href="#设置密码" class="headerlink" title="设置密码"></a>设置密码</h3><p><img src="https://p4.ssl.qhimg.com/t0122f23e6530a7b6fb.png" alt=""></p><p>有了前面异步 Promise API 的 Recorder，我们不难实现上面的两个流程。</p><h3 id="验证密码的内部流程"><a href="#验证密码的内部流程" class="headerlink" title="验证密码的内部流程"></a>验证密码的内部流程</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">async</span> check(password)&#123;</div><div class="line">  <span class="keyword">if</span>(<span class="keyword">this</span>.mode !== Locker.MODE_CHECK)&#123;</div><div class="line">    <span class="keyword">await</span> <span class="keyword">this</span>.cancel();</div><div class="line">    <span class="keyword">this</span>.mode = Locker.MODE_CHECK;</div><div class="line">  &#125;  </div><div class="line"></div><div class="line">  <span class="keyword">let</span> checked = <span class="keyword">this</span>.options.check.checked;</div><div class="line"></div><div class="line">  <span class="keyword">let</span> res = <span class="keyword">await</span> <span class="keyword">this</span>.record();</div><div class="line"></div><div class="line">  <span class="keyword">if</span>(res.err &amp;&amp; res.err.message === Locker.ERR_USER_CANCELED)&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(res);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">if</span>(!res.err &amp;&amp; password !== res.records)&#123;</div><div class="line">    res.err = <span class="keyword">new</span> <span class="built_in">Error</span>(Locker.ERR_PASSWORD_MISMATCH)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  checked.call(<span class="keyword">this</span>, res);</div><div class="line">  <span class="keyword">this</span>.check(password);</div><div class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(res);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="设置密码的内部流程"><a href="#设置密码的内部流程" class="headerlink" title="设置密码的内部流程"></a>设置密码的内部流程</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">async</span> update()&#123;</div><div class="line">  <span class="keyword">if</span>(<span class="keyword">this</span>.mode !== Locker.MODE_UPDATE)&#123;</div><div class="line">    <span class="keyword">await</span> <span class="keyword">this</span>.cancel();</div><div class="line">    <span class="keyword">this</span>.mode = Locker.MODE_UPDATE;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">let</span> beforeRepeat = <span class="keyword">this</span>.options.update.beforeRepeat, </div><div class="line">      afterRepeat = <span class="keyword">this</span>.options.update.afterRepeat;</div><div class="line"></div><div class="line">  <span class="keyword">let</span> first = <span class="keyword">await</span> <span class="keyword">this</span>.record();</div><div class="line"></div><div class="line">  <span class="keyword">if</span>(first.err &amp;&amp; first.err.message === Locker.ERR_USER_CANCELED)&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(first);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">if</span>(first.err)&#123;</div><div class="line">    <span class="keyword">this</span>.update();</div><div class="line">    beforeRepeat.call(<span class="keyword">this</span>, first);</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(first);   </div><div class="line">  &#125;</div><div class="line"></div><div class="line">  beforeRepeat.call(<span class="keyword">this</span>, first);</div><div class="line"></div><div class="line">  <span class="keyword">let</span> second = <span class="keyword">await</span> <span class="keyword">this</span>.record();      </div><div class="line"></div><div class="line">  <span class="keyword">if</span>(second.err &amp;&amp; second.err.message === Locker.ERR_USER_CANCELED)&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(second);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">if</span>(!second.err &amp;&amp; first.records !== second.records)&#123;</div><div class="line">    second.err = <span class="keyword">new</span> <span class="built_in">Error</span>(Locker.ERR_PASSWORD_MISMATCH);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">this</span>.update();</div><div class="line">  afterRepeat.call(<span class="keyword">this</span>, second);</div><div class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(second);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>可以看到，有了 Recorder 之后，Locker 的验证和设置密码基本上就是顺着流程用 async/await 写下来就行了。</p><h2 id="细节问题"><a href="#细节问题" class="headerlink" title="细节问题"></a>细节问题</h2><p>实际手机触屏时，如果上下拖动，浏览器有默认行为，会导致页面上下移动，需要阻止 touchmove 的默认事件。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.container.addEventListener(<span class="string">'touchmove'</span>, </div><div class="line">      evt =&gt; evt.preventDefault(), &#123;<span class="attr">passive</span>: <span class="literal">false</span>&#125;);</div></pre></td></tr></table></figure></p><p>这里仍然需要注意的一点是， touchmove 事件在 chrome 下默认是一个 <a href="https://dom.spec.whatwg.org/#in-passive-listener-flag" target="_blank" rel="external">Passive Event</a>，因此 addEventListener 的时候需要传参 {passive: false}，否则的话不能 preventDefault。</p><h2 id="工具-amp-工程化"><a href="#工具-amp-工程化" class="headerlink" title="工具 &amp; 工程化"></a>工具 &amp; 工程化</h2><p>因为我们的代码使用了 ES6+，所以需要引入 babel 编译，我们的组件也使用 webpack 进行打包，以便于使用者在浏览器中直接引入。</p><p>这方面的内容，在之前的<a href="https://www.h5jun.com/post/using-webpack2-and-npm-scripts.html" target="_blank" rel="external">博客里有介绍，</a>这里就不再一一说明。</p><p>最后，具体的代码可以直接<a href="https://github.com/akira-cn/handlock" target="_blank" rel="external">查看 GitHub 工程</a>。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上就是今天要讲的全部内容，这里面有几个点我想再强调一下：</p><ol><li>在设计 API 的时候思考真正的需求，判断什么该开放、什么该封装</li><li>做好技术调研和核心方案研究，选择合适的方案</li><li>优化和解决细节问题</li></ol><p>最后，如有任何问题，欢迎大家在下方评论区探讨。</p><p>本文链接：<a href="https://www.h5jun.com/post/handlock-comp.html" target="_blank" rel="external">https://www.h5jun.com/post/handlock-comp.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;纸上得来终觉浅，绝知此事要躬行&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;原文猛戳月影大大博客&lt;a href=&quot;https://www.h5jun.com/post/handlock-comp.html#toc-af9&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;—十年踪迹—-&lt;/a&gt;,读了一遍干货很多，先转过来，后面再慢慢消化。&lt;br&gt;这是&lt;a href=&quot;https://html5.360.cn/star&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;第三届 360 前端星计划&lt;/a&gt;的选拔&lt;a href=&quot;https://www.h5jun.com/post/75team-star-handlock.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;作业题&lt;/a&gt;。600多名学生参与了解答，最后通过了60人。这60名同学完成的不错，思路、代码风格、功能完成度颇有可取之处，不过也有一些欠考虑的地方，比如发现很多同学能按照需求实现完整的功能，但是不知道应当如何&lt;em&gt;设计开放的 API&lt;/em&gt;，或者说，如何分析和预判产品需求和未来的变化，从而决定什么应当开放，什么应当封装。这无关于答案正确与否，还是和经验有关。&lt;br&gt;
    
    </summary>
    
      <category term="编程实战" scheme="https://dsb123dsb.github.io/categories/%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="js" scheme="https://dsb123dsb.github.io/tags/js/"/>
    
      <category term="工程化" scheme="https://dsb123dsb.github.io/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>实现font-size响应式</title>
    <link href="https://dsb123dsb.github.io/2017/04/28/%E5%AE%9E%E7%8E%B0font-size%E5%93%8D%E5%BA%94%E5%BC%8F/"/>
    <id>https://dsb123dsb.github.io/2017/04/28/实现font-size响应式/</id>
    <published>2017-04-28T01:24:20.000Z</published>
    <updated>2017-10-03T13:53:51.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>纸上得来终觉浅，绝知此事要躬行</p></blockquote><p>前几天看阮一峰微博发了个简略的响应式字体的代码，专门搜了下文章系统地学习了一遍—–<a href="https://segmentfault.com/a/1190000006824046" target="_blank" rel="external">原文猛搓——</a><br>本文样式代码采用 SCSS。</p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>那么多的文章讲了响应式的网站如何布局，使用 CSS 如何实现，如何 Blah Blah 的。但是，我们都忘了很重要的一点——对字体大小的响应式控制。<br>现在的很多网站，从布局上来说，尽管是响应式的(当然，或许可以说成所谓响应式的)。但是，从字体上来说，却不一定是响应式的。虽然，每个网站可能会通过某些方式(比如频繁使用<code>@media</code> )来让自己的网站在不同的屏幕大小下显示不同大小的字体，但是，这样不能叫做响应式，这<em>只是一种适应式</em>的做法。</p><p>那么，怎么样才能对我们的 font-size 实现真正的响应式呢？</p><p>我们需要做的主要有以下两点：</p><ol><li><p>制定一个最大的和最小的屏幕宽度值，我们的 <code>font-size</code> 应该是在这个屏幕范围内平滑均匀的变化；<br>不可能让字体大小一直不停的变化。试想一下，自己一直缩小或者方法浏览器，字体一直变小或者变大的场景。</p></li><li><p>制定最大和最小的 <code>font-siz</code>e，屏幕大小小于最小的屏幕宽度值的时候，应用最小的 font-size，反之，应用最大的 font-size；</p></li></ol><p>OK，计划制定好了，那么，应该如何实施呢？我们需要用到哪些技术呢？<br>其实要用到的技术不多，只是，我们需要把脑子转一下。</p><ul><li>@media：CSS Level 3 提供的媒体查询，只要做过响应式，或者任何适应屏幕功能的肯定用过这个属性。所以，在此不过多解释此属性，详细可查看 <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/@media" target="_blank" rel="external">@media | MDN</a></li><li>vw：Viewport 单位，1vw 相当于屏幕宽度的百分之一。此处也不过多解释，详细可查看<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/length" target="_blank" rel="external"> length | CSS</a></li><li>calc：这是 CSS 提供的一个非常强大的属性，可以用来动态计算 CSS 的值。我们的功能主要就是通过这个函数来实现。详细可查看 <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/calc" target="_blank" rel="external">calc | MDN</a></li></ul><p>OK，需要的技术也齐全了。那么，现在就来一步一步实现。<br><a id="more"></a></p><h1 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h1><p>按照上文中所说的计划那样，我们需要定义四个值，他们分别是最小屏幕宽度，最大屏幕宽度，最小字体，最大字体<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$min-font-size: 14px;</div><div class="line">$max-font-size: 18px;</div><div class="line">$min-screen: 600px;</div><div class="line">$max-screen: 1200px;</div><div class="line">`</div></pre></td></tr></table></figure></p><p>不过，使用 px 来定义字体大小显得不是很优雅，我们可以使用 rem 来定义我们的字体。那么，这时候，就需要先对网站的根元素设置字体大小了。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-pseudo">:root</span> &#123;</div><div class="line">    <span class="attribute">font-size</span>: <span class="number">10px</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>然后，再来更新我们的变量。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$min-font-size: 1.4rem;</div><div class="line">$max-font-size: 1.8rem;</div><div class="line">$min-screen: 600px;</div><div class="line">$max-screen: 1200px;</div></pre></td></tr></table></figure></p><p>我们把我们的变量定义和根元素的 font-size 放在文件的顶部。在这里，我们就不写那些相关的 reset 等样式了。</p><h1 id="加入测试内容"><a href="#加入测试内容" class="headerlink" title="加入测试内容"></a>加入测试内容</h1><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">header</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>This is Header.<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">header</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">section</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">article</span>&gt;</span></div><div class="line">        Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.</div><div class="line">    <span class="tag">&lt;/<span class="name">article</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></div></pre></td></tr></table></figure><h1 id="使用-media-对限制字体大小边界值"><a href="#使用-media-对限制字体大小边界值" class="headerlink" title="使用 @media 对限制字体大小边界值"></a>使用 <code>@media</code> 对限制字体大小边界值</h1><p>上文中说过，在我们的屏幕宽度小于 600px 的时候，字体大小为 1.4rem，屏幕宽度大于 1200px 的时候，字体大小为 1.8rem。这个功能实现起来很简单，只需要应用相应的一小段媒体查询就行了。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">@<span class="keyword">media</span> (min-width: $max-screen) &#123;</div><div class="line">    <span class="selector-tag">article</span> &#123;</div><div class="line">        <span class="attribute">font-size</span>: $max-font-size;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@<span class="keyword">media</span> (max-width: $min-screen) &#123;</div><div class="line">    <span class="selector-tag">article</span> &#123;</div><div class="line">        <span class="attribute">font-size</span>: $min-font-size;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>OK，就这么一段代码，我们就可以将字体大小的边界值进行限制。在屏幕宽度小于或者大于对应的屏幕宽度值的时候，我们的字体大小都会保持在一个恒定的值。</p><p>那么，边界限制做好了，接下来就是要实现真正的响应式了。怎么说呢？我们要让我们的 <code>font-size</code> 在 <code>600px ~ 1200px</code> 的屏幕宽度范围内平滑的变化。当然，这还不够，并不是说，只是给 <code>font-size</code> 设置一个百分比或者任何其他的相对单位，然后让这个字体能够在放大缩小屏幕的同时也能够放大缩小。我们要做的，是要通过精确的大小控制来实现响应式。</p><h1 id="使用-calc-函数实现字体大小的响应式"><a href="#使用-calc-函数实现字体大小的响应式" class="headerlink" title="使用 calc 函数实现字体大小的响应式"></a>使用 <code>calc</code> 函数实现字体大小的响应式</h1><p>仔细看看上文中对字体大小边界值的限制的代码，已经有两个 <code>@media</code> 了，在这个部分，我们肯定还要加一个 <code>@media</code>，是不是显得有点多余？所以，我们可以稍微精简一下。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">article</span> &#123;</div><div class="line">    <span class="attribute">font-size</span>: $min-font-size;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@<span class="keyword">media</span> (min-width: $min-screen) and (max-width: $max-screen) &#123;</div><div class="line">    // ...</div><div class="line">&#125;</div><div class="line"></div><div class="line">@<span class="keyword">media</span> (min-width: $max-screen) &#123;</div><div class="line">    <span class="selector-tag">article</span> &#123;</div><div class="line">        <span class="attribute">font-size</span>: $max-font-size;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>只要两个 <code>@media</code> 其实就够了。对于不在媒体查询范围内的，只需要设置一个默认值就行了。但是，要注意的是，这个默认值一定要写在两个媒体查询规则的前面。否则，会由于 CSS 的层叠的特性，后声明的样式会覆盖掉先声明的样式，从而导致媒体查询规则不起作用。</p><p>那么，要实现在这个屏幕宽度范围内精确平滑的变化，肯定需要用到一点数学计算。</p><ol><li><p>font-size 变化的范围是 1.8rem - 1.4rem = 0.4rem；</p></li><li><p>屏幕宽度的变化范围是 1200px - 600px = 600px；</p></li><li><p>最小的 font-size 是 1.4rem。那么，屏幕宽度只要大于 600px，这个值肯定会增加，同时，只要屏幕宽度达到 1200px，这个值也达到 1.8rem，然后便不再变化；</p></li></ol><p>可以看下图：</p><p><img src="http://i.imgur.com/EeID4wK.jpg" alt=""></p><p>比如，我们现在有三种屏幕宽度，分别是 600px，1000px，1200px。那么，仔细观察左边的参考线，我们将最小的那个屏幕宽度去掉，相当于就剩下了两个值，一个是 a，一个是 b。</p><p>由于 <code>1200px</code> 是我们设置的屏幕宽度的最大值，那么，也就是说，b 的变化范围最大也就是 a 的长度。通俗一点说就是，可以把 a 和 b 看成进度条，a 为 100% 的长度，b 为不断增加或者减少的长度。所以，这里就存在了一个比例值，当 b 为 0 的时候，这个比例也为 0，当 b 为 100% 的时候，这个比例就是 1。</p><p>那么，按照这样的思路，转换到对应 font-size 的变化：变化范围是 0.4rem，这是分母，那么，分子该如何计算呢？我们怎么知道字体增加了多少呢？</p><p>此处肯定是没有减少的。我们是在 600px ~ 1200px 之间变化的，最小的字体为 1.4rem，无论怎么算，字体大小都不会再减小了。<br>所以，此处还有一个小小的转换。想一想，我们变化的不只是字体大小，还有屏幕宽度也在变化。所以，就像图片解释的那样，可以使用屏幕宽度的计算来得到一个相应的比例，然后，乘以 font-size 的变化范围 0.4rem，就可以得到我们增加的字体大小了。然后，在最小 font-size 的基础之上加上这个变化的范围，就可以得到在对应屏幕宽度下的精准的 font-size了。</p><p>所以，使用 <code>calc</code> 可以这样写：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@<span class="keyword">media</span> (min-width: $min-screen) and (max-width: $max-screen) &#123;</div><div class="line">    <span class="selector-tag">article</span> &#123;</div><div class="line">        <span class="attribute">font-size</span>: <span class="built_in">calc</span>($min-font-size + (1.8 - 1.4) * ((<span class="number">100vw</span> - $min-screen) / (<span class="number">1200</span> - <span class="number">600</span>)));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><blockquote><p>注意，<code>calc</code> 函数在计算除法的时候，/ 右边只能是数字，不能带单位。<code>*</code> 要求至少一个参数是数字。</p></blockquote><p>对这个式子我也解释一下，可以看到，其中有个表达式是 <code>100vw - 600px</code>，这是什么意思呢？<br>转换成文字：浏览器可视区域的宽度减去最小宽度。</p><p>其实理解起来很简单，举个例子：假设现在屏幕宽度为 <code>1000px</code>，那么，<code>100vw - 600px</code> 得到的结果为 <code>400px</code>，然后，除以 600，最后得到的是 2 / 3。然后，这个值去乘以 <code>0.4rem</code>，那么，这样就能计算出增加的字体大小值了，然后加上 <code>1.4rem</code>，就能得到最终的一个 <code>font-size</code>了。</p><p>所以，就这样，我们就对 <code>font-size</code> 实现了响应式。不用再通过各种屏幕大小的媒体查询来变化了。<br>值得庆幸的是，此规则对于 <code>line-height</code> 同样适用。</p><p>以下是完整的 SCSS 代码：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">$min-font-size: 1.4rem;</div><div class="line">$max-font-size: 1.8rem;</div><div class="line">$min-screen: 600px;</div><div class="line">$max-screen: 1200px;</div><div class="line"></div><div class="line"><span class="selector-pseudo">:root</span> &#123;</div><div class="line">    <span class="attribute">font-size</span>: <span class="number">10px</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-tag">article</span> &#123;</div><div class="line">    <span class="attribute">font-size</span>: $min-font-size;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@<span class="keyword">media</span> (min-width: $min-screen) and (max-width: $max-screen) &#123;</div><div class="line">    <span class="selector-tag">article</span> &#123;</div><div class="line">        <span class="attribute">font-size</span>: <span class="built_in">calc</span>($min-font-size + (2 - 1.4) * ((<span class="number">100vw</span> - $min-screen) / (<span class="number">1200</span> - <span class="number">800</span>)));</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@<span class="keyword">media</span> (min-width: $max-screen) &#123;</div><div class="line">    <span class="selector-tag">article</span> &#123;</div><div class="line">        <span class="attribute">font-size</span>: $max-font-size;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>References</p><p>   <a href="https://madebymike.com.au/writing/precise-control-responsive-typography/" target="_blank" rel="external">Precise control over responsive typography</a></p><p>   <a href="http://blog.typekit.com/2016/08/17/flexible-typography-with-css-locks/?utm_source=Responsive+Design+Weekly&amp;utm_campaign=dbc98f86d4-Responsive_Design_Weekly_222&amp;utm_medium=email&amp;utm_term=0_df65b6d7c8-dbc98f86d4-59087657&amp;goal=0_df65b6d7c8-dbc98f86d4-59087657&amp;mc_cid=dbc98f86d4&amp;mc_eid=142e875650" target="_blank" rel="external">Flexible typography with CSS locks</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;纸上得来终觉浅，绝知此事要躬行&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;前几天看阮一峰微博发了个简略的响应式字体的代码，专门搜了下文章系统地学习了一遍—–&lt;a href=&quot;https://segmentfault.com/a/1190000006824046&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;原文猛搓——&lt;/a&gt;&lt;br&gt;本文样式代码采用 SCSS。&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;那么多的文章讲了响应式的网站如何布局，使用 CSS 如何实现，如何 Blah Blah 的。但是，我们都忘了很重要的一点——对字体大小的响应式控制。&lt;br&gt;现在的很多网站，从布局上来说，尽管是响应式的(当然，或许可以说成所谓响应式的)。但是，从字体上来说，却不一定是响应式的。虽然，每个网站可能会通过某些方式(比如频繁使用&lt;code&gt;@media&lt;/code&gt; )来让自己的网站在不同的屏幕大小下显示不同大小的字体，但是，这样不能叫做响应式，这&lt;em&gt;只是一种适应式&lt;/em&gt;的做法。&lt;/p&gt;
&lt;p&gt;那么，怎么样才能对我们的 font-size 实现真正的响应式呢？&lt;/p&gt;
&lt;p&gt;我们需要做的主要有以下两点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;制定一个最大的和最小的屏幕宽度值，我们的 &lt;code&gt;font-size&lt;/code&gt; 应该是在这个屏幕范围内平滑均匀的变化；&lt;br&gt;不可能让字体大小一直不停的变化。试想一下，自己一直缩小或者方法浏览器，字体一直变小或者变大的场景。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;制定最大和最小的 &lt;code&gt;font-siz&lt;/code&gt;e，屏幕大小小于最小的屏幕宽度值的时候，应用最小的 font-size，反之，应用最大的 font-size；&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;OK，计划制定好了，那么，应该如何实施呢？我们需要用到哪些技术呢？&lt;br&gt;其实要用到的技术不多，只是，我们需要把脑子转一下。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;@media：CSS Level 3 提供的媒体查询，只要做过响应式，或者任何适应屏幕功能的肯定用过这个属性。所以，在此不过多解释此属性，详细可查看 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/@media&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;@media | MDN&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;vw：Viewport 单位，1vw 相当于屏幕宽度的百分之一。此处也不过多解释，详细可查看&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/length&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt; length | CSS&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;calc：这是 CSS 提供的一个非常强大的属性，可以用来动态计算 CSS 的值。我们的功能主要就是通过这个函数来实现。详细可查看 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/calc&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;calc | MDN&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;OK，需要的技术也齐全了。那么，现在就来一步一步实现。&lt;br&gt;
    
    </summary>
    
      <category term="技术分享" scheme="https://dsb123dsb.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="css" scheme="https://dsb123dsb.github.io/tags/css/"/>
    
      <category term="响应式" scheme="https://dsb123dsb.github.io/tags/%E5%93%8D%E5%BA%94%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>vue2.0仿饿了么webApp踩坑指南</title>
    <link href="https://dsb123dsb.github.io/2017/04/17/vue2-0%E4%BB%BF%E9%A5%BF%E4%BA%86%E4%B9%88webApp%E8%B8%A9%E5%9D%91%E6%8C%87%E5%8D%97/"/>
    <id>https://dsb123dsb.github.io/2017/04/17/vue2-0仿饿了么webApp踩坑指南/</id>
    <published>2017-04-17T04:33:12.000Z</published>
    <updated>2017-10-03T13:53:51.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>纸上得来终觉浅，绝知此事要躬行</p></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>对于vue之前一直都是看官方文档，做一些小的demo，没有完整做过练手项目，慕课网上看到滴滴vue.js权威指南的作者黄轶评价很好，完整的学习了一遍，对于vue的理解也有更大提高，不过视频是网上找的没有花钱买（以后有钱了一定支持作者版权）是vue1.0版本，而构建项目时已经是2.0了，而且很多npm依赖包也有升级，踩了很多坑，做下总结</p><h1 id="vue-router"><a href="#vue-router" class="headerlink" title="vue-router"></a>vue-router</h1><h2 id="html节点创建。"><a href="#html节点创建。" class="headerlink" title="html节点创建。"></a>html节点创建。</h2><p>2.0默认渲染成带有正确链接的 <code>&lt;a&gt;</code> 标签，可以通过配置 tag 属性生成别的标签，比1.0直接写死的好处(摘自官方文档):</p><ol><li>无论是<code>HTML5 history</code>模式还是<code>hash</code>模式，表现行为一致，所以，当你要切换路由模式，或者在IE9降级使用<code>hash</code>模式，无须作任何变动。</li><li>在 HTML5 history 模式下，<code>router-link</code> 会拦截点击事件，让浏览器不在重新加载页面。</li><li>当你在 HTML5 history 模式下使用 base 选项之后，所有的 to 属性都不需要写（基路径）了。</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">   <span class="comment">&lt;!-- vue-router1.0创建路由 --&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">a</span> <span class="attr">v-link</span>=<span class="string">"&#123; path: '/foo' &#125;"</span>&gt;</span>Go to Foo<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">a</span> <span class="attr">v-link</span>=<span class="string">"&#123; path: '/bar' &#125;"</span>&gt;</span>Go to Bar<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line">   <span class="comment">&lt;!-- 2.0使用 router-link 组件来导航. --&gt;</span></div><div class="line">   <span class="comment">&lt;!-- 通过传入 `to` 属性指定链接. --&gt;</span></div><div class="line">   <span class="comment">&lt;!-- &lt;router-link&gt; 默认会被渲染成一个 `&lt;a&gt;` 标签 --&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/foo"</span>&gt;</span>Go to Foo<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/bar"</span>&gt;</span>Go to Bar<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></div><div class="line">   <span class="comment">&lt;!-- 路由出口没有神马变化 --&gt;</span></div><div class="line">   <span class="comment">&lt;!-- 路由匹配到的组件将渲染在这里 --&gt;</span> </div><div class="line"><span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></div></pre></td></tr></table></figure><p>值得一提的是2.0将若切换路由时要保留之前状态，将<code>keep-alive</code>属性改成<code>&lt;keep-alive&gt;&lt;/keep-alive&gt;</code>标签</p><h2 id="js定义路由"><a href="#js定义路由" class="headerlink" title="js定义路由"></a>js定义路由</h2><p>2.0定义路由更加方便，删除了一些方法，创建router，可以直接将组件作为一个对象传入，然后把router挂载到根实例就好<br><a id="more"></a></p><h1 id="v-for-遍历数组对象时的参数顺序变更"><a href="#v-for-遍历数组对象时的参数顺序变更" class="headerlink" title="v-for 遍历数组对象时的参数顺序变更"></a>v-for 遍历数组对象时的参数顺序变更</h1><p>当包含 index或key 时，之前遍历数组对象时的参数顺序是 (index, value)和(key, value)。现在是 (value, index)和(value, key) ，来和 JavaScript 的原生数组方法以及常见的对象迭代器（例如 forEach 和 map）保持一致。<br>同时使用index和key时移除了 $index 和 $key 这两个隐式声明变量，以便在 v-for 中显式定义。这可以使没有太多 Vue 开发经验的开发者更好地阅读代码，并且在处理嵌套循环时也能产生更清晰的行为。</p><h1 id="transition参数替换"><a href="#transition参数替换" class="headerlink" title="transition参数替换"></a>transition参数替换</h1><p>Vue 的过渡系统有了彻底的改变，现在通过使用 <code>&lt;transition&gt;</code> 和 <code>&lt;transition-group&gt;</code> 来包裹元素实现过渡效果，而不再使用 transition 属性<br>在新的过渡系统中，可以通过模板复用过渡效果。</p><h1 id="v-el和v-ref替换"><a href="#v-el和v-ref替换" class="headerlink" title="v-el和v-ref替换"></a>v-el和v-ref替换</h1><p> <code>v-el</code>和<code>v-ref</code>合并为一个<code>ref</code>属性了，可以在组件实例中通过 <code>$refs</code> 来调用。这意味着 <code>v-el:my-element</code> 将写成这样： <code>ref=&quot;myElement&quot;</code>， <code>v-ref:my-component</code> 变成了这样： <code>ref=&quot;myComponent&quot;</code>。绑定在一般元素上时，<code>ref</code> 指<code>DOM</code>元素，绑定在组件上时，<code>ref</code> 为一组件实例。<br>因为 <code>v-ref</code> 不再是一个指令了而是一个特殊的属性，它也可以被动态定义了。这样在和<code>v-for</code> 结合的时候是很有用的：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-for</span>=<span class="string">"item in items"</span> <span class="attr">v-bind:ref</span>=<span class="string">"'item' + item.id"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></div></pre></td></tr></table></figure></p><p>以前 <code>v-el/v-ref</code> 和<code>v-for</code> 一起使用将产生一个<code>DOM</code>数组或者组件数组，因为没法给每个元素一个特定名字。现在你还仍然可以这样做，给每个元素一个同样的<code>ref</code>：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-for</span>=<span class="string">"item in items"</span> <span class="attr">ref</span>=<span class="string">"items"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></div></pre></td></tr></table></figure></p><p>和 1.x 中不同， <code>$refs</code> 不是响应的，因为它们在渲染过程中注册/更新。只有监听变化并重复渲染才能使它们响应。<br>另一方面，设计<code>$refs</code>主要是提供给 <code>js</code> 程序访问的，并不建议在模板中过度依赖使用它。因为这意味着在实例之外去访问实例状态，违背了 Vue 数据驱动的思想。</p><h1 id="dispatch-和-broadcast-替换"><a href="#dispatch-和-broadcast-替换" class="headerlink" title="$dispatch 和 $broadcast 替换"></a>$dispatch 和 $broadcast 替换</h1><p><code>$dispatch</code> 和 <code>$broadcast</code> 已经被弃用。可使用更多简明清晰的组件间通信和更好的状态管理方案，如：Vuex.<br>基于组件树结构的事件流方式实在是让人难以理解，并且在组件结构扩展的过程中会变得越来越脆弱。这种事件方式确实不太好，$dispatch 和 $broadcast 也没有解决兄弟组件间的通信问题。<br>对于$dispatch 和 $broadcast最简单的升级方式就是：通过使用事件中心，允许组件自由交流，无论组件处于组件树的哪一层。<strong>由于 Vue 实例实现了一个事件分发接口，你可以通过实例化一个空的 Vue 实例来实现这个目的</strong>。<br>这些方法的最常见用途之一是父子组件的相互通信。在这些情况下，你可以使用 v-on监听子组件上 $emit 的变化。这可以允许你很方便的添加事件显性。<br>然而，如果是跨多层父子组件通信的话， $emit 并没有什么用。相反，用集中式的事件中间件可以做到简单的升级。这会让组件之间的通信非常顺利，即使是兄弟组件。因为 Vue 通过事件发射器接口执行实例，实际上你可以使用一个空的 Vue 实例。</p><h1 id="生命周期钩子"><a href="#生命周期钩子" class="headerlink" title="生命周期钩子"></a>生命周期钩子</h1><h2 id="ready-替换"><a href="#ready-替换" class="headerlink" title="ready 替换"></a>ready 替换</h2><p>使用新的 mounted 钩子函数替代。应该注意的是，使用 mounted 并不能保证钩子函数中的 this.$el 在 document 中。为此还应该引入 <code>Vue.nextTick</code>/<code>vm.$nextTick</code>。</p><h1 id="stylus"><a href="#stylus" class="headerlink" title="stylus"></a>stylus</h1><p>有一次<code>stylus</code>中tab空格中手动输入了一个空格，导致页面一直渲染不出来，eslint也没很好检查出来，记得卡了一晚上，最后才发现，这应该是我印象最深刻得了<br>下面这幅图是正常的情况<br><img src="http://i.imgur.com/62qCsXA.png" alt=""></p><p>这里是我不小心手动输入的一个空格，注意红色方框部分<br><img src="http://i.imgur.com/xMX1qcH.png" alt=""></p><p>上面两幅图都是把代码选中是的显示，如果不选中，是一模一样的，其实就算选中也很难注意到，而且我是直接在第一幅图的代码基础上手动插入的一个空格，但是我们看到代码并没有因为我多输入一个空格和代码也相应后移，所以这是很难发现的问题</p><p>最后放一张自己做完的效果图：</p><p><img src="http://i.imgur.com/Ww7HXAo.png" alt=""></p><p>总结：当时vue的迁移变化我踩坑是并不知道官方有个专门的迁移指南，全是查找的文档对比区别的，现在才是看的官方迁移指南文档总结的，也算自己踩坑印象更加深刻吧，后面再有新的发现会继续添加</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;纸上得来终觉浅，绝知此事要躬行&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;对于vue之前一直都是看官方文档，做一些小的demo，没有完整做过练手项目，慕课网上看到滴滴vue.js权威指南的作者黄轶评价很好，完整的学习了一遍，对于vue的理解也有更大提高，不过视频是网上找的没有花钱买（以后有钱了一定支持作者版权）是vue1.0版本，而构建项目时已经是2.0了，而且很多npm依赖包也有升级，踩了很多坑，做下总结&lt;/p&gt;
&lt;h1 id=&quot;vue-router&quot;&gt;&lt;a href=&quot;#vue-router&quot; class=&quot;headerlink&quot; title=&quot;vue-router&quot;&gt;&lt;/a&gt;vue-router&lt;/h1&gt;&lt;h2 id=&quot;html节点创建。&quot;&gt;&lt;a href=&quot;#html节点创建。&quot; class=&quot;headerlink&quot; title=&quot;html节点创建。&quot;&gt;&lt;/a&gt;html节点创建。&lt;/h2&gt;&lt;p&gt;2.0默认渲染成带有正确链接的 &lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt; 标签，可以通过配置 tag 属性生成别的标签，比1.0直接写死的好处(摘自官方文档):&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;无论是&lt;code&gt;HTML5 history&lt;/code&gt;模式还是&lt;code&gt;hash&lt;/code&gt;模式，表现行为一致，所以，当你要切换路由模式，或者在IE9降级使用&lt;code&gt;hash&lt;/code&gt;模式，无须作任何变动。&lt;/li&gt;
&lt;li&gt;在 HTML5 history 模式下，&lt;code&gt;router-link&lt;/code&gt; 会拦截点击事件，让浏览器不在重新加载页面。&lt;/li&gt;
&lt;li&gt;当你在 HTML5 history 模式下使用 base 选项之后，所有的 to 属性都不需要写（基路径）了。&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight html&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;   &lt;span class=&quot;comment&quot;&gt;&amp;lt;!-- vue-router1.0创建路由 --&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;v-link&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;&amp;#123; path: &#39;/foo&#39; &amp;#125;&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;Go to Foo&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;a&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;v-link&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;&amp;#123; path: &#39;/bar&#39; &amp;#125;&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;Go to Bar&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;a&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   &lt;span class=&quot;comment&quot;&gt;&amp;lt;!-- 2.0使用 router-link 组件来导航. --&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   &lt;span class=&quot;comment&quot;&gt;&amp;lt;!-- 通过传入 `to` 属性指定链接. --&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   &lt;span class=&quot;comment&quot;&gt;&amp;lt;!-- &amp;lt;router-link&amp;gt; 默认会被渲染成一个 `&amp;lt;a&amp;gt;` 标签 --&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;router-link&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;to&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;/foo&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;Go to Foo&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;router-link&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;router-link&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;to&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;/bar&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;Go to Bar&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;router-link&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   &lt;span class=&quot;comment&quot;&gt;&amp;lt;!-- 路由出口没有神马变化 --&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   &lt;span class=&quot;comment&quot;&gt;&amp;lt;!-- 路由匹配到的组件将渲染在这里 --&amp;gt;&lt;/span&gt; &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;router-view&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;router-view&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;值得一提的是2.0将若切换路由时要保留之前状态，将&lt;code&gt;keep-alive&lt;/code&gt;属性改成&lt;code&gt;&amp;lt;keep-alive&amp;gt;&amp;lt;/keep-alive&amp;gt;&lt;/code&gt;标签&lt;/p&gt;
&lt;h2 id=&quot;js定义路由&quot;&gt;&lt;a href=&quot;#js定义路由&quot; class=&quot;headerlink&quot; title=&quot;js定义路由&quot;&gt;&lt;/a&gt;js定义路由&lt;/h2&gt;&lt;p&gt;2.0定义路由更加方便，删除了一些方法，创建router，可以直接将组件作为一个对象传入，然后把router挂载到根实例就好&lt;br&gt;
    
    </summary>
    
      <category term="编程实战" scheme="https://dsb123dsb.github.io/categories/%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="vue.js" scheme="https://dsb123dsb.github.io/tags/vue-js/"/>
    
  </entry>
  
  <entry>
    <title>图片放大镜效果实现</title>
    <link href="https://dsb123dsb.github.io/2017/04/03/%E5%9B%BE%E7%89%87%E6%94%BE%E5%A4%A7%E9%95%9C%E6%95%88%E6%9E%9C%E5%AE%9E%E7%8E%B0/"/>
    <id>https://dsb123dsb.github.io/2017/04/03/图片放大镜效果实现/</id>
    <published>2017-04-03T04:30:49.000Z</published>
    <updated>2017-10-03T13:53:51.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>纸上得来终觉浅，绝知此事要躬行</p></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前放大镜效果都是用jquery的插件，具体实现也没认真想过，看到一个demo感觉不错，mark下来，<a href="http://www.cnblogs.com/ys-ys/p/6642304.html" target="_blank" rel="external">原来地址猛戳</a></p><p>由项目需要，原生写了个详情页图片放大镜的效果，扔上代码供学习分享，也作为日常笔记…</p><p>效果如图(例子中偷偷链了张天猫的图片，希望没啥事 -。-)：</p><p><img src="http://i.imgur.com/He1ZJU4.gif" alt=""><br><a id="more"></a></p><h1 id="实现过程教简单css"><a href="#实现过程教简单css" class="headerlink" title="实现过程教简单css"></a>实现过程教简单css</h1><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/* 图片容器 */</span></div><div class="line"><span class="selector-class">.imgBox</span>&#123;</div><div class="line">  <span class="attribute">width</span>: <span class="number">200px</span>; <span class="comment">/* 各位大老爷们看着办 */</span></div><div class="line">  <span class="attribute">height</span>: <span class="number">200px</span>; <span class="comment">/* 各位大老爷们看着办 */</span></div><div class="line">  <span class="attribute">position</span>: relative; <span class="comment">/* 必需 */</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* 图片标签 */</span></div><div class="line"><span class="selector-class">.mainImg</span>&#123;</div><div class="line">  <span class="attribute">width</span>: <span class="number">100%</span>; <span class="comment">/* 各位大老爷们看着办，尽量100%好看些[斜眼笑] */</span></div><div class="line">  <span class="attribute">height</span>: <span class="number">100%</span>; <span class="comment">/* 各位大老爷们看着办，尽量100%好看些[斜眼笑] */</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* 遮罩层-既放大区域 */</span></div><div class="line"><span class="selector-class">.glass</span>&#123;</div><div class="line">  <span class="attribute">position</span>: absolute; <span class="comment">/* 必需 */</span></div><div class="line">  <span class="attribute">width</span>: <span class="number">50px</span>; <span class="comment">/* 遮罩层宽度 此处是放大4倍，所以为200/4=50 */</span></div><div class="line">  <span class="attribute">height</span>: <span class="number">50px</span>; <span class="comment">/* 遮罩层高度 此处是放大4倍，所以为200/4=50  */</span></div><div class="line">  <span class="attribute">top</span>: -<span class="number">9999px</span>; <span class="comment">/* 绝对位置，先放远些 */</span></div><div class="line">  <span class="attribute">left</span>: -<span class="number">9999px</span>; <span class="comment">/* 绝对位置，先放远些 */</span></div><div class="line">  <span class="attribute">cursor</span>: move; <span class="comment">/* 鼠标样式，好看些 */</span></div><div class="line">  <span class="attribute">background</span>: <span class="built_in">rgba</span>(0,0,180,0.5); <span class="comment">/* 遮罩层样式，好看些 */</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* 大图所在的容器 */</span></div><div class="line"><span class="selector-class">.imgMax</span>&#123;</div><div class="line">  <span class="attribute">position</span>: absolute;  <span class="comment">/* 必需 */</span></div><div class="line">  <span class="attribute">overflow</span>: hidden; <span class="comment">/* 必需，盖掉超出的大图[斜眼笑] */</span></div><div class="line">  <span class="attribute">left</span>: <span class="number">210px</span>; <span class="comment">/* 必需，此处为距原图左边10像素 */</span></div><div class="line">  <span class="attribute">top</span>: <span class="number">0</span>; <span class="comment">/* 必需，此处为距上边0像素 */</span></div><div class="line">  <span class="attribute">width</span>: <span class="number">200px</span>; <span class="comment">/* 放大图片容器的宽度 此处此处是放大4倍，为200，保持和原图容器一般大，若此处为400，则是放大2*4倍，那么相应的放大图片应该是200*4*2=1600 */</span></div><div class="line">  <span class="attribute">height</span>: <span class="number">200px</span>; <span class="comment">/* 放大图片容器的高度 此处此处是放大4倍，为200，保持和原图容器一般大，若此处为400，则是放大2*4倍，那么相应的放大图片应该是200*4*2=1600 */</span></div><div class="line">  <span class="attribute">display</span>: none; <span class="comment">/* 先隐藏 */</span></div><div class="line">&#125;</div><div class="line"><span class="selector-class">.maxImg</span>&#123;</div><div class="line">  <span class="attribute">position</span>: absolute; <span class="comment">/* 必需 */</span></div><div class="line">  <span class="attribute">width</span>: <span class="number">800px</span>; <span class="comment">/* 此处是放大4倍，所以为200*4=800  受放大图片所在的容器影响，规则如上 */</span></div><div class="line">  <span class="attribute">height</span>: <span class="number">800px</span>; <span class="comment">/* 此处是放大4倍，所以为200*4=800  受放大图片所在的容器影响，规则如上 */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>上面css中需要注意的就是几个position和缩放比例，注意调整下即可</p><h1 id="来看看布局-html"><a href="#来看看布局-html" class="headerlink" title="来看看布局-html"></a>来看看布局-html</h1><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">&lt;!-- 图片容器 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"J_imgBox imgBox"</span>&gt;</span></div><div class="line">  <span class="comment">&lt;!-- 需要放大的图片-原始图 --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">"J_mainImg mainImg"</span> <span class="attr">src</span>=<span class="string">"http://img.alicdn.com/bao/uploaded/i7/TB1Xpe_NXXXXXXRXFXXGTq09XXX_035318.jpg_430x430q90.jpg"</span> /&gt;</span></div><div class="line">  <span class="comment">&lt;!-- 遮罩-既放大的区域 --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"J_glass glass"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">  <span class="comment">&lt;!-- 大图的容器 --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"J_imgMax imgMax"</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- 大图 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">"J_maxImg maxImg"</span> /&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure><h1 id="主要的js代码"><a href="#主要的js代码" class="headerlink" title="主要的js代码"></a>主要的js代码</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="comment">/* 放大镜函数</span></div><div class="line"><span class="comment">    ** @imgContainer  需要实现放大镜效果的图片容器  此处是 class 为 J_imgBox 的 div</span></div><div class="line"><span class="comment">    */</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">imgZoom</span>(<span class="params">imgContainer</span>)</span>&#123;</div><div class="line"></div><div class="line">      <span class="comment">// 取大图url，不知道淘宝图片规则如何，反正看了详情页的大图和小图url对比，随便写了个替换</span></div><div class="line">      <span class="keyword">var</span> imgUrl = imgContainer.querySelector(<span class="string">'.J_mainImg'</span>).src.replace(<span class="regexp">/\.(jpg|jpeg|png|gif)(_)(\d+)(x)(\d+)(q90)?/g</span>,<span class="string">''</span>);</div><div class="line"></div><div class="line">      <span class="comment">// 取大图标签的节点</span></div><div class="line">      <span class="keyword">var</span> maxImg = imgContainer.querySelector(<span class="string">'.J_maxImg'</span>);</div><div class="line"></div><div class="line">      <span class="comment">// 给该节点的src属性赋值为大图的url</span></div><div class="line">      maxImg.src = imgUrl;</div><div class="line"></div><div class="line">      <span class="comment">// 取大图所在的容器</span></div><div class="line">      <span class="keyword">var</span> maxImgContainer = imgContainer.querySelector(<span class="string">'.J_imgMax'</span>);</div><div class="line"></div><div class="line">      <span class="comment">// 取遮罩块</span></div><div class="line">      <span class="keyword">var</span> glassBlock = imgContainer.querySelector(<span class="string">'.J_glass'</span>);</div><div class="line"></div><div class="line">      <span class="comment">// 取消放大镜效果</span></div><div class="line">      <span class="keyword">var</span> hideMaxImg = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        glassBlock.style.top = <span class="string">'-9999px'</span>;</div><div class="line">        glassBlock.style.left = <span class="string">'-9999px'</span>;</div><div class="line">        maxImgContainer.style.display = <span class="string">'none'</span>;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="comment">// 鼠标移出图片区域，取消放大镜效果</span></div><div class="line">      imgContainer.onmouseout = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">        event.stopPropagation();</div><div class="line">        hideMaxImg();</div><div class="line">      &#125;;</div><div class="line"></div><div class="line">      <span class="comment">// 鼠标在图片区域内移动事件</span></div><div class="line">      imgContainer.onmousemove = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</div><div class="line">        event.stopPropagation();</div><div class="line"></div><div class="line">        <span class="comment">// 取图片容器的大小及其相对于视口的位置，需要实时取，所以放在move事件里</span></div><div class="line">        <span class="keyword">var</span> clientRect = event.currentTarget.getBoundingClientRect();</div><div class="line"></div><div class="line">        <span class="comment">// 获取距鼠标距的上和左的坐标</span></div><div class="line">        <span class="keyword">var</span> leftX = event.clientX - clientRect.left;</div><div class="line">        <span class="keyword">var</span> leftY = event.clientY - clientRect.top;</div><div class="line"></div><div class="line">        <span class="comment">// 动态设置遮罩块的left和top位置  这里需要减去遮罩层的一半，因为鼠标位于遮罩块中心点</span></div><div class="line">        <span class="keyword">var</span> pointerLeft = leftX - <span class="number">25</span>;</div><div class="line">        <span class="keyword">var</span> pointerTop = leftY - <span class="number">25</span>;</div><div class="line"></div><div class="line">        <span class="comment">// 如果鼠标坐标移动超出原始图片区域边缘 则取消放大镜效果  因为这里存在快速移动鼠标到大图区域时，鼠标仍处在外层的图片区域内，并不会触发mouseout事件(虽然中间隔了小小的间距，但是快速移动仍能产生这个bug,如代码下面的图所示)</span></div><div class="line">        <span class="keyword">if</span>((pointerLeft+<span class="number">25</span>) &gt; clientRect.width || pointerLeft &lt; <span class="number">0</span> - <span class="number">25</span> || (pointerTop+<span class="number">25</span>) &gt; clientRect.height || pointerTop &lt; <span class="number">0</span> - <span class="number">25</span>)&#123;</div><div class="line">          hideMaxImg();</div><div class="line">          <span class="keyword">return</span> !<span class="number">1</span>;</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">        <span class="comment">// 遮罩块在最左边的时候，鼠标仍在图片区域内，可在遮罩块左边缘至中心线区域内移动，且这时遮罩块为距左0像素</span></div><div class="line">        <span class="keyword">if</span>(pointerLeft &lt; <span class="number">0</span>)&#123;</div><div class="line">          pointerLeft = <span class="number">0</span>;</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">        <span class="comment">// 同上 右边限制</span></div><div class="line">        <span class="keyword">if</span>(pointerLeft &gt; clientRect.width - <span class="number">50</span>)&#123;</div><div class="line">          pointerLeft = clientRect.width - <span class="number">50</span>;</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">        <span class="comment">// 同上 顶部限制</span></div><div class="line">        <span class="keyword">if</span>(pointerTop &lt; <span class="number">0</span>)&#123;</div><div class="line">          pointerTop = <span class="number">0</span>;</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">        <span class="comment">// 同上 底部限制</span></div><div class="line">        <span class="keyword">if</span>(pointerTop &gt; clientRect.height - <span class="number">50</span>)&#123;</div><div class="line">          pointerTop = clientRect.height - <span class="number">50</span>;</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">        <span class="comment">// 设置遮罩块的位置</span></div><div class="line">        glassBlock.style.left = pointerLeft+<span class="string">'px'</span>;</div><div class="line">        glassBlock.style.top = pointerTop+<span class="string">'px'</span>;</div><div class="line"></div><div class="line">        <span class="comment">// 取遮罩快距离左边的位置和图片区域的宽高比，用于计算大图偏移距离，展示遮罩块所对应的图片区域</span></div><div class="line">        <span class="keyword">var</span> percentLeft = pointerLeft/clientRect.width;</div><div class="line">        <span class="keyword">var</span> percentHeight = pointerTop/clientRect.height;</div><div class="line"></div><div class="line">        <span class="comment">// 设置大图偏移距离 因为其父元素存在 overflow:hidden 所以只会展示对应区块</span></div><div class="line">        maxImg.style.left = -(percentLeft*maxImg.clientWidth)+<span class="string">'px'</span>;</div><div class="line">        maxImg.style.top = -(percentHeight*maxImg.clientHeight)+<span class="string">'px'</span>;</div><div class="line">maxImgContainer.style.display = <span class="string">'block'</span>;<span class="comment">//显示大图容器</span></div><div class="line">      &#125;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> elem = <span class="built_in">document</span>.querySelectorAll(<span class="string">'.J_imgBox'</span>);</div><div class="line"></div><div class="line">    elem.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item,idx</span>)</span>&#123;</div><div class="line">      imgZoom(item)</div><div class="line">    &#125;)</div><div class="line">  &#125;)()</div></pre></td></tr></table></figure><h1 id="出来在平常开发中比较实用的知识"><a href="#出来在平常开发中比较实用的知识" class="headerlink" title="出来在平常开发中比较实用的知识"></a>出来在平常开发中比较实用的知识</h1><ol><li>Element.getBoundingClientRect()<br>Element.getBoundingClientRect()方法返回元素的大小及其相对于视口的位置</li><li>event.target 和 event.currentTarget<ul><li>target：指向触发事件的元素</li><li>currentTarget：指向被绑定事件句柄的元素,只有当绑定的事件处理程序与触发该事件处理程序都为同一个对象的时候，两者相同</li></ul></li><li>event.preventDefault() &amp; event.stopPropagation()<ul><li>preventDefault：如果事件可取消，则取消该事件，而不停止事件的进一步传播</li><li>stopPropagation：阻止捕获和冒泡阶段中当前事件的进一步传播</li></ul></li><li>event.stopPropagation() &amp;event.stopImmediatePropagation()<ul><li>stopPropagation：阻止捕获和冒泡阶段中当前事件的进一步传播</li><li>stopImmediatePropagation：阻止元素上调用相同事件的其他事件监听并阻止冒泡</li></ul></li></ol><p>虽然都是些简单的知识点，在平常开发中也是很实用的，希望能从细节出发，没事多复习复习 -。-~</p><p>后来一时兴起将放大镜写的更傻瓜式配置的插件了… <a href="https://github.com/Program-Monkey/imageZoom/blob/master/imageZoom.js" target="_blank" rel="external">点我看代码(github地址)</a></p><h1 id="imageZoom-js"><a href="#imageZoom-js" class="headerlink" title="imageZoom.js"></a>imageZoom.js</h1><p>最后我把作者封装的插件代码写在下面<br>只需要使用者写一个标签和写图片大小即可的了 0.0 , 只需要配置imgContainer的大小和必须的position:relative，然后写个div ，写上对应class和 图片地址data-src，然后js里调用下imageZoom就行了<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">window</span>)</span>&#123;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">imageZoom</span>(<span class="params">elem,options</span>)</span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> settings = &#123;</div><div class="line">      imgZoom : options &amp;&amp; options.imgZoom || <span class="number">2</span>,</div><div class="line">      marginLeft: options &amp;&amp; options.marginLeft || <span class="number">0</span>,</div><div class="line">      marginTop: options &amp;&amp; options.marginTop || <span class="number">0</span>,</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 获取图片节点</span></div><div class="line">    <span class="keyword">var</span> imgContainer = elem;</div><div class="line"></div><div class="line">    <span class="comment">// 获取图片url</span></div><div class="line">    <span class="keyword">var</span> imgUrl = imgContainer.getAttribute(<span class="string">'data-src'</span>)</div><div class="line">    </div><div class="line">    <span class="comment">//  you need to write your own RegExp to replace my RegExp . This is important ！！！</span></div><div class="line">    <span class="comment">// 用自己的正则代替这里的  因为对图片处理的参数不尽相同，比如我们公司就是?imageView/w/300/h/300</span></div><div class="line">    <span class="keyword">var</span> originalUrl = imgUrl.replace(<span class="regexp">/\.(jpg|jpeg|png|gif)(_)(\d+)(x)(\d+)(q90)?/g</span>,<span class="string">''</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 获取图片节点位置</span></div><div class="line">    <span class="keyword">var</span> elemClientRect = imgContainer.getBoundingClientRect();</div><div class="line"></div><div class="line">    <span class="comment">// 生成小图html</span></div><div class="line">    <span class="keyword">var</span> minImgHtml = <span class="string">'&lt;img style="width:100%;height:100%" src="'</span> + imgUrl + <span class="string">'" /&gt;'</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span>(!settings.marginLeft &amp;&amp; !settings.marginTop)&#123;</div><div class="line">      settings.marginLeft = elemClientRect.width+<span class="number">10</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 生成遮罩html</span></div><div class="line">    <span class="keyword">var</span> glassWidth = elemClientRect.width/settings.imgZoom;</div><div class="line">    <span class="keyword">var</span> glassHeight = elemClientRect.height/settings.imgZoom;</div><div class="line">    <span class="keyword">var</span> glassStyle = <span class="string">'width:'</span> + glassWidth + <span class="string">'px;height:'</span> + glassHeight + <span class="string">'px;'</span>+<span class="string">'position:absolute;top: -9999px;left: -9999px;cursor: move;background: rgba(0,0,180,0.5);'</span></div><div class="line">    <span class="keyword">var</span> glassHtml = <span class="string">'&lt;div class="J_glass" style="'</span> + glassStyle + <span class="string">'" &gt;&lt;/div&gt;'</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 生成大图</span></div><div class="line">    <span class="keyword">var</span> maxImgStyle = <span class="string">'position:absolute;width:'</span> + (elemClientRect.width * settings.imgZoom) + <span class="string">'px;height:'</span> + (elemClientRect.height * settings.imgZoom) + <span class="string">'px;'</span>;</div><div class="line">    <span class="keyword">var</span> maxImgHtml = <span class="string">'&lt;img class="J_maxImg" src="'</span> + originalUrl + <span class="string">'" style="'</span> + maxImgStyle + <span class="string">'" /&gt;'</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 生成大图容器</span></div><div class="line">    <span class="keyword">var</span> maxContainerStyle = <span class="string">'position:absolute;left:'</span> + settings.marginLeft + <span class="string">'px;top:'</span>+ settings.marginTop +<span class="string">'px;width:'</span> + elemClientRect.width + <span class="string">';height:'</span> + elemClientRect.height + <span class="string">';overflow:hidden;display:none'</span>;</div><div class="line">    <span class="keyword">var</span> maxContainerHtml = <span class="string">'&lt;div class="J_imgMax" style="'</span> + maxContainerStyle + <span class="string">'"&gt;'</span> + maxImgHtml + <span class="string">'&lt;/div&gt;'</span>;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> contentHtml = minImgHtml + glassHtml + maxContainerHtml;</div><div class="line"></div><div class="line">    imgContainer.innerHTML = contentHtml;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> maxImgContainer = imgContainer.querySelector(<span class="string">'.J_imgMax'</span>);</div><div class="line">    <span class="keyword">var</span> glassBlock = imgContainer.querySelector(<span class="string">'.J_glass'</span>);</div><div class="line">    <span class="keyword">var</span> maxImg = imgContainer.querySelector(<span class="string">'.J_maxImg'</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 隐藏大图&amp;遮罩</span></div><div class="line">    <span class="keyword">var</span> hideMaxImg = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        glassBlock.style.top = <span class="string">'-9999px'</span>;</div><div class="line">        glassBlock.style.left = <span class="string">'-9999px'</span>;</div><div class="line">        maxImgContainer.style.display = <span class="string">'none'</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    imgContainer.onmouseover = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">      event.stopPropagation();</div><div class="line">      maxImgContainer.style.display = <span class="string">'block'</span>;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    imgContainer.onmouseout = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">      event.stopPropagation();</div><div class="line">      hideMaxImg();</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    imgContainer.onmousemove = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</div><div class="line">      event.stopPropagation();</div><div class="line">      <span class="keyword">var</span> clientRect = event.currentTarget.getBoundingClientRect();</div><div class="line">      <span class="comment">// 获取左右上下坐标</span></div><div class="line">      <span class="keyword">var</span> leftX = event.clientX - clientRect.left;</div><div class="line">      <span class="keyword">var</span> leftY = event.clientY - clientRect.top;</div><div class="line">      <span class="comment">// 动态设置遮罩范围值</span></div><div class="line">      <span class="keyword">var</span> pointerLeft = leftX - glassWidth/<span class="number">2</span>;</div><div class="line">      <span class="keyword">var</span> pointerTop = leftY - glassHeight/<span class="number">2</span>;</div><div class="line">      <span class="keyword">if</span>((pointerLeft+glassWidth/<span class="number">2</span>) &gt; clientRect.width || pointerLeft &lt; <span class="number">0</span> - glassWidth/<span class="number">2</span> || (pointerTop+glassHeight/<span class="number">2</span>) &gt; clientRect.height || pointerTop &lt; <span class="number">0</span> - glassHeight/<span class="number">2</span>)&#123;</div><div class="line">        hideMaxImg();</div><div class="line">        <span class="keyword">return</span> !<span class="number">1</span>;</div><div class="line">      &#125;;</div><div class="line">      <span class="keyword">if</span>(pointerLeft &lt; <span class="number">0</span>)&#123;</div><div class="line">        pointerLeft = <span class="number">0</span>;</div><div class="line">      &#125;;</div><div class="line">      <span class="keyword">if</span>(pointerLeft &gt; clientRect.width - glassWidth)&#123;</div><div class="line">        pointerLeft = clientRect.width - glassWidth;</div><div class="line">      &#125;;</div><div class="line">      <span class="keyword">if</span>(pointerTop &lt; <span class="number">0</span>)&#123;</div><div class="line">        pointerTop = <span class="number">0</span>;</div><div class="line">      &#125;;</div><div class="line">      <span class="keyword">if</span>(pointerTop &gt; clientRect.height - glassHeight)&#123;</div><div class="line">        pointerTop = clientRect.height - glassHeight;</div><div class="line">      &#125;;</div><div class="line">      glassBlock.style.left = pointerLeft;</div><div class="line">      glassBlock.style.top = pointerTop;</div><div class="line">      <span class="keyword">var</span> percentLeft = pointerLeft/clientRect.width;</div><div class="line">      <span class="keyword">var</span> percentHeight = pointerTop/clientRect.height;</div><div class="line">      maxImg.style.left = -(percentLeft*maxImg.clientWidth)+<span class="string">'px'</span>;</div><div class="line">      maxImg.style.top = -(percentHeight*maxImg.clientHeight)+<span class="string">'px'</span>;</div><div class="line">    &#125;;</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">window</span>.imageZoom = imageZoom;<span class="comment">//挂载到全局对象</span></div><div class="line">&#125;)(<span class="built_in">window</span>)</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;纸上得来终觉浅，绝知此事要躬行&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;之前放大镜效果都是用jquery的插件，具体实现也没认真想过，看到一个demo感觉不错，mark下来，&lt;a href=&quot;http://www.cnblogs.com/ys-ys/p/6642304.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;原来地址猛戳&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;由项目需要，原生写了个详情页图片放大镜的效果，扔上代码供学习分享，也作为日常笔记…&lt;/p&gt;
&lt;p&gt;效果如图(例子中偷偷链了张天猫的图片，希望没啥事 -。-)：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/He1ZJU4.gif&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="编程实战" scheme="https://dsb123dsb.github.io/categories/%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="js" scheme="https://dsb123dsb.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>仿百度搜索框智能提示实现</title>
    <link href="https://dsb123dsb.github.io/2017/03/26/%E4%BB%BF%E7%99%BE%E5%BA%A6%E6%90%9C%E7%B4%A2%E6%A1%86%E6%99%BA%E8%83%BD%E6%8F%90%E7%A4%BA%E5%AE%9E%E7%8E%B0/"/>
    <id>https://dsb123dsb.github.io/2017/03/26/仿百度搜索框智能提示实现/</id>
    <published>2017-03-26T03:36:11.000Z</published>
    <updated>2017-10-03T13:53:51.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>纸上得来终觉浅，绝知此事要躬行</p></blockquote><p>找工作难，找实习难，找实习这段时间对自己心里磨砺也是很大，要多写、多看、多温故。前段时间做了到笔试编程题目要求编写类似百度搜索自动完成控件，当时没有写的很完善，花了点时间仔细整理写了下<br>具体题目要求如图：</p><p><img src="http://i.imgur.com/uv8rCAP.jpg" alt=""></p><p>具体思路：</p><ol><li>HTML的oninput事件可以监控input输入，不过题目要求兼容IE8,当时并没有想到，回来查资料有个onproperty事件可以</li><li>自动完成的列表项使用fragement文档片段插入，这要比逐个插入效率高很多，<code>visibility</code>设置<code>hidden</code>，当用监控到户输入匹配项时，更改为<code>visible</code>，</li><li>提示列表鼠标悬浮变色：css伪类<code>li：hover</code></li><li>点击列表项时，值插入输入框：采用事件委托绑定click事件<a id="more"></a></li></ol><p>代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//js部分</span></div><div class="line"><span class="keyword">var</span> EventUntil=&#123;<span class="comment">//跨浏览器事件处理</span></div><div class="line">addhandler:<span class="function"><span class="keyword">function</span>(<span class="params">element,type,handler</span>)</span>&#123;</div><div class="line"><span class="keyword">if</span>(element.addEventListener)&#123;</div><div class="line">element.addEventListener(type,handler,<span class="literal">false</span>);</div><div class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(element.attachEvent)&#123;</div><div class="line">element.attachEvent(<span class="string">'on'</span>+type,handler);</div><div class="line">&#125;<span class="keyword">else</span>&#123;</div><div class="line">element[<span class="string">'on'</span>+type]=handler;</div><div class="line">&#125;</div><div class="line">&#125;,</div><div class="line">getEvent:<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line"><span class="keyword">return</span> event?event:<span class="built_in">window</span>.event;</div><div class="line">&#125;,</div><div class="line">getTarget:<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line"><span class="keyword">return</span> event.target||event.srcElement;</div><div class="line">&#125;,</div><div class="line">preventDefeault:<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line"><span class="keyword">if</span>(preventDefeault)&#123;</div><div class="line">event.preventDefeault();</div><div class="line">&#125;<span class="keyword">else</span>&#123;</div><div class="line">event.returnValue=<span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line">&#125;,</div><div class="line">removhandler:<span class="function"><span class="keyword">function</span>(<span class="params">element,type,handler</span>)</span>&#123;</div><div class="line"><span class="keyword">if</span>(event.removeEventListener)&#123;</div><div class="line">element.removeEventListener(type,handler,<span class="literal">false</span>);</div><div class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(element.detachEvent)&#123;</div><div class="line">element.detachEvent(<span class="string">'on'</span>+type,handler);</div><div class="line">&#125;<span class="keyword">else</span>&#123;</div><div class="line">element[<span class="string">'on'</span>+type]=<span class="literal">null</span>;</div><div class="line">&#125;</div><div class="line">&#125;,</div><div class="line">stopPropagation:<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line"><span class="keyword">if</span>(event.stopPropagation)&#123;</div><div class="line">event.stopPropagation();</div><div class="line">&#125;<span class="keyword">else</span>&#123;</div><div class="line">event.cancelBubble=<span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;;</div><div class="line"><span class="comment">//具体逻辑代码</span></div><div class="line"><span class="keyword">var</span> arr=[<span class="string">"前端学习路线"</span>,<span class="string">"前端工程师"</span>,<span class="string">"前端开发"</span>,<span class="string">"前端框架"</span>],</div><div class="line">box=<span class="built_in">document</span>.getElementById(<span class="string">"input"</span>),</div><div class="line">dis=<span class="built_in">document</span>.getElementById(<span class="string">"dis"</span>);</div><div class="line"><span class="keyword">var</span> el=<span class="literal">false</span>;<span class="comment">//标识已经插入</span></div><div class="line">EventUntil.addhandler(box,<span class="string">'input'</span>,(event)=&gt;&#123;<span class="comment">//1.监听键盘输入</span></div><div class="line">event=EventUntil.getEvent(event);</div><div class="line"><span class="built_in">console</span>.log(event);</div><div class="line"><span class="keyword">if</span>(box.value==<span class="string">"前端"</span>)&#123;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"显示候选"</span>);</div><div class="line"><span class="keyword">var</span> frageMent=<span class="built_in">document</span>.createDocumentFragment(),</div><div class="line">ul=<span class="built_in">document</span>.getElementById(<span class="string">"ul"</span>);</div><div class="line"><span class="keyword">if</span>(el===<span class="literal">false</span>)&#123;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;<span class="comment">//2.插入文档</span></div><div class="line"><span class="keyword">var</span> texNode=<span class="built_in">document</span>.createTextNode(arr[i]);</div><div class="line"><span class="keyword">var</span> li=<span class="built_in">document</span>.createElement(<span class="string">"li"</span>);</div><div class="line">li.id=i;</div><div class="line">li.appendChild(texNode);</div><div class="line">frageMent.appendChild(li);</div><div class="line">&#125;</div><div class="line">ul.appendChild(frageMent);</div><div class="line">&#125;</div><div class="line">el=<span class="literal">true</span>;</div><div class="line">ul.onclick=<span class="function">(<span class="params">event</span>)=&gt;</span>&#123;<span class="comment">//事件委托  点击插入并且提示消失</span></div><div class="line">box.value=arr[event.target.id];</div><div class="line">dis.style.visibility=<span class="string">"hidden"</span>;</div><div class="line">&#125;</div><div class="line">dis.style.visibility=<span class="string">"visible"</span>;</div><div class="line">&#125;</div><div class="line">&#125;);</div><div class="line">box.onporpertychange=<span class="function">(<span class="params">event</span>)=&gt;</span>&#123;<span class="comment">//1.监听键盘输入（兼容ie8）</span></div><div class="line"><span class="built_in">console</span>.log(event);</div><div class="line"><span class="keyword">if</span>(box.value==<span class="string">"a"</span>)&#123;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"显示候选"</span>)</div><div class="line">dis.style.visibility=<span class="string">"visible"</span>;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//html部分</div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">"input"</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">placeholder</span>=<span class="string">"百度一下，你就知道"</span> <span class="attr">id</span>=<span class="string">"input"</span> <span class="attr">name</span>=<span class="string">""</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"dis"</span> <span class="attr">class</span>=<span class="string">"insert"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"ul"</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">//css部分</div><div class="line"><span class="selector-class">.container</span>&#123;</div><div class="line"><span class="attribute">position</span>: absolute;</div><div class="line">         <span class="attribute">top</span>: <span class="number">0</span>; <span class="attribute">left</span>: <span class="number">0</span>; <span class="attribute">bottom</span>: <span class="number">0</span>; <span class="attribute">right</span>: <span class="number">0</span>; </div><div class="line"><span class="attribute">margin</span>: auto;</div><div class="line"><span class="attribute">height</span>: <span class="number">60px</span>;</div><div class="line"><span class="attribute">width</span>: <span class="number">50%</span></div><div class="line">&#125;</div><div class="line">.input&#123;;</div><div class="line"><span class="selector-tag">height</span>: 45<span class="selector-tag">px</span>;</div><div class="line"><span class="selector-tag">width</span>: 100%;</div><div class="line"><span class="selector-tag">margin</span>: 0;</div><div class="line"><span class="selector-tag">padding</span>: 0;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.insert</span>&#123;</div><div class="line"><span class="attribute">position</span>: absolute;</div><div class="line"><span class="attribute">top</span>: <span class="number">50px</span>;</div><div class="line"><span class="attribute">width</span>: <span class="number">100.7%</span>;</div><div class="line"><span class="attribute">margin</span>: <span class="number">0</span>;</div><div class="line"><span class="attribute">padding</span>: <span class="number">0</span>;</div><div class="line"><span class="attribute">visibility</span>: hidden;</div><div class="line">&#125;</div><div class="line"><span class="selector-tag">ul</span> &#123;</div><div class="line"><span class="attribute">list-style-type</span>: none;</div><div class="line"><span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#eee</span>;</div><div class="line"><span class="attribute">margin</span>: <span class="number">0</span>;</div><div class="line"><span class="attribute">padding</span>:<span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">/*悬浮变色，替代 鼠标事件*/</span></div><div class="line"><span class="selector-tag">li</span><span class="selector-pseudo">:hover</span>&#123;</div><div class="line"><span class="attribute">background</span>: <span class="number">#eea</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>最后实现效果<br><img src="http://i.imgur.com/3EHyVLS.gif" alt=""></p><p>总结：做完感觉需求挺简单的，可是写的时候发现细节还是蛮多，查api测试算下来也花了将近两个小时才完善，汗颜。。而且写的也只是一个很简单的demo，继续努力fighting</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;纸上得来终觉浅，绝知此事要躬行&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;找工作难，找实习难，找实习这段时间对自己心里磨砺也是很大，要多写、多看、多温故。前段时间做了到笔试编程题目要求编写类似百度搜索自动完成控件，当时没有写的很完善，花了点时间仔细整理写了下&lt;br&gt;具体题目要求如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/uv8rCAP.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;具体思路：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;HTML的oninput事件可以监控input输入，不过题目要求兼容IE8,当时并没有想到，回来查资料有个onproperty事件可以&lt;/li&gt;
&lt;li&gt;自动完成的列表项使用fragement文档片段插入，这要比逐个插入效率高很多，&lt;code&gt;visibility&lt;/code&gt;设置&lt;code&gt;hidden&lt;/code&gt;，当用监控到户输入匹配项时，更改为&lt;code&gt;visible&lt;/code&gt;，&lt;/li&gt;
&lt;li&gt;提示列表鼠标悬浮变色：css伪类&lt;code&gt;li：hover&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;点击列表项时，值插入输入框：采用事件委托绑定click事件
    
    </summary>
    
      <category term="编程实战" scheme="https://dsb123dsb.github.io/categories/%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="笔试" scheme="https://dsb123dsb.github.io/tags/%E7%AC%94%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>笔记-网易游戏笔试题目</title>
    <link href="https://dsb123dsb.github.io/2017/03/11/%E7%AC%94%E8%AE%B0-%E7%BD%91%E6%98%93%E6%B8%B8%E6%88%8F%E7%AC%94%E8%AF%95%E9%A2%98%E7%9B%AE/"/>
    <id>https://dsb123dsb.github.io/2017/03/11/笔记-网易游戏笔试题目/</id>
    <published>2017-03-11T13:23:33.000Z</published>
    <updated>2017-10-03T13:53:51.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>纸上得来终觉浅，绝知此事要躬行</p></blockquote><ol><li><p>给定一个字符串，请你将字符串重新编码，将连续的字符替换成“连续出现的个数+字符”。比如字符串AAAABCCDAA会被编码成4A1B2C1D2A。</p><ul><li><p>常规解法：遍历字符串</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> key=<span class="string">"AAAABCCDAA"</span>,</div><div class="line">result=<span class="string">""</span>,</div><div class="line">lastKey=<span class="string">""</span>,</div><div class="line">lastCount=<span class="number">0</span>,</div><div class="line">currentKey;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;key.length;i++)&#123;</div><div class="line">currentKey=key.substr(i,<span class="number">1</span>);<span class="comment">//获取当前字符</span></div><div class="line"><span class="keyword">if</span>(lastKey==curentKey)&#123;<span class="comment">//判断当前字符是否读取完毕</span></div><div class="line">lastCount++;<span class="comment">//读取当前字符个数</span></div><div class="line">&#125;<span class="keyword">else</span>&#123;</div><div class="line"><span class="keyword">if</span>(lastKey!=<span class="string">""</span>)&#123;</div><div class="line">result+=lastKCount+lastKey;<span class="comment">//保存当前字符状态</span></div><div class="line">&#125;</div><div class="line">lastKey=currentKey;<span class="comment">//开始或者当前字符读取完毕重置为下个字符</span></div><div class="line">lastCount=<span class="number">1</span>;<span class="comment">//开始或者重置下个字符个数</span></div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//最后一个字符类别补全</span></div><div class="line">result += lastKeyCount + lastKey;</div><div class="line"><span class="built_in">console</span>.log(result);</div></pre></td></tr></table></figure></li><li><p>正则解法：<br>第二种方法，<code>replace</code>方法不多做解释，正则表达式中\1表示原子组，既第一个捕获组，*号表示匹配零个或者多个\1,replace方法第二个参数是个函数，函数两个参数分别为匹配项和第一个捕获组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> key=<span class="string">"AAAABCCDAA"</span>;</div><div class="line"><span class="keyword">var</span> result=key.replace(<span class="regexp">/(\w)\1*/ig</span>,<span class="function"><span class="keyword">function</span>(<span class="params">s,v</span>)</span>&#123;<span class="keyword">return</span> s.length+v;&#125;)</div></pre></td></tr></table></figure></li></ul></li></ol><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;纸上得来终觉浅，绝知此事要躬行&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;给定一个字符串，请你将字符串重新编码，将连续的字符替换成“连续出现的个数+字符”。比如字符串AAAABCCDAA会被编码成4A1B2C1D2A。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;常规解法：遍历字符串&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; key=&lt;span class=&quot;string&quot;&gt;&quot;AAAABCCDAA&quot;&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	result=&lt;span class=&quot;string&quot;&gt;&quot;&quot;&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	lastKey=&lt;span class=&quot;string&quot;&gt;&quot;&quot;&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	lastCount=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	currentKey;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;i&amp;lt;key.length;i++)&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	currentKey=key.substr(i,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;span class=&quot;comment&quot;&gt;//获取当前字符&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(lastKey==curentKey)&amp;#123;&lt;span class=&quot;comment&quot;&gt;//判断当前字符是否读取完毕&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		lastCount++;&lt;span class=&quot;comment&quot;&gt;//读取当前字符个数&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&amp;#125;&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(lastKey!=&lt;span class=&quot;string&quot;&gt;&quot;&quot;&lt;/span&gt;)&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;			result+=lastKCount+lastKey;&lt;span class=&quot;comment&quot;&gt;//保存当前字符状态&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		lastKey=currentKey;&lt;span class=&quot;comment&quot;&gt;//开始或者当前字符读取完毕重置为下个字符&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		lastCount=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;span class=&quot;comment&quot;&gt;//开始或者重置下个字符个数&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//最后一个字符类别补全&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;result += lastKeyCount + lastKey;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(result);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;正则解法：&lt;br&gt;第二种方法，&lt;code&gt;replace&lt;/code&gt;方法不多做解释，正则表达式中\1表示原子组，既第一个捕获组，*号表示匹配零个或者多个\1,replace方法第二个参数是个函数，函数两个参数分别为匹配项和第一个捕获组&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; key=&lt;span class=&quot;string&quot;&gt;&quot;AAAABCCDAA&quot;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; result=key.replace(&lt;span class=&quot;regexp&quot;&gt;/(\w)\1*/ig&lt;/span&gt;,&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;s,v&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; s.length+v;&amp;#125;)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="基础杂谈" scheme="https://dsb123dsb.github.io/categories/%E5%9F%BA%E7%A1%80%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="笔试" scheme="https://dsb123dsb.github.io/tags/%E7%AC%94%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>实现一个函数clone，可以对JavaScript中的5种主要数据类型进行值复制</title>
    <link href="https://dsb123dsb.github.io/2017/03/09/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0clone%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%AF%B9JavaScript%E4%B8%AD%E7%9A%845%E7%A7%8D%E4%B8%BB%E8%A6%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BF%9B%E8%A1%8C%E5%80%BC%E5%A4%8D%E5%88%B6/"/>
    <id>https://dsb123dsb.github.io/2017/03/09/实现一个函数clone，可以对JavaScript中的5种主要数据类型进行值复制/</id>
    <published>2017-03-09T14:24:05.000Z</published>
    <updated>2017-10-03T13:53:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>数据类型：（包括Number、String、Object、Array、Boolean、Null）;<br>主要思路typeof判断基本数据类型，然后对判定同属object的null、Array和object进行单独复制（遍历数组和对象并调用自身clone克隆内部成员）<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">obj</span>)</span>&#123;</div><div class="line"><span class="keyword">var</span> o;</div><div class="line"><span class="keyword">switch</span>(<span class="keyword">typeof</span> obj)&#123;</div><div class="line"><span class="keyword">case</span> <span class="string">"undefined"</span>:</div><div class="line"><span class="keyword">break</span>;</div><div class="line"><span class="keyword">case</span> <span class="string">"string"</span>:</div><div class="line">o=obj+<span class="string">""</span>;</div><div class="line"><span class="keyword">break</span>;</div><div class="line"><span class="keyword">case</span> <span class="string">"number"</span>:</div><div class="line">o=obj<span class="number">-0</span>;</div><div class="line"><span class="keyword">break</span>;</div><div class="line"><span class="keyword">case</span> <span class="string">"object"</span>:<span class="comment">//object具体 分两种情况 对象（Object）或数组（Array）</span></div><div class="line"><span class="keyword">if</span>(obj===<span class="literal">null</span>)&#123;</div><div class="line">o=<span class="literal">null</span>;</div><div class="line">&#125;<span class="keyword">else</span>&#123;</div><div class="line"><span class="keyword">if</span>(<span class="built_in">Object</span>.prototype.toString.call(obj).slice(<span class="number">8</span>,<span class="number">-1</span>)===<span class="string">"Array"</span>)&#123;</div><div class="line">o=[];</div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;obj.length;i++)&#123;</div><div class="line">o.push(clone(obj[i]));<span class="comment">//调用自身克隆数组对象内部成员</span></div><div class="line">&#125;</div><div class="line">&#125;<span class="keyword">else</span>&#123;</div><div class="line">o=&#123;&#125;;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> k <span class="keyword">in</span> obj)&#123;</div><div class="line">o[k]=clone(obj[k]);<span class="comment">//调用自身克隆对象内部成员</span></div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">break</span>;</div><div class="line"><span class="keyword">default</span>;</div><div class="line">o=obj;</div><div class="line"><span class="keyword">break</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> o;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;数据类型：（包括Number、String、Object、Array、Boolean、Null）;&lt;br&gt;主要思路typeof判断基本数据类型，然后对判定同属object的null、Array和object进行单独复制（遍历数组和对象并调用自身clone克隆内部成员）&lt;br
      
    
    </summary>
    
      <category term="基础杂谈" scheme="https://dsb123dsb.github.io/categories/%E5%9F%BA%E7%A1%80%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="学习笔记" scheme="https://dsb123dsb.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>js实现冒泡排序以及优化</title>
    <link href="https://dsb123dsb.github.io/2017/03/07/js%E5%AE%9E%E7%8E%B0%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E4%BB%A5%E5%8F%8A%E4%BC%98%E5%8C%96/"/>
    <id>https://dsb123dsb.github.io/2017/03/07/js实现冒泡排序以及优化/</id>
    <published>2017-03-07T12:17:48.000Z</published>
    <updated>2017-10-03T13:53:51.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>纸上得来终觉浅，绝知此事要躬行</p></blockquote><h1 id="基本思想："><a href="#基本思想：" class="headerlink" title="基本思想："></a>基本思想：</h1><p>在要排序的一组数中，对当前还未排好序的范围内的全部数，自上而下对相邻的两个数依次进行比较和调整，让较大的数往下沉，较小的往上冒。即：每当两相邻的数比较后发现它们的排序与排序要求相反时，就将它们互换。</p><h1 id="算法的实现："><a href="#算法的实现：" class="headerlink" title="算法的实现："></a>算法的实现：</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//冒泡排序</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span>(<span class="params">arr</span>)</span>&#123;</div><div class="line"><span class="keyword">var</span> len=arr.length;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;len<span class="number">-1</span>;i++)&#123;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> j=<span class="number">0</span>;j&lt;len-i<span class="number">-1</span>;j++)&#123;</div><div class="line"><span class="keyword">if</span>(arr[j]&gt;arr[j+<span class="number">1</span>])&#123;</div><div class="line"><span class="keyword">var</span> tmp=arr[j];arr[j]=arr[j+<span class="number">1</span>];arr[j+<span class="number">1</span>]=tmp;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> arr;</div><div class="line">&#125;</div><div class="line">bubbleSort([<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">92</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">111</span>,<span class="number">1</span>,<span class="number">9</span>])</div></pre></td></tr></table></figure><a id="more"></a><h1 id="冒泡排序算法的改进"><a href="#冒泡排序算法的改进" class="headerlink" title="冒泡排序算法的改进"></a>冒泡排序算法的改进</h1><p>对冒泡排序常见的改进方法是加入一标志性变量exchange，用于标志某一趟排序过程中是否有数据交换，如果进行某一趟排序时并没有进行数据交换，则说明数据已经按要求排列好，可立即结束排序，避免不必要的比较过程。本文再提供以下两种改进算法</p><p>1.设置一标志性变量pos,用于记录每趟排序中最后一次进行交换的位置。由于pos位置之后的记录均已交换到位,故在进行下一趟排序时只要扫描到pos位置即可。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//优化</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort1</span>(<span class="params">arr</span>)</span>&#123;</div><div class="line"><span class="keyword">var</span> i=arr.length<span class="number">-1</span>;<span class="comment">//初始时,最后位置保持不变  </span></div><div class="line"><span class="keyword">while</span>(i&gt;<span class="number">0</span>)&#123;</div><div class="line"><span class="keyword">var</span> pos=<span class="number">0</span>;<span class="comment">//每趟开始时,无记录交换</span></div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</div><div class="line"><span class="keyword">if</span>(arr[j]&gt;arr[j+<span class="number">1</span>])&#123;</div><div class="line"><span class="keyword">var</span> tmp=arr[j];arr[j]=arr[j+<span class="number">1</span>];arr[j+<span class="number">1</span>]=tmp;</div><div class="line">pos=j;<span class="comment">//记录最后交换的位置  </span></div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">i=pos;<span class="comment">//为下一趟排序作准备</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> arr;</div><div class="line">&#125;</div><div class="line">bubbleSort1([<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">92</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">111</span>,<span class="number">1</span>,<span class="number">90</span>])</div></pre></td></tr></table></figure></p><p>2．传统冒泡排序中每一趟排序操作只能找到一个最大值或最小值,我们考虑利用在每趟排序中进行正向和反向两遍冒泡的方法一次可以得到两个最终值(最大者和最小者) , 从而使排序趟数几乎减少了一半。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//优化</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort2</span>(<span class="params">arr</span>)</span>&#123;</div><div class="line"><span class="keyword">var</span> low=<span class="number">0</span>;</div><div class="line"><span class="keyword">var</span> high=arr.length<span class="number">-1</span>;<span class="comment">//设置变量的初始值 </span></div><div class="line"><span class="keyword">while</span>(low&lt;high)&#123;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=low;i&lt;high;i++)&#123;<span class="comment">//正向冒泡,找到最大者  </span></div><div class="line"><span class="keyword">if</span>(arr[i]&gt;arr[i+<span class="number">1</span>])&#123;</div><div class="line"><span class="keyword">var</span> tmp=arr[i];arr[i]=arr[i+<span class="number">1</span>];arr[i+<span class="number">1</span>]=tmp;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">--high;<span class="comment">//修改high值, 前移一位 ，最大已经找到一位</span></div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> j=high;j&gt;low;j--)&#123;</div><div class="line"><span class="keyword">if</span>(arr[j]&lt;arr[j<span class="number">-1</span>])&#123;</div><div class="line"><span class="keyword">var</span> tmp=arr[j];arr[j]=arr[j<span class="number">-1</span>];arr[j<span class="number">-1</span>]=tmp;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">--low;<span class="comment">//修改low值,后移一位</span></div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">bubbleSort1([<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">92</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">111</span>,<span class="number">1</span>,<span class="number">99</span>])</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;纸上得来终觉浅，绝知此事要躬行&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;基本思想：&quot;&gt;&lt;a href=&quot;#基本思想：&quot; class=&quot;headerlink&quot; title=&quot;基本思想：&quot;&gt;&lt;/a&gt;基本思想：&lt;/h1&gt;&lt;p&gt;在要排序的一组数中，对当前还未排好序的范围内的全部数，自上而下对相邻的两个数依次进行比较和调整，让较大的数往下沉，较小的往上冒。即：每当两相邻的数比较后发现它们的排序与排序要求相反时，就将它们互换。&lt;/p&gt;
&lt;h1 id=&quot;算法的实现：&quot;&gt;&lt;a href=&quot;#算法的实现：&quot; class=&quot;headerlink&quot; title=&quot;算法的实现：&quot;&gt;&lt;/a&gt;算法的实现：&lt;/h1&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//冒泡排序&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;bubbleSort&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;arr&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; len=arr.length;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;i&amp;lt;len&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;;i++)&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; j=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;j&amp;lt;len-i&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;;j++)&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;			&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(arr[j]&amp;gt;arr[j+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;])&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;			&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; tmp=arr[j];arr[j]=arr[j+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;];arr[j+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]=tmp;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;			&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; arr;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;bubbleSort([&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;92&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;111&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;])&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="基础杂谈" scheme="https://dsb123dsb.github.io/categories/%E5%9F%BA%E7%A1%80%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="js" scheme="https://dsb123dsb.github.io/tags/js/"/>
    
      <category term="算法" scheme="https://dsb123dsb.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>学习笔记-Symbol数据类型</title>
    <link href="https://dsb123dsb.github.io/2017/03/05/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Symbol%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>https://dsb123dsb.github.io/2017/03/05/学习笔记-Symbol数据类型/</id>
    <published>2017-03-05T06:50:01.000Z</published>
    <updated>2017-10-03T13:53:51.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>ES5的对象属性名都是字符串，这容易造成属性名的冲突。ES6引入了一种新的原始数据类型Symbol，表示独一无二的值。它是JavaScript语言的第七种数据类型，前六种:Undefined、Null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。<br>1.Symbol值可以通过<code>Symbol</code>函数生成。既对象的属性名可以有两种类型：原来的字符串、新增的Symbol类型，后者是独一无二的，保证不会与其它属性名产生冲突。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> s=<span class="built_in">Symbol</span>();</div><div class="line"><span class="keyword">typeof</span> s<span class="comment">//"Symbol"</span></div></pre></td></tr></table></figure></p><p>2.值得注意的是<code>Symbol</code>函数前不能使用<code>new</code>命令，否则会报错。因为生成的Symbol是一个原始数据类型的值，不是对象。也就是说由于Symbol不是对象，所以不能添加属性。<br>3.<code>Symbol</code>函数可以接受一个字符串作为参数，表示对<code>Symbol</code>实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> s1=<span class="built_in">Symbol</span>(<span class="string">'foo'</span>);</div><div class="line"><span class="keyword">var</span> s2=<span class="built_in">Symbol</span>(<span class="string">'bar'</span>);</div><div class="line">s1<span class="comment">//Symbol(foo)</span></div><div class="line">s2<span class="comment">//Symbol(bar)</span></div><div class="line">s1.toString()<span class="comment">//"Symbol(foo)"</span></div><div class="line">s2.toString()<span class="comment">//"Symbol(bar)"</span></div></pre></td></tr></table></figure></p><a id="more"></a><p>上面代码，s1和s2是两个<code>Symbol</code>值。如果不加参数，在控制台输出都是<code>Symbol()</code>，注意，参数只是表示对于当前<code>Symbol</code>的描述，因此相同参数的<code>Symbol</code>函数的返回值是不相等的。<br>4.Symbol值不能与其它类型的值进行计算，会报错,但是可以显示转化为字符串、布尔值，不能转为数值<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> sym=<span class="built_in">Symbol</span>(<span class="string">'My symbol'</span>);</div><div class="line"><span class="string">'your symbol is '</span>+sym</div><div class="line"><span class="comment">//报错</span></div><div class="line"><span class="string">`your symbol is <span class="subst">$&#123;sym&#125;</span>`</span></div><div class="line"><span class="comment">//报错</span></div><div class="line"></div><div class="line"><span class="built_in">String</span>(sym)<span class="comment">//'Symbol(My symbol)'</span></div><div class="line">sym.toString()<span class="comment">//'Symbol(My symbol)'</span></div><div class="line"></div><div class="line"><span class="built_in">Boolean</span>(sym)<span class="comment">//true</span></div><div class="line">!sym<span class="comment">//false</span></div><div class="line"></div><div class="line"><span class="keyword">if</span>(sym)&#123;</div><div class="line"><span class="comment">//...&#125;</span></div><div class="line"></div><div class="line"><span class="built_in">Number</span>(sym)<span class="comment">//报错</span></div><div class="line">sym+<span class="number">2</span><span class="comment">//报错</span></div></pre></td></tr></table></figure></p><h1 id="作为属性名的Symbol"><a href="#作为属性名的Symbol" class="headerlink" title="作为属性名的Symbol"></a>作为属性名的Symbol</h1><p>Symbol值作为标识符，用于对象的属性名，能保证不会出现同名属性。对于一个对象有多个模块构成的情况下，能防止一个键不小心改写或覆盖<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> mySymbol=<span class="built_in">Symbol</span>();</div><div class="line"><span class="comment">//第一种写法</span></div><div class="line"><span class="keyword">var</span> a=&#123;&#125;;</div><div class="line">a[mySymbol]=<span class="string">'hello'</span>;</div><div class="line"></div><div class="line"><span class="comment">//第二种写法</span></div><div class="line"><span class="keyword">var</span> a=&#123;</div><div class="line">[mySymbol]:<span class="string">'hello'</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//第三种写法</span></div><div class="line"><span class="keyword">var</span> a=[];</div><div class="line"><span class="built_in">Object</span>.defineProperty(a,mySymbol,&#123;<span class="attr">value</span>:<span class="string">'hello&#125;);</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">//以上写法都得到同样结果哦</span></div><div class="line"><span class="string">a[mySymbol]//'</span>hello<span class="string">'</span></div></pre></td></tr></table></figure></p><p>注意，Symbol值作为对象属性名是，不能用点运算符。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> mySymbol=<span class="built_in">Symbol</span>();</div><div class="line"><span class="keyword">var</span> a=&#123;&#125;;</div><div class="line">a.mySymbol=<span class="string">'hello'</span>;</div><div class="line">a[mySymbol]<span class="comment">//undefined</span></div><div class="line">a[<span class="string">'mySymbol'</span>]<span class="comment">//'hello'</span></div></pre></td></tr></table></figure></p><p>上面代码中，因为点运算符后面总是字符串，所以不会读取<code>mySymbol</code>作为标识名所指代的那个值，导致a的属性名实际上是一个字符串，而不是Symbol值，同样在对象内部，使用Symbol值定义属性时，Symbol值必须放在括号之中，否则会被认为字符串<br><code>let s=Symbol();let obj={[s](arg){}}//增强对象写法</code></p><h1 id="属性名的遍历"><a href="#属性名的遍历" class="headerlink" title="属性名的遍历"></a>属性名的遍历</h1><p>Symbol作为属性名，该属性不会出现在<code>for...in</code>、<code>for...of</code>循环中，也不会被<code>Object.keys()</code>、<code>Object.getOwnPropertyNames</code>返回。但是它也不是私有属性，<code>Object.getOwnPropertySymbols</code>方法，获取指定对象的所有Symbol属性名（一个数组），另一个新的API<code>Reflect.ownKeys</code>方法可以返回所有类型的键名。我们可以利用这个特性，为对象定义一些非私有的、但又希望只用于内部的方法（不会被常规方法访问到）。</p><h1 id="Symbol-for-Symbol-keyFor"><a href="#Symbol-for-Symbol-keyFor" class="headerlink" title="Symbol.for(),Symbol.keyFor()"></a>Symbol.for(),Symbol.keyFor()</h1><p>有时，我们希望重新使用同一个<code>Symbol</code>值，<code>Symbol.for</code>方法可以做到这一点。它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的Symbol值。如果有，就返回这个Symbol值，否则就新建并返回一个以该字符串为名称的Symbol值。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> s1=<span class="built_in">Symbol</span>(<span class="string">'foo'</span>);</div><div class="line"><span class="keyword">var</span> s2=<span class="built_in">Symbol</span>(<span class="string">'foo'</span>);</div><div class="line">s1===s2<span class="comment">//true</span></div></pre></td></tr></table></figure></p><p>上面代码中，s1和s2都是Symbol值，但是它们都是同样参数<code>Symbol.for</code>方法生成的，所以实际上是同一个值，它生成的值会被登记在全局环境中供搜索，Symbol()不会，所以每次调用都会返回一个不同的值。</p><p><code>Symbol.keyFor()</code>方法返回一个已经登记的Symbol类型值的key<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> s1=<span class="built_in">Symbol</span>.for(<span class="string">'foo'</span>);</div><div class="line"><span class="built_in">Symbol</span>.keyFor(s1)<span class="comment">//'foo'</span></div><div class="line"><span class="comment">//未登记</span></div><div class="line"><span class="keyword">var</span> s2=<span class="built_in">Symbol</span>(<span class="string">'foo'</span>);</div><div class="line"><span class="built_in">Symbol</span>.keyFor(s2);<span class="comment">//undefined</span></div></pre></td></tr></table></figure></p><p>上面代码，变量s2属于未被登记的Symbol值，所以返回undefined。</p><p>注意：<code>Symbol.for</code>为Symbol值登记的名字，是全局环境的额，可以在不同的iframe或service worker中取到同一个值<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">iframe=<span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>);</div><div class="line">iframe.src=<span class="built_in">String</span>(<span class="built_in">window</span>.location);</div><div class="line"><span class="built_in">document</span>.body.appendChild(iframe);</div><div class="line">iframe.contentWindow.Symbol.for(<span class="string">'foo'</span>)===<span class="built_in">Symbol</span>.for(<span class="string">'foo'</span>)<span class="comment">//true</span></div></pre></td></tr></table></figure></p><h1 id="实例：模块的Singleton模式"><a href="#实例：模块的Singleton模式" class="headerlink" title="实例：模块的Singleton模式"></a>实例：模块的Singleton模式</h1><p>Singleton模式指的是调用一个类，任何时候返回的都是同一个实例<br>对于Node来说，模块文件可以看成是一个类。怎么保证每次执行这个模块文件，返回的都是同一个实例呢？<br>很容易想到，可以把实例放到顶层对象<code>global</code>。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//mod.js</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>)</span>&#123;</div><div class="line"><span class="keyword">this</span>.foo=<span class="string">'hello'</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span>(!global._foo)&#123;</div><div class="line">global._foo=<span class="keyword">new</span> A();</div><div class="line">&#125;</div><div class="line"><span class="built_in">module</span>.exports=global._foo</div><div class="line"></div><div class="line"><span class="comment">//加载上面mod.js</span></div><div class="line"><span class="keyword">var</span> a=<span class="built_in">require</span>(<span class="string">'./mod.js'</span>);</div><div class="line"><span class="built_in">console</span>.log(a.foo);</div></pre></td></tr></table></figure></p><p>上面代码中，变量a任何时候加载的都是A的同一个实例，但是问题在于，全局变量<code>global._foo</code>是可写的。任何文件都可以修改它。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a=<span class="built_in">require</span>(<span class="string">'./mod.js'</span>);</div><div class="line">global._foo=<span class="number">123</span>;</div></pre></td></tr></table></figure></p><p>上面的代码，会使得别的脚本加载mod.js脚本都失真。防止这种情况可以使用Symbol<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> FOO_KEY=<span class="built_in">Symbol</span>.for(<span class="string">'foo'</span>);<span class="comment">//1.</span></div><div class="line"><span class="comment">//const FOO_KEY=Symbol('foo');//2.</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>)</span>&#123;</div><div class="line"><span class="keyword">this</span>.foo=<span class="string">'hello'</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span>(!global._foo)&#123;</div><div class="line">global[FOO_KEY]=<span class="keyword">new</span> A();</div><div class="line">&#125;</div><div class="line"><span class="built_in">module</span>.exports=global[FOO_kEY];</div></pre></td></tr></table></figure></p><p>Symbol.for()生成可以保证不会被无意覆盖，但还是可以被改写，Symbol方法生成的话，外部将无法引用这个值，当然无法改写，但这样也有个问题，如果多次执行这个脚本，每次得到FOO_KEY都是不一样的。虽然Node会将脚本执行结果缓存，一般形况下，不会多次执行同一个脚本，但是用户可以手动清除缓存，所以也不是完全可靠。</p><h1 id="内置Symbol值"><a href="#内置Symbol值" class="headerlink" title="内置Symbol值"></a>内置Symbol值</h1><p>内置Symbol值共11个，仅列出以下三个</p><ol><li>Symbol.hasInstance：对象的<code>Symbol.hasInstance</code>属性，指向一个内部方法。当其他对象使用<code>instanceof</code>运算符，判断是否为该对象的实例时，会调用这个方法。比如，<code>foo instanceof Foo在</code>语言内部，实际调用的是<code>Foo[Symbol.hasInstance](foo)</code></li><li>Symbol.isConcatSpreadable：对象的Symbol.isConcatSpreadable属性等于一个布尔值，表示该对象使用<code>Array.prototype.concat()</code>时，是否可以展开，可以手动修改。对于一个类来说，<code>Symbol.isConcatSpreadable</code>属性必须写成实例的属性</li><li>Symbol.species：对象的<code>Symbol.species</code>属性，指向当前对象的构造函数。创造实例时，默认会调用这个方法，即使用这个属性返回的函数当作构造函数，来创造新的实例对象。定义<code>Symbol.species</code>属性要采用get读取器。默认的<code>Symbol.species</code>属性等同于下面的写法。<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> get [<span class="built_in">Symbol</span>.species]()&#123;</div><div class="line"><span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;ES5的对象属性名都是字符串，这容易造成属性名的冲突。ES6引入了一种新的原始数据类型Symbol，表示独一无二的值。它是JavaScript语言的第七种数据类型，前六种:Undefined、Null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。&lt;br&gt;1.Symbol值可以通过&lt;code&gt;Symbol&lt;/code&gt;函数生成。既对象的属性名可以有两种类型：原来的字符串、新增的Symbol类型，后者是独一无二的，保证不会与其它属性名产生冲突。&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; s=&lt;span class=&quot;built_in&quot;&gt;Symbol&lt;/span&gt;();	&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; s&lt;span class=&quot;comment&quot;&gt;//&quot;Symbol&quot;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;2.值得注意的是&lt;code&gt;Symbol&lt;/code&gt;函数前不能使用&lt;code&gt;new&lt;/code&gt;命令，否则会报错。因为生成的Symbol是一个原始数据类型的值，不是对象。也就是说由于Symbol不是对象，所以不能添加属性。&lt;br&gt;3.&lt;code&gt;Symbol&lt;/code&gt;函数可以接受一个字符串作为参数，表示对&lt;code&gt;Symbol&lt;/code&gt;实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; s1=&lt;span class=&quot;built_in&quot;&gt;Symbol&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;foo&#39;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; s2=&lt;span class=&quot;built_in&quot;&gt;Symbol&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;bar&#39;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;s1&lt;span class=&quot;comment&quot;&gt;//Symbol(foo)&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;s2&lt;span class=&quot;comment&quot;&gt;//Symbol(bar)&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;s1.toString()&lt;span class=&quot;comment&quot;&gt;//&quot;Symbol(foo)&quot;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;s2.toString()&lt;span class=&quot;comment&quot;&gt;//&quot;Symbol(bar)&quot;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="基础杂谈" scheme="https://dsb123dsb.github.io/categories/%E5%9F%BA%E7%A1%80%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="学习笔记" scheme="https://dsb123dsb.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Symbol" scheme="https://dsb123dsb.github.io/tags/Symbol/"/>
    
  </entry>
  
</feed>
